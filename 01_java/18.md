<h1>Express√µes Lambda</h1>



Antes de falarmos sobre Express√µes Lambdas, precisamos definir o conceito de Programa√ß√£o Funcional.

<br />

<h2>1. Programa√ß√£o Funcional</h2>



O Paradigma da Programa√ß√£o Funcional √© um estilo de programa√ß√£o que baseia-se na defini√ß√£o e composi√ß√£o de fun√ß√µes, enfatizando a imutabilidade e a aus√™ncia de efeitos colaterais. Ele trata a computa√ß√£o como a avalia√ß√£o de fun√ß√µes e evita o uso de estados mut√°veis e dados compartilhados. 

> **Paradigma de Programa√ß√£o** √© um estilo ou uma forma de se escrever programas de computador, baseado em um conjunto de princ√≠pios, conceitos e t√©cnicas que definem como o c√≥digo √© estruturado, organizado e executado. 

As principais caracter√≠sticas desse paradigma s√£o:

- **Composi√ß√£o de fun√ß√£o**: √© a cria√ß√£o de uma nova fun√ß√£o a partir da combina√ß√£o de outras fun√ß√µes. 
- **Fun√ß√µes puras**: s√£o fun√ß√µes que produzem sempre o mesmo resultado se receberem os mesmos argumentos. Elas n√£o dependem de valores mut√°veis nem causam efeitos colaterais externos.
- **Imutabilidade**: significa que uma vez que uma vari√°vel recebe um valor, ela vai possuir esse valor para sempre, ou quando criamos um objeto ele n√£o pode ser modificado. 

A Programa√ß√£o Funcional tem suas ra√≠zes na matem√°tica e busca oferecer solu√ß√µes elegantes, concisas e robustas para o desenvolvimento de sistemas complexos e altamente abstratos. 

Esse paradigma se fundamenta em um modelo matem√°tico conhecido como **C√°lculo Lambda**, criado por *Alonzo Church* na d√©cada de 1930, com o objetivo de formalizar os conceitos de fun√ß√£o, aplica√ß√£o e recurs√£o. 

O C√°lculo Lambda define uma forma de computa√ß√£o baseada exclusivamente em fun√ß√µes an√¥nimas e aplica√ß√£o de argumentos, sem o uso de vari√°veis mut√°veis ou estruturas de controle imperativas. 

Essa base te√≥rica serviu de inspira√ß√£o para diversas linguagens de programa√ß√£o e, especialmente, para a constru√ß√£o das **Express√µes Lambda**, que s√£o uma implementa√ß√£o pr√°tica e moderna desse conceito. 

Em linguagens de programa√ß√£o de alto n√≠vel, como Java, as Express√µes Lambda permitem representar fun√ß√µes como objetos, de forma concisa e sem a necessidade de declarar classes ou m√©todos nomeados, aproximando a linguagem do paradigma funcional e ampliando seu poder expressivo.

<br />

<h2>2. Paradigmas de Programa√ß√£o - Linguagens de Alto N√≠vel</h2>



Para uma melhor compreens√£o do que √© o Paradigma da Programa√ß√£o Funcional √© importante conhecer os  paradigmas de programa√ß√£o das Linguagens de Alto N√≠vel mais populares: **Programa√ß√£o Imperativa** e **Programa√ß√£o Orientada a Objetos** (POO).

<div align="center"><img src="https://i.imgur.com/EtLQsSx.jpg" title="source: imgur.com" width="90%"/></div>



<h3>2.1. Programa√ß√£o Imperativa</h3>



A **Programa√ß√£o Imperativa** √© um dos paradigmas mais antigos e amplamente utilizados na hist√≥ria da computa√ß√£o. Ela se baseia na execu√ß√£o sequencial de instru√ß√µes que alteram o estado do programa ao longo do tempo. 

Nesse modelo, a pessoa desenvolvedora descreve passo a passo *como* o problema deve ser resolvido, por meio de comandos expl√≠citos, manipula√ß√£o de vari√°veis, atribui√ß√µes de valores, estruturas de repeti√ß√£o e condicionais. O foco est√° no controle do fluxo de execu√ß√£o e na muta√ß√£o de estados. 

Linguagens como **C**, **Pascal** e **COBOL** s√£o exemplos cl√°ssicos desse paradigma, frequentemente utilizadas em contextos onde o desempenho e o controle preciso da mem√≥ria s√£o essenciais.

<div align="center"><img src="https://i.imgur.com/7iY404h.png" title="source: imgur.com" width="80%"/></div>

<br />

<h3>2.2. Programa√ß√£o Orientada a Objetos</h3>



A **Programa√ß√£o Orientada a Objetos (POO)** √© atualmente o paradigma mais popular e amplamente adotado no desenvolvimento de software. Ela se fundamenta na abstra√ß√£o de entidades do mundo real por meio de **objetos**, que encapsulam **atributos** (dados) e **m√©todos** (comportamentos). 

Nesse modelo, a pessoa desenvolvedora descreve *o que* o programa deve fazer organizando o c√≥digo em **classes**, que servem como moldes para cria√ß√£o de objetos. A POO promove conceitos fundamentais como **encapsulamento**, **heran√ßa**, **polimorfismo** e **abstra√ß√£o**, favorecendo a reutiliza√ß√£o de c√≥digo, modularidade e manuten√ß√£o de sistemas. 

Linguagens como **Java**, **C#** e **C++** s√£o exemplos expressivos desse paradigma, sendo amplamente utilizadas em aplica√ß√µes de diferentes portes e finalidades.

<div align="center"><img src="https://i.imgur.com/FJVYTaz.png" title="source: imgur.com" width="80%"/></div>

<br />

<h3>2.3. E a Programa√ß√£o Funcional?</h3>



Diferentemente dos paradigmas Imperativo e Orientado a Objetos, a **Programa√ß√£o Funcional** adota a premissa de que tudo √© fun√ß√£o. Em vez de uma sequ√™ncia de instru√ß√µes que alteram o estado do programa ou a modelagem baseada em objetos, esse paradigma estrutura a solu√ß√£o como uma composi√ß√£o de **fun√ß√µes matem√°ticas puras**, que recebem dados de entrada e produzem resultados sem causar efeitos colaterais.

Nesse modelo, uma fun√ß√£o √© aplicada a um conjunto de dados de entrada e retorna uma sa√≠da, sem modificar os valores originais. A transforma√ß√£o ocorre exclusivamente por meio de opera√ß√µes encadeadas, e o mesmo dado de entrada sempre resultar√° na mesma sa√≠da, garantindo previsibilidade e consist√™ncia.

Outro princ√≠pio fundamental da programa√ß√£o funcional √© a **imutabilidade**: em vez de vari√°veis mut√°veis, utilizam-se **valores constantes**, o que evita altera√ß√µes inesperadas de estado ao longo do tempo. Essa abordagem favorece c√≥digos mais concisos, seguros e f√°ceis de testar, especialmente em ambientes com concorr√™ncia e paralelismo.

Algumas das vantagens de usar esse paradigma s√£o:

- **Facilidade de testar e depurar**: como as fun√ß√µes puras n√£o dependem de estados externos nem causam efeitos colaterais, elas s√£o mais f√°ceis de testar e depurar, pois podemos isolar e reproduzir seus comportamentos.
- **Concorr√™ncia e paralelismo**: como as fun√ß√µes puras n√£o compartilham dados nem modificam estados, elas podem ser executadas em paralelo sem causar conflitos ou inconsist√™ncias.
- **Expressividade e legibilidade**: como as fun√ß√µes s√£o compostas de forma declarativa, elas expressam melhor a inten√ß√£o do c√≥digo e s√£o mais f√°ceis de ler e entender.

Algumas das desvantagens de usar esse paradigma s√£o:

- **Curva de aprendizado**: como a programa√ß√£o funcional usa conceitos e termos diferentes dos paradigmas mais comuns, como a programa√ß√£o orientada a objetos ou a programa√ß√£o imperativa, ela pode ser mais dif√≠cil de aprender e aplicar para quem est√° acostumado com esses estilos.
- **Desempenho**: como a programa√ß√£o funcional evita a muta√ß√£o de dados e usa estruturas de dados imut√°veis, ela pode consumir mais mem√≥ria e processamento do que outras abordagens, especialmente em linguagens que n√£o s√£o otimizadas para esse paradigma.
- **Integra√ß√£o**: como a programa√ß√£o funcional √© menos popular e difundida do que outros paradigmas, ela pode ter menos ferramentas, bibliotecas e recursos dispon√≠veis para integrar com outras tecnologias e sistemas.

Algumas das linguagens de programa√ß√£o que suportam ou seguem o paradigma funcional s√£o: **Haskell**, **Clojure**, **Elixir**, entre outras.

<div align="center"><img src="https://i.imgur.com/fcUE3rV.png" title="source: imgur.com" width="80%"/></div>

<br />

<h2>3. Express√µes Lambda</h2>



Uma **Express√£o Lambda** √© uma forma concisa de representar uma fun√ß√£o an√¥nima ‚Äî ou seja, uma fun√ß√£o sem nome ‚Äî que pode ser definida e utilizada diretamente no corpo de um m√©todo. Essa constru√ß√£o recebe par√¢metros e retorna um valor, comportando-se de maneira semelhante a um m√©todo, por√©m sem a necessidade de declara√ß√£o expl√≠cita em uma classe. 

As Express√µes Lambda foram introduzidas no Java a partir da vers√£o 8, como parte do esfor√ßo para incorporar conceitos da **Programa√ß√£o Funcional** √† linguagem. Com elas, foi poss√≠vel escrever c√≥digos mais **enxutos, leg√≠veis e expressivos**, al√©m de facilitar o uso de APIs que operam com fun√ß√µes como argumentos, como √© o caso do m√©todo `forEach()` e do framework **Streams API**. Essa adi√ß√£o ampliou significativamente a flexibilidade da linguagem, especialmente em cen√°rios que envolvem processamento funcional de cole√ß√µes e programa√ß√£o reativa.

**Sintaxe:**

```java
lista de par√¢metros -> corpo da fun√ß√£o
```

Uma Express√£o Lambda consiste em tr√™s componentes, um conjunto de par√¢metros, um operador Lambda e um corpo de fun√ß√£o. Aqui est√£o os tr√™s componentes:

- **Lista de Par√¢metros:** Aqui vem o argumento que pode ser vazio ou n√£o vazio tamb√©m.
- **Express√£o Lambda:** Express√£o Lambda ou seta (->) √© usada para separar a lista de par√¢metros e o corpo da fun√ß√£o.
- **Corpo da fun√ß√£o:** cont√©m a instru√ß√£o de fun√ß√£o para Express√£o Lambda.

Os par√¢metros de entrada est√£o no lado esquerdo do Operador Lambda e o corpo da fun√ß√£o no lado direito do Operador Lambda. Essa sintaxe do Lambda Expression reduz o volume do c√≥digo, que √© de cinco linhas de c√≥digo em uma linha.

<br />

<h3>2.1. Caracter√≠sticas da Express√£o Lambda</h3>



As principais caracter√≠sticas das Express√µes Lambda s√£o:

1. **Declara√ß√£o de tipo:** a declara√ß√£o de tipo √© opcional. Se voc√™ n√£o declarar o tipo de par√¢metro, o compilador Java consegue inferir (descobrir) o valor do par√¢metro.

<img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/>**Exemplo 01: Express√£o Lambda sem declara√ß√£o de tipo:**

```java
(a, b) -> a + b
```

<br />

2. **Par√™nteses ao redor do par√¢metro:** O par√™ntese ao redor do par√¢metro √© opcional. Voc√™ pode colocar par√™nteses se quiser, caso contr√°rio, deixe como est√°. Se houver mais de um par√¢metro em uma Express√£o Lambda, os par√™nteses s√£o obrigat√≥rios.

<img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/>**Exemplo 02: Express√£o Lambda com 1 Par√¢metro:**

```java
a -> a * a
```

<br />

<img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/>**Exemplo 03: Express√£o Lambda com 2 Par√¢metros:**

```java
(a, b) -> a + b
```

<br />

3. **Chaves:** As chaves ao redor do corpo da fun√ß√£o tamb√©m s√£o opcionais se houver apenas uma instru√ß√£o. Para v√°rias declara√ß√µes, as chaves em torno do corpo da fun√ß√£o s√£o necess√°rias.

<img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/>**Exemplo 04: Express√£o Lambda com v√°rias instru√ß√µes:**

```java
n -> {
	instru√ß√£o 01
	instru√ß√£o 02
	instru√ß√£o 03
	};
```

<br />

4. **Instru√ß√£o de retorno:** A instru√ß√£o de retorno (return) tamb√©m √© opcional em Express√µes Lambda. O compilador Java retorna automaticamente o valor se o corpo tiver uma √∫nica express√£o. Se o corpo da fun√ß√£o retornar um valor, voc√™ deve coloc√°-lo entre chaves.

<img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/>**Exemplo 05: Express√£o Lambda com retorno:**

```java
n -> {
	int retorno = n * n;
	return retorno;
}
```

<br />

<img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/>**Exemplo 06 - Express√µes Lambda e Collections:** 

Nesta primeira vers√£o do c√≥digo, n√£o foram utilizadas as Express√µes Lambdas:

```java
package lambda_collections_01;

import java.util.Arrays;
import java.util.List;

public class Lambda {
	public static void main(String[] args) {

		List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

		System.out.println("Exibir os itens\n");
		
		// Exibir os itens da Lista sem Express√£o Lambda
		for(Integer n : numeros) {
			System.out.println(n);
		}

		System.out.println("\nExibir os itens somados com eles mesmos\n");
		
		// Exibir os itens da Lista dobrados sem Express√£o Lambda
		for(Integer n : numeros) {
			System.out.println(n + n);
		}

		System.out.println("\nExibir os itens pares da lista\n");
		
		// Exibir apenas os elementos pares da Lista sem Express√£o Lambda
		for(Integer n : numeros) {
			if(n%2 == 0)
			System.out.println(n);
		}
	}
}
```

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="25px"/> <a href="https://github.com/rafaelq80/exemplos_java/tree/main/lambda/lambda_collections_v1" target="_blank"><b>C√≥digo fonte: Exemplo 06 - Vers√£o 01</b></a></div>

<br />

Na segunda vers√£o do c√≥digo, foram utilizadas as Express√µes Lambdas:

```java
package lambda_collections_02;

import java.util.Arrays;
import java.util.List;

public class Lambda {
	public static void main(String[] args) {

		List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

		System.out.println("Exibir os itens\n");
		
		// Exibir os itens da Lista com Express√£o Lambda
		numeros.forEach(n -> System.out.println(n));

		System.out.println("\nExibir os itens somados com eles mesmos\n");
		
		// Exibir os itens da Lista dobrados com Express√£o Lambda
		numeros.forEach(n -> System.out.println(n + n));

		System.out.println("\nExibir os itens pares da lista\n");
		
		// Exibir apenas os elementos pares da Lista com Express√£o Lambda
		numeros.forEach(n -> {
			if (n % 2 == 0)
				System.out.println(n);
		});
	}
}
```

Ao comparar a primeira vers√£o do c√≥digo, escrita de forma tradicional, com a segunda vers√£o que utiliza **Express√µes Lambda**, √© poss√≠vel perceber uma redu√ß√£o significativa na verbosidade. O c√≥digo se torna mais direto, leg√≠vel e enxuto, favorecendo a clareza e a manuten√ß√£o.

As Express√µes Lambda foram utilizadas dentro do m√©todo **`forEach()`**, dispon√≠vel na interface **`Iterable`** (implementada por cole√ß√µes como `List`, `Set`, entre outras), justamente porque esse m√©todo espera como argumento uma **interface funcional** ‚Äî no caso, a **`Consumer<T>`**, pertencente ao pacote `java.util.function`.

Por ser uma interface funcional (ou seja, com apenas um m√©todo abstrato), `Consumer<T>` permite que a a√ß√£o a ser executada em cada elemento da cole√ß√£o seja passada diretamente como uma **Express√£o Lambda**. Isso elimina a necessidade de criar classes an√¥nimas ou m√©todos auxiliares, tornando o c√≥digo mais expressivo e alinhado ao paradigma funcional incorporado ao Java a partir da vers√£o 8.

Abaixo, vemos o resultado da execu√ß√£o de ambos os c√≥digos.

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
Exibir os itens

1
2
3
4
5
6
7
8
9

Exibir os itens somados com eles mesmos

2
4
6
8
10
12
14
16
18

Exibir os itens pares da lista

2
4
6
8
```

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank"><b>Documenta√ß√£o: Lambda Expressions</b></a></div>

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="25px"/> <a href="https://github.com/rafaelq80/exemplos_java/tree/main/lambda/lambda_collections_v2" target="_blank"><b>C√≥digo fonte: Exemplo 06 - Vers√£o 02</b></a></div>


<br />

<h2>4. Interfaces Funcionais</h2>



**Interfaces Funcionais** s√£o interfaces que possuem **apenas um m√©todo abstrato**, ou seja, um √∫nico m√©todo que precisa ser implementado. Elas s√£o essenciais para o uso de **Express√µes Lambda** no Java, pois permitem que uma fun√ß√£o an√¥nima seja passada como argumento e associada diretamente a esse m√©todo.

Quando uma Express√£o Lambda √© utilizada, o compilador Java consegue identificar automaticamente qual √© o m√©todo da interface funcional que ser√° executado, justamente porque existe apenas um m√©todo poss√≠vel.

Embora n√£o seja obrigat√≥rio, √© uma boa pr√°tica usar a anota√ß√£o **`@FunctionalInterface`** para indicar que aquela interface foi criada com esse prop√≥sito. Se voc√™ usar essa anota√ß√£o e, por engano, declarar mais de um m√©todo abstrato, o compilador exibir√° um erro ‚Äî ajudando a garantir que a interface siga corretamente o padr√£o funcional.

<br />

<img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/>**Exemplo 07 - Express√µes Lambdas e Interface Funcional:** 

Neste exemplo, vamos desenvolver uma calculadora simples utilizando **Express√µes Lambda**. Para isso, vamos criar uma **Interface Funcional** que servir√° como base para representar as opera√ß√µes matem√°ticas de forma flex√≠vel e reutiliz√°vel.

Come√ßaremos criando a interface chamada **`OperacaoMatematica`**, que define um √∫nico m√©todo abstrato. Esse m√©todo ser√° respons√°vel por executar qualquer opera√ß√£o matem√°tica entre dois n√∫meros inteiros. Com essa estrutura, poderemos passar as opera√ß√µes como Express√µes Lambda sempre que quisermos realizar um c√°lculo, tornando o c√≥digo mais limpo e modular.

**Interface OperacaoMatematica**

```java
package lambda;

@FunctionalInterface
public interface OperacaoMatematica {

	public int executar(int a, int b);

}
```

Dentro da nossa Interface foi assinado o M√©todo Abstrato executar, com 2 par√¢metros inteiros.

Na sequ√™ncia, vamos implementar a Classe **Calculadora**, onde implementaremos a Calculadora propriamente dita:

**Classe Calculadora**

```java
package lambda;

import java.util.Scanner;

public class TestaCalculadora {

	public static int calcular(OperacaoMatematica om, int num1, int num2) {
        return om.executar(num1, num2);
    }
	
	public static void main(String[] args) {

		Scanner leia = new Scanner(System.in);
		
		int n1, n2 = 0;
		
		System.out.println("****************************************************");
		System.out.println("              Calculadora com Lambda                ");
		System.out.println("****************************************************");
		System.out.println("Digite o primeiro numero: ");
		n1 = leia.nextInt();
		System.out.println("Digite o segundo numero: ");
		n2 = leia.nextInt();
		
		System.out.println("Soma = " + calcular((a,b) -> a + b, n1, n2));
        System.out.println("Subtra√ß√£o = " + calcular((a,b) -> a - b, n1, n2));
        System.out.println("Multiplica√ß√£o = " + calcular((a,b) -> a * b, n1, n2));
        System.out.println("Divis√£o = " + calcular((a,b) -> a / b, n1, n2));
		
        leia.close();
        
	}
		
}
```

- Observe que foi criado o m√©todo **`calcular`**, que recebe tr√™s par√¢metros:

  - Um **objeto da interface `OperacaoMatematica`**, que ser√° representado por uma **Express√£o Lambda**. Essa express√£o define qual opera√ß√£o matem√°tica ser√° realizada (como soma, subtra√ß√£o, multiplica√ß√£o ou divis√£o) e ser√° aplicada dentro do m√©todo **`executar()`** da interface.
  - Dois **valores inteiros** (`num1` e `num2`), que representam os n√∫meros de entrada sobre os quais a opera√ß√£o ser√° aplicada.

  Dessa forma, a Express√£o Lambda √© passada como argumento para o m√©todo `calcular`, permitindo que diferentes opera√ß√µes sejam executadas dinamicamente, sem a necessidade de criar m√©todos separados para cada tipo de c√°lculo.

Depois da entrada de dados via teclado, observe a linha da opera√ß√£o de soma:

```java
System.out.println("Soma = " + calcular((a,b) -> a + b, n1, n2));
```

Note que, na chamada do m√©todo **`calcular`**, o primeiro par√¢metro √© uma **Express√£o Lambda** que representa a opera√ß√£o de soma. Essa express√£o √© enviada como argumento e ser√° associada ao m√©todo **`executar()`** da interface funcional `OperacaoMatematica`.

```java
//Express√£o Lambda
(a,b) -> a + b
```

Na sequ√™ncia foram inseridos os 2 n√∫meros inteiros recebidos via teclado, que substituir√£o os par√¢metros a e b na Express√£o Lambda, efetuando a soma dos dois n√∫meros.

As demais Opera√ß√µes seguem a mesma linha de racioc√≠nio.

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
****************************************************
              Calculadora com Lambda                
****************************************************
Digite o primeiro numero: 
10
Digite o segundo numero: 
5
Soma = 15
Subtra√ß√£o = 5
Multiplica√ß√£o = 50
Divis√£o = 2
```

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="25px"/> <a href="https://github.com/rafaelq80/exemplos_java/tree/main/lambda/calculadora_lambda" target="_blank"><b>C√≥digo fonte: Exemplo 07</b></a></div>

<br />

Por fim, √© importante destacar que, ao contr√°rio das fun√ß√µes tradicionais que s√£o definidas com nome e corpo dentro de classes, as **Express√µes Lambda em Java dependem diretamente de interfaces funcionais para funcionar**. Elas n√£o existem de forma isolada: s√≥ podem ser utilizadas quando associadas a uma interface funcional, ou seja, uma interface com exatamente um m√©todo abstrato. Essa associa√ß√£o permite que o compilador saiba qual opera√ß√£o deve ser executada. 

Sem uma interface funcional como base, a Express√£o Lambda n√£o tem contexto e, portanto, n√£o pode ser aplicada. Essa caracter√≠stica √© o que torna o uso de lambdas t√£o poderoso e ao mesmo tempo seguro, garantindo clareza na defini√ß√£o de comportamentos de forma concisa.

------

## üîë**Pontos chave:**

- **Paradigma Imperativo:** baseado em instru√ß√µes sequenciais que alteram o estado do programa. Foco em *como* resolver o problema.
- **Paradigma Orientado a Objetos:** organiza o c√≥digo em objetos com atributos e m√©todos. Usa conceitos como heran√ßa, polimorfismo e encapsulamento.
- **Paradigma Funcional:** inspirado na matem√°tica, usa fun√ß√µes puras, dados imut√°veis e evita efeitos colaterais. O foco est√° em *o que* deve ser feito.
- **Express√£o Lambda:** √© uma fun√ß√£o an√¥nima que pode ser usada como argumento de m√©todos, permitindo escrever c√≥digo mais conciso e funcional.
- **Interface Funcional:** possui apenas um m√©todo abstrato e √© **obrigat√≥ria** para o uso de lambdas em Java. A lambda s√≥ pode ser usada quando o tipo esperado √© uma interface funcional.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
