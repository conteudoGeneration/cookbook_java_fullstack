<h1>Express√µes Lambda</h1>



Antes de falarmos sobre Express√µes Lambdas, precisamos definir o conceito de Programa√ß√£o Funcional.

<br />

<h2>1. Programa√ß√£o Funcional</h2>



O paradigma da programa√ß√£o funcional √© um estilo de programa√ß√£o que se baseia na avalia√ß√£o de express√µes e na aplica√ß√£o de fun√ß√µes matem√°ticas. Ele trata a computa√ß√£o como a avalia√ß√£o de fun√ß√µes e evita o uso de estados mut√°veis e dados compartilhados. 

> **Paradigma Programa√ß√£o** √© um estilo ou uma forma de se escrever programas de computador, baseado em um conjunto de princ√≠pios, conceitos e t√©cnicas que definem como o c√≥digo √© estruturado, organizado e executado. 

As principais caracter√≠sticas desse paradigma s√£o:

- **Composi√ß√£o de fun√ß√£o**: √© a cria√ß√£o de uma nova fun√ß√£o a partir da combina√ß√£o de outras fun√ß√µes. 
- **Fun√ß√µes puras**: s√£o fun√ß√µes que produzem sempre o mesmo resultado se receberem os mesmos argumentos. Elas n√£o dependem de valores mut√°veis nem causam efeitos colaterais externos.
- **Imutabilidade**: significa que uma vez que uma vari√°vel recebe um valor, ela vai possuir esse valor para sempre, ou quando criamos um objeto ele n√£o pode ser modificado. 

A programa√ß√£o funcional √© inspirada nos conceitos da matem√°tica e oferece solu√ß√µes elegantes, concisas e poderosas para lidar com sistemas complexos e abstra√ß√µes. O Paradigma da Programa√ß√£o Funcional √© baseado num modelo Computacional bem antigo, chamado de **C√°lculo Lambda**, por isso ela ganhou o nome **Express√µes Lambda**. 

<br />

<h2>2. Paradigmas de Programa√ß√£o - Linguagens de Alto N√≠vel</h2>



Para uma melhor compreens√£o do que √© o Paradigma da Programa√ß√£o Funcional √© importante conhecer os  paradigmas de programa√ß√£o das Linguagens de Alto N√≠vel mais populares: **Programa√ß√£o Imperativa** e **Programa√ß√£o Orientada a Objetos** (POO).

<div align="center"><img src="https://i.imgur.com/EtLQsSx.jpg" title="source: imgur.com" width="90%"/></div>



<h3>2.1. Programa√ß√£o Imperativa</h3>



√â o paradigma mais antigo e tradicional, que se baseia em instru√ß√µes sequenciais que modificam o estado do programa. A pessoa desenvolvedora especifica como o programa deve resolver o problema, atrav√©s de comandos, vari√°veis, atribui√ß√µes, la√ßos, condicionais, entre outros. Exemplos de linguagens imperativas s√£o C, Pascal e Cobol.

<div align="center"><img src="https://i.imgur.com/7iY404h.png" title="source: imgur.com" width="80%"/></div>

<br />

<h3>2.2. Programa√ß√£o Orientada a Objetos</h3>



√â o paradigma mais popular e difundido atualmente, que se baseia na abstra√ß√£o de entidades do mundo real em objetos que possuem atributos (dados) e m√©todos (comportamentos). A pessoa desenvolvedora especifica o que o programa deve fazer, atrav√©s de classes, objetos, heran√ßa, polimorfismo, encapsulamento, entre outros. Exemplos de linguagens orientadas a objetos s√£o Java, Python e C++.

<div align="center"><img src="https://i.imgur.com/FJVYTaz.png" title="source: imgur.com" width="80%"/></div>

<br />

<h3>2.3. E a Programa√ß√£o Funcional?</h3>



Diferentemente das programa√ß√µes Imperativa e Orientada a Objetos, a Funcional parte do princ√≠pio de que  tudo s√£o fun√ß√µes. N√£o existe uma lista de instru√ß√µes ou objetos para o  computador realizar, mas uma sequ√™ncia de **fun√ß√µes matem√°ticas** que, juntas, v√£o resolver um problema.

Isso significa que, no paradigma funcional, voc√™ tem uma fun√ß√£o,  coloca um dado de entrada, aplica v√°rias opera√ß√µes e obt√©m uma sa√≠da. √â  poss√≠vel alterar as opera√ß√µes e, consequentemente, a sa√≠da, mas a  entrada sempre permanecer√° a mesma.

Al√©m disso, no Paradigma da Programa√ß√£o Funcional n√£o existem vari√°veis, mas constantes. Isso se traduz em c√≥digos mais  objetivos com constantes que, de forma geral, n√£o mudam. 

Algumas das vantagens de usar esse paradigma s√£o:

- **Facilidade de testar e depurar**: como as fun√ß√µes puras n√£o dependem de estados externos nem causam efeitos colaterais, elas s√£o mais f√°ceis de testar e depurar, pois podemos isolar e reproduzir seus comportamentos.
- **Concorr√™ncia e paralelismo**: como as fun√ß√µes puras n√£o compartilham dados nem modificam estados, elas podem ser executadas em paralelo sem causar conflitos ou inconsist√™ncias.
- **Expressividade e legibilidade**: como as fun√ß√µes s√£o compostas de forma declarativa, elas expressam melhor a inten√ß√£o do c√≥digo e s√£o mais f√°ceis de ler e entender.

Algumas das desvantagens de usar esse paradigma s√£o:

- **Curva de aprendizado**: como a programa√ß√£o funcional usa conceitos e termos diferentes dos paradigmas mais comuns, como a programa√ß√£o orientada a objetos ou a programa√ß√£o imperativa, ela pode ser mais dif√≠cil de aprender e aplicar para quem est√° acostumado com esses estilos.
- **Desempenho**: como a programa√ß√£o funcional evita a muta√ß√£o de dados e usa estruturas de dados imut√°veis, ela pode consumir mais mem√≥ria e processamento do que outras abordagens, especialmente em linguagens que n√£o s√£o otimizadas para esse paradigma.
- **Integra√ß√£o**: como a programa√ß√£o funcional √© menos popular e difundida do que outros paradigmas, ela pode ter menos ferramentas, bibliotecas e recursos dispon√≠veis para integrar com outras tecnologias e sistemas.

Algumas das linguagens de programa√ß√£o que suportam ou seguem o paradigma funcional s√£o: Haskell, Clojure, Elixir, entre outras.

<div align="center"><img src="https://i.imgur.com/fcUE3rV.png" title="source: imgur.com" width="80%"/></div>

<br />

<h2>3. Express√µes Lambda</h2>



Uma **Express√£o Lambda** √© um pequeno bloco de c√≥digo que recebe par√¢metros e retorna um valor. Uma express√£o lambda tamb√©m pode ser vista como uma fun√ß√£o an√¥nima. Uma fun√ß√£o que n√£o tem nome e n√£o pertence a nenhuma classe. As Express√µes Lambda s√£o semelhantes aos m√©todos, mas n√£o precisam de um nome e podem ser implementadas diretamente no corpo de um m√©todo. Atrav√©s das Express√µes Lambda o Java adicionou novas Classes, que implementam os conceitos da Programa√ß√£o Funcional, tornando a Linguagem Java mais flex√≠vel, servindo como um complemento para a constru√ß√£o de c√≥digos mais limpos e enxutos.

**Sintaxe:**

```java
lista de par√¢metros -> corpo da fun√ß√£o
```

Uma Express√£o Lambda consiste em tr√™s componentes, um conjunto de par√¢metros, um operador Lambda e um corpo de fun√ß√£o. Aqui est√£o os tr√™s componentes:

- **Lista de Par√¢metros:** Aqui vem o argumento que pode ser vazio ou n√£o vazio tamb√©m.
- **Express√£o Lambda:** Express√£o Lambda ou seta (->) √© usada para separar a lista de par√¢metros e o corpo da fun√ß√£o.
- **Corpo da fun√ß√£o:** cont√©m a instru√ß√£o de fun√ß√£o para Express√£o Lambda.

Os par√¢metros de entrada est√£o no lado esquerdo do Operador Lambda e o corpo da fun√ß√£o no lado direito do Operador Lambda. Essa sintaxe do Lambda Expression reduz o volume do c√≥digo, que √© de cinco linhas de c√≥digo em uma linha.

<br />

<h3>2.1. Caracter√≠sticas da Express√£o Lambda</h3>



As principais caracter√≠sticas das Express√µes Lambda s√£o:

1. **Declara√ß√£o de tipo:** a declara√ß√£o de tipo √© opcional. Se voc√™ n√£o declarar o tipo de par√¢metro, o compilador Java consegue inferir (descobrir) o valor do par√¢metro.

<img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/>**Exemplo 01: Express√£o Lambda sem declara√ß√£o de tipo:**

```java
(5,4) -> corpo da fun√ß√£o
```

<br />

2. **Par√™nteses ao redor do par√¢metro:** O par√™ntese ao redor do par√¢metro √© opcional. Voc√™ pode colocar par√™nteses se quiser, caso contr√°rio, deixe como est√°. Se houver mais de um par√¢metro em uma Express√£o Lambda, os par√™nteses s√£o obrigat√≥rios.

<img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/>**Exemplo 02: Express√£o Lambda com 1 Par√¢metro:**

```java
5 -> corpo da fun√ß√£o
```

<br />

<img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/>**Exemplo 03: Express√£o Lambda com 2 Par√¢metros:**

```java
(5, 4) -> corpo da fun√ß√£o
```

<br />

3. **Chaves:** As chaves ao redor do corpo da fun√ß√£o tamb√©m s√£o opcionais se houver apenas uma instru√ß√£o. Para v√°rias declara√ß√µes, as chaves em torno do corpo da fun√ß√£o s√£o necess√°rias.

<img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/>**Exemplo 04: Express√£o Lambda com v√°rias instru√ß√µes:**

```java
n -> {
	instru√ß√£o 01
	instru√ß√£o 02
	instru√ß√£o 03
	};
```

<br />

4. **Instru√ß√£o de retorno:** A instru√ß√£o de retorno (return) tamb√©m √© opcional em Express√µes Lambda. O compilador Java retorna automaticamente o valor se o corpo tiver uma √∫nica express√£o. Se o corpo da fun√ß√£o retornar um valor, voc√™ deve coloc√°-lo entre chaves.

<img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/>**Exemplo 05: Express√£o Lambda com retorno:**

```java
n -> {
	int retorno = n * n;
	return retorno;
}
```

<br />

<img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/>**Exemplo 06 - Express√µes Lambda e Collections:** 

Nesta primeira vers√£o do c√≥digo, n√£o foram utilizadas as Express√µes Lambdas:

```java
package lambda_collections_01;

import java.util.Arrays;
import java.util.List;

public class Lambda {
	public static void main(String[] args) {

		List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

		System.out.println("Exibir os itens\n");
		
		// Exibir os itens da Lista sem Express√£o Lambda
		for(Integer n : numeros) {
			System.out.println(n);
		}

		System.out.println("\nExibir os itens somados com eles mesmos\n");
		
		// Exibir os itens da Lista dobrados sem Express√£o Lambda
		for(Integer n : numeros) {
			System.out.println(n + n);
		}

		System.out.println("\nExibir os itens pares da lista\n");
		
		// Exibir apenas os elementos pares da Lista sem Express√£o Lambda
		for(Integer n : numeros) {
			if(n%2 == 0)
			System.out.println(n);
		}
	}
}
```

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="25px"/> <a href="https://github.com/rafaelq80/exemplos_java/tree/main/lambda/lambda_collections_v1" target="_blank"><b>C√≥digo fonte: Exemplo 06 - Vers√£o 01</b></a></div>

<br />

Na segunda vers√£o do c√≥digo, foram utilizadas as Express√µes Lambdas:

```java
package lambda_collections_02;

import java.util.Arrays;
import java.util.List;

public class Lambda {
	public static void main(String[] args) {

		List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

		System.out.println("Exibir os itens\n");
		
		// Exibir os itens da Lista com Express√£o Lambda
		numeros.forEach(n -> System.out.println(n));

		System.out.println("\nExibir os itens somados com eles mesmos\n");
		
		// Exibir os itens da Lista dobrados com Express√£o Lambda
		numeros.forEach(n -> System.out.println(n + n));

		System.out.println("\nExibir os itens pares da lista\n");
		
		// Exibir apenas os elementos pares da Lista com Express√£o Lambda
		numeros.forEach(n -> {
			if (n % 2 == 0)
				System.out.println(n);
		});
	}
}
```

Observe que ao comparar a primeira vers√£o sem Express√µes Lambdas, com a segunda vers√£o com Express√µes Lambdas, o c√≥digo da segunda vers√£o fica muito menos verboso, mais direto e limpo. Observe que as Express√µes Lambda foram inseridas dentro do M√©todo **forEach()**, da Classe Collections, porque as Express√µes Lambda dependem de uma Interface Funcional para serem executadas.

O M√©todo **forEach()**, que √© utilizado para iterar sobre uma cole√ß√£o e executar uma determinada a√ß√£o em cada elemento, utiliza uma classe que implementa a **interface Consumer**, que √© passada para o M√©todo **forEach()** como um argumento do M√©todo. Como a interface Consumer √© uma interface funcional, a a√ß√£o que ser√° executada sobre a Collection, ser√° enviada na forma de uma Express√£o Lambda.

Abaixo, vemos o resultado da execu√ß√£o de ambos os c√≥digos.

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
Exibir os itens

1
2
3
4
5
6
7
8
9

Exibir os itens somados com eles mesmos

2
4
6
8
10
12
14
16
18

Exibir os itens pares da lista

2
4
6
8
```

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank"><b>Documenta√ß√£o: Lambda Expressions</b></a></div>

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="25px"/> <a href="https://github.com/rafaelq80/exemplos_java/tree/main/lambda/lambda_collections_v2" target="_blank"><b>C√≥digo fonte: Exemplo 06 - Vers√£o 02</b></a></div>


<br />

<h2>4. Interfaces Funcionais</h2>



**Interfaces Funcionais** s√£o interfaces que t√™m um √∫nico M√©todo Abstrato a ser implementado. Isso significa que toda Interface criada que respeite esta premissa, torna-se automaticamente uma Interface Funcional.

Um ponto importante que deve ser destacado √© que o compilador Java reconhece automaticamente essas Interfaces e a partir da Express√£o Lambda enviada, ele sabe exatamente qual Opera√ß√£o ser√° executada pelo M√©todo da Interface.

Para identificar que uma Interface √© Funcional utilizamos a anota√ß√£o **@FunctionalInterface**. O compilador exibe um alerta *'Annotation @FunctionalInterface inesperado'* se a Interface contiver mais de um m√©todo abstrato. No entanto, n√£o h√° obriga√ß√£o de utilizar esta anota√ß√£o.

<br />

<img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/>**Exemplo 07 - Express√µes Lambdas e Interface Funcional:** 

Neste exemplo, vamos criar uma Calculadora utilizando Interfaces Funcionais e Express√µes Lambdas. 

Vamos come√ßar implementando a Interface Funcional **OperacaoMatematica**, que ser√° respons√°vel por executar todas as Opera√ß√µes matem√°ticas da nossa Calculadora:

**Interface OperacaoMatematica**

```java
package lambda;

@FunctionalInterface
public interface OperacaoMatematica {

	public int executar(int a, int b);

}
```

Dentro da nossa Interface foi assinado o M√©todo Abstrato executar, com 2 par√¢metros inteiros.

Na sequ√™ncia, vamos implementar a Classe **Calculadora**, onde implementaremos a Calculadora propriamente dita:

**Classe Calculadora**

```java
package lambda;

import java.util.Scanner;

public class TestaCalculadora {

	public static int calcular(OperacaoMatematica om, int num1, int num2) {
        return om.executar(num1, num2);
    }
	
	public static void main(String[] args) {

		Scanner leia = new Scanner(System.in);
		
		int n1, n2 = 0;
		
		System.out.println("****************************************************");
		System.out.println("              Calculadora com Lambda                ");
		System.out.println("****************************************************");
		System.out.println("Digite o primeiro numero: ");
		n1 = leia.nextInt();
		System.out.println("Digite o segundo numero: ");
		n2 = leia.nextInt();
		
		System.out.println("Soma = " + calcular((a,b) -> a + b, n1, n2));
        System.out.println("Subtra√ß√£o = " + calcular((a,b) -> a - b, n1, n2));
        System.out.println("Multiplica√ß√£o = " + calcular((a,b) -> a * b, n1, n2));
        System.out.println("Divis√£o = " + calcular((a,b) -> a / b, n1, n2));
		
        leia.close();
        
	}
		
}
```

Observe que foi criado o M√©todo **Calcular**, que receber√° 3 par√¢metros: Um **Objeto da Interface OperacaoMatematica**, que receber√° a Express√£o Lambda contendo a Opera√ß√£o Matem√°tica que o M√©todo **executar()** ir√° calcular e **2 par√¢metros inteiros**, que ser√£o a lista de par√¢metros da Express√£o Lambda.

Depois da entrada de dados, vamos observar a linha da opera√ß√£o de soma:

```java
System.out.println("Soma = " + calcular((a,b) -> a + b, n1, n2));
```

Observe que na chamada do M√©todo Calcular, foi passado no primeiro par√¢metro a Express√£o Lambda respons√°vel por efetuar a soma, que ser√° processada pela Interface Funcional:

```java
//Express√£o Lambda
(a,b) -> a + b
```

Na sequ√™ncia foram inseridos os 2 n√∫meros inteiros recebidos via teclado, que substituir√£o os par√¢metros a e b na Express√£o Lambda, efetuando a soma dos dois n√∫meros.

As demais Opera√ß√µes seguem a mesma linha de racioc√≠nio.

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
****************************************************
              Calculadora com Lambda                
****************************************************
Digite o primeiro numero: 
10
Digite o segundo numero: 
5
Soma = 15
Subtra√ß√£o = 5
Multiplica√ß√£o = 50
Divis√£o = 2
```

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="25px"/> <a href="https://github.com/rafaelq80/exemplos_java/tree/main/lambda/calculadora_lambda" target="_blank"><b>C√≥digo fonte: Exemplo 07</b></a></div>

<br />

------

## üîë**Pontos chave:**

- **Paradigma imperativo:** √© o paradigma mais antigo e tradicional, que se baseia em instru√ß√µes sequenciais que modificam o estado do programa.
- **Paradigma orientado a objetos:** √© o paradigma mais popular e difundido atualmente, que se baseia na abstra√ß√£o de entidades do mundo real em objetos que possuem atributos (dados) e m√©todos (comportamentos). 
- **Paradigma funcional:** √© o paradigma inspirado na matem√°tica, que se baseia na avalia√ß√£o de express√µes e na aplica√ß√£o de fun√ß√µes. 
- Uma **Express√£o Lambda** √© um pequeno bloco de c√≥digo que recebe par√¢metros e retorna um valor. Uma express√£o lambda tamb√©m pode ser vista como uma fun√ß√£o an√¥nima. Uma fun√ß√£o que n√£o tem nome e n√£o pertence a nenhuma classe. 
- **Interfaces Funcionais** s√£o interfaces que t√™m um √∫nico M√©todo Abstrato a ser implementado. Isso significa que toda Interface criada que respeite esta premissa, torna-se automaticamente uma Interface Funcional.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
