<h1>Programa√ß√£o Orientada a Objetos - Parte 02</h1>

Anteriormente, iniciamos nossos estudos sobre os conceitos iniciais da Programa√ß√£o Orientada a Objetos, tais como **Classes, Objetos, M√©todos, Atributos e Encapsulamento**. Neste material veremos outros 2 conceitos fundamentais: **Heran√ßa e Polimorfismo**. Antes, vamos entender o que √© Relacionamento entre Classes:

<h2>1. Relacionamento entre Classes</h2>

**Os Relacionamentos entre classes no Java** definem os Relacionamentos especiais entre os diferentes tipos de classes.

No exemplo abaixo, existe uma rela√ß√£o especial entre uma classe chamada Ve√≠culo e uma classe chamada Carro: Um Carro √© um tipo de Ve√≠culo, como mostra a figura abaixo:

```mermaid
classDiagram
Veiculo <-- Carro: √© um tipo de
```

No pr√≥ximo exemplo, tamb√©m existe um tipo diferente de relacionamento entre as classes Carro, Motor e Roda. Um Carro √© compostos por Motor e Roda, como mostra a figura abaixo:

```mermaid
classDiagram
Carro *-- Motor : √© composto por
Carro *-- Roda : √© composto por
```

Quando projetamos um aplicativo, precisamos explorar os tipos de relacionamentos entre as classes, porque os relacionamentos nos ajudam de v√°rias maneiras.

Por exemplo, suponha que em um aplicativo, temos classes com comportamentos comuns (m√©todos), ent√£o podemos economizar esfor√ßo colocando os comportamentos comuns (m√©todos) dentro de uma √∫nica Classe, chamada de superclasse e na sequ√™ncia poderemos criar outras Classes que herdar√£o estes M√©todos em comum.

Ou ainda, Suponha que algumas classes n√£o estejam relacionadas entre si, ent√£o podemos atribuir diferentes programadores para implementar cada uma delas, sem nos preocuparmos que uma delas ter√° que esperar pela outra. 

Os relacionamentos entre as classes nos ajudam a entender como os objetos em um programa trabalham em conjunto e se comunicam entre si.

<h3>1.1. Tipos de relacionamento entre classes em Java</h3>

Existem tr√™s tipos de relacionamentos mais comuns entre classes em Java que s√£o os seguintes:

- Heran√ßa ("Is-A") - √â um
- Depend√™ncia (‚ÄúUse-A‚Äù) - Usa um
- Associa√ß√£o (‚ÄúHas-A‚Äù) - Tem um

A associa√ß√£o √© ainda classificada em 2 categorias:

- Agrega√ß√£o 

- Composi√ß√£o

Veja o resumo no Organograma abaixo:

<div align="center"><img src="https://i.imgur.com/UvL4z36.png" title="source: imgur.com" /></div>



<h4>1.1.1. Rela√ß√£o de Heran√ßa</h4>

A heran√ßa estabelece um relacionamento entre uma classe mais gen√©rica e abstrata (conhecida como superclasse) e uma classe mais especializada (conhecida como subclasse).

Em outras palavras, define o relacionamento entre duas classes em que uma classe "estende" outra classe, ou simplesmente cria um Relacionamento do tipo **√â-Um** (Is-A).

```mermaid
classDiagram
Pessoa <|-- Professor : √â uma
Pessoa <|-- Aluno : √â uma
```

<h4>1.1.2. Rela√ß√£o de Depend√™ncia</h4>

Quando criamos um objeto de uma classe dentro de um m√©todo de outra classe, esse relacionamento √© chamado **de relacionamento de depend√™ncia em Java**, ou simplesmente relacionamento **Usa-Um** (Use-A).

Em outras palavras, quando um m√©todo de uma classe usa um objeto de outra classe, ele √© chamado de depend√™ncia em Java. √â o relacionamento mais √≥bvio e mais geral em java.

```mermaid
classDiagram
Produto <.. Carrinho : Depende de
```

No Diagrama acima, em um aplicativo de com√©rcio eletr√¥nico, a classe Carrinho depende da classe Produto porque a classe Carrinho usa a classe Produto como par√¢metro para uma opera√ß√£o de adi√ß√£o de itens. 

Esse tipo de Relacionamento deve ser evitado devido ao alto grau de acoplamento gerado pela depend√™ncia.

<h4>1.1.3. Relacionamento de Associa√ß√£o</h4>

A associa√ß√£o √© outro tipo de relacionamento fundamental entre classes, que √© informalmente conhecido como relacionamento ‚Äú**Tem-Um**‚Äù (Has-A).

Quando um objeto de uma classe √© criado como Atributo de uma outra classe, ele √© chamado **de relacionamento de associa√ß√£o em java** ou simplesmente um Relacionamento do tipo Tem-Um.

```mermaid
classDiagram
Aluno <-- Professor : Tem um ou mais
```

Neste tipo de relacionamento √© importante definir tamb√©m as cardinalidades, ou seja, o numero de Objetos que podem se relacionar com outros Objetos. Existem basicamente 3 tipos de cardinalidades:

- **One to One:** Um Objeto tem rela√ß√£o com apenas Nenhum ou Um Objeto;
- **One to Many / Many to One:** Um Objeto tem rela√ß√£o com Nenhum, Um ou Mais Objetos;
- **Many to Many:** Muitos Objetos tem rela√ß√£o com Muitos Objetos.

Existem dois tipos de relacionamento de Associa√ß√£o especiais, que s√£o os seguintes:

- Agrega√ß√£o
- Composi√ß√£o

**Agrega√ß√£o:** Uma agrega√ß√£o √© uma forma especial de associa√ß√£o que representa um relacionamento de propriedade entre dois objetos, ou seja, dois objetos agregados t√™m seus pr√≥prios ciclos de vida, mas um dos objetos √© o propriet√°rio do relacionamento Tem-Um. 

O objeto propriet√°rio √© chamado de objeto agregador e sua classe √© chamada de classe agregadora. A classe agregadora tem uma refer√™ncia a outra classe e √© a propriet√°ria dessa classe. Ter seu pr√≥prio relacionamento significa que destruir um objeto n√£o afetar√° outro objeto.

```mermaid
classDiagram
Departamento o-- Professor : √â parte de
```

No exemplo acima, um Objeto Departamento cont√©m diversos Objetos Professor e ele √© o propriet√°rio do Relacionamento. Os Objetos Professor continuam existindo mesmo que o Objeto Departamento seja destru√≠do.

As *palavras chaves* usadas para identificar uma agrega√ß√£o s√£o: *"consiste em", "cont√©m", "√© parte de"*.

**Composi√ß√£o :** Uma composi√ß√£o √© uma forma especial e mais restritiva de agrega√ß√£o. Ele tamb√©m representa o relacionamento Tem-Um em que um objeto n√£o pode existir por conta pr√≥pria. O ‚Äútodo‚Äù √© realmente dependente da ‚Äúparte‚Äù.

Em outras palavras, dois objetos compostos n√£o podem ter seu pr√≥prio ciclo de vida. Ou seja, um objeto composto n√£o pode existir por conta pr√≥pria. Se um objeto composto for destru√≠do, todas as suas partes tamb√©m ser√£o exclu√≠das. Veja o exemplo abaixo:

```mermaid
classDiagram
Universidade *-- Departamento : √© parte de
```

Por exemplo, uma Universidade √© composta por v√°rios Departamentos. Um Departamento √© parte de uma Universidade e n√£o pode existir sem a exist√™ncia da Universidade, assim como nenhum Departamento pode pertencer a duas Universidades diferentes. Se o Objeto Universidade for destru√≠do, todos os Objetos Departamentos ser√£o destru√≠dos automaticamente.

<h3>Como decidir que tipo de relacionamento precisamos?</h3>

Os relacionamentos mais importantes ou mais utilizados no dia a dia s√£o o relacionamento √â-Um (Heran√ßa) e o relacionamento Tem-Um (Associa√ß√£o). A melhor maneira de decidir que tipo de relacionamento devemos criar √© a seguinte:

1. Se o seu problema for definido com a frase: "*O Objeto A √© um tipo do Objeto B*", ent√£o voc√™ deve usar o relacionamento de Heran√ßa. **Exemplo:** "*Um cachorro √© um Pet*". N√£o podemos dizer ‚Äú*Um Cachorro tem um Pet*‚Äù, pois n√£o faz o menor sentido. Ent√£o, neste caso, vamos criar uma superclasse chamada Pet e uma subclasse derivada chamada Cachorro.

```mermaid
classDiagram
Pet <|-- Cachorro : √â um
```

2. Por outro lado, se o seu problema for definido com a frase: "*O Objeto A tem um Objeto B*", ent√£o voc√™ deve usar o relacionamento de Associa√ß√£o. **Exemplo:**  ‚Äú*Um Pet tem uma Ra√ßa*‚Äù. N√£o podemos dizer: ‚Äú*Um Pet √© uma Ra√ßa*‚Äù. Esta afirma√ß√£o n√£o faz o menor sentido. Ent√£o, neste caso, vamos criar uma associa√ß√£o entre a Classe chamada Pet e a Classe derivada chamada Cachorro.

```mermaid
classDiagram
Raca <-- Pet : Tem uma
```

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="80px"/> | <p align="justify"> **IMPORTANTE:** Neste primeiro momento, iremos focar na Rela√ß√£o de Heran√ßa. </p> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<h2>2. Heran√ßa</h2>

O que torna a Orienta√ß√£o a Objetos √∫nica √© o **conceito de heran√ßa**. **Heran√ßa** √© um mecanismo que permite que caracter√≠sticas comuns a diversas classes sejam fatoradas de uma classe base, ou **superclasse**, ou seja, permite uma Classe herdar todos os Atributos e M√©todos de outra Classe. 

<div align="center"><img src="https://i.imgur.com/2T7wxZN.png" title="source: imgur.com" /></div>

Analisando a imagem acima: 

- Considere **capacidade** como um atributo da **Classe Transporte**, que indica a quantidade de pessoas que o transporte em quest√£o pode transportar.
- Os atributos **numero de rodas** e **velocidade** (KM/h) como atributos da **Classe Terrestre**.
- Os atributos **cor, n√∫mero de portas, placa e marcha** como atributos da **Classe Autom√≥vel**.
- A imagem acima apresenta um exemplo de Heran√ßa, onde:
  - As **Classes Aqu√°tico, Terrestre e A√©reo** herdam a **Classe Transporte**.
  - A **Classe Barco** herda a **Classe Aqu√°tico**.
  - A **Classe Autom√≥vel** herda a **Classe Terrestre**.
  - A **Classe Avi√£o** herda a **Classe A√©reo**.

A heran√ßa √© uma forma de reutiliza√ß√£o de software em que novas classes s√£o criadas a partir das classes existentes, absorvendo todos os seus atributos e m√©todos, al√©m de adicionar novos recursos que as novas classes exigem. A partir de uma **classe base**, outras classes podem ser especificadas e cada classe derivada ou **subclasse** apresenta as caracter√≠sticas (estrutura e m√©todos) da **superclasse**, al√©m de acrescentar o que for definido como particularidade da subclasse. Cada **subclasse** tamb√©m se torna uma candidata a ser uma **superclasse** para alguma subclasse futura

Observando o exemplo acima:

- A **Classe Transporte** possui um **atributo chamado capacidade**.
- Como a **Classe Aqu√°tico** herda a **Classe Transporte**, pode-se dizer que ela tamb√©m possui o **atributo capacidade**.
- A **Classe Barco**, como herda a **Classe Aqu√°tico**, tamb√©m possui o **atributo capacidade**.

Abaixo, vemos o Diagrama de Classes do exemplo acima:

<img src="https://i.imgur.com/vGDOChv.png" title="source: imgur.com" width="3%"/>**Exemplo 01 - Diagrama de Classes** 

```mermaid
classDiagram
class Transporte {
- capacidade: int  
}
class Aereo {
  
}
class Terrestre {
- numero de rodas: int  
- velocidade: float 
}
class Aquatico {
  
}
class Aviao {
  
}
class Automovel {
- cor: String
- numero de portas: int
- placa: String
- marcha: int
}
class Barco {
  
}
Transporte <-- Aquatico
Transporte <-- Terrestre
Transporte <-- Aereo
Aquatico <-- Barco
Terrestre <-- Automovel
Aereo <-- Aviao
```

<h3>2.1. Tipos de Heran√ßa</h3>

Existem basicamente 2 tipos de heran√ßa:

- **Heran√ßa Simples:** Cada classe pode ter apenas uma superclasse. Na linguagem Java usa-se a palavra reservada **extends** para declarar que uma classe √© herdeira de outra.
- **Heran√ßa M√∫ltipla:** √â a capacidade de uma classe possuir mais de uma superclasse e herdar os atributos e m√©todos
  de todas as superclasses. Java n√£o implementa Heran√ßa M√∫ltipla nativamente, como a Linguagem C++, por exemplo. Para simular a heran√ßa m√∫ltipla em Java, usa-se **Interfaces**, que veremos mais adiante.

<h3>2.2. Heran√ßa em Java</h3>

**Sintaxe:**

<div align="center"><img src="https://i.imgur.com/LlHR3A0.png" title="source: imgur.com" /></div>

<br />

<h4>2.2.1 Modificadores de Acesso</h4>

As Classes possuem apenas 2 modificadores de acesso:

| **Modificador** | **Descri√ß√£o**                                                |
| --------------- | ------------------------------------------------------------ |
| **padr√£o**      | Uma Classe padr√£o (identificado pela aus√™ncia de modificadores) poder√° ser acessada por todas as Classes que estiverem **no mesmo pacote**. |
| **public**      | Uma Classe public poder√° ser acessado por qualquer classe em qualquer pacote. |

***\*Observa√ß√£o importante:\**** Os modificadores de acesso (padr√£o e public) nunca poder√£o ser combinados;

<br />

<h4>2.2.2 Modificadores de Classes</h4>

As Classes possuem 2 modificadores de Classes:

| Modificador  | Descri√ß√£o                                                    |
| ------------ | ------------------------------------------------------------ |
| **abstract** | Uma Classe Abstrata n√£o pode ser usada para criar objetos, ou seja, para acessar uma Classe Abstrata, ela deve ser herdada por outra Classe. |
| **final**    | Uma Classe final n√£o pode ser herdada por outras Classes.    |

***\*Observa√ß√µes importantes:\****

- Uma Classe nunca poder√° ser abstract e final simultaneamente;
- Uma Classe Abstrata nunca poder√° ser instanciada.

<br />

<h4>2.2.3 A palavra reservada extends</h4>

A palavra reservada **extends** - indica que uma Classe est√° sendo criada como uma heran√ßa (extens√£o) de uma classe existente.

A **Classe existente** √© a superclasse, classe base ou classe progenitora.

A **Nova classe** √© a subclasse, classe derivada ou classe filha.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://www.w3schools.com/java/java_modifiers.asp" target="_blank"><b>Documenta√ß√£o: Modificadores de Classes</b></a>
<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://www.w3schools.com/java/ref_keyword_extends.asp" target="_blank"><b>Documenta√ß√£o: Palavra reservada extends</b></a>

<br />

<h3>2.3 O M√©todo Construtor da Subclasse</h3>

O M√©todo Construtor de uma Subclasse utiliza o M√©todo super() **que tem a fun√ß√£o de chamar o M√©todo Construtor da Superclasse**. Ele sempre √© chamado e deve ser o primeiro item dentro do M√©todo Construtor da Subclasse. 

No M√©todo super() devem ser passados como par√¢metros todos os Atributos da Superclasse. Os Atributos espec√≠ficos da Subclasse devem ser mantidos no M√©todo Construtor da Subclasse.

<br />

<h3>2.4 A palavra reservada super</h3>

Al√©m do M√©todo super(), existe tamb√©m a palavra reservada **super**, que faz refer√™ncia aos Objetos da Superclasse, semelhante a palavra reservada **this**, que faz refer√™ncia aos Objetos da pr√≥pria Classe.

A palavra reservada **super** e usada para chamar M√©todos da Superclasse. O uso mais comum da palavra reservada super √© eliminar a confus√£o entre superclasses e subclasses que possuem m√©todos com o mesmo nome.

<br />


<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/IandI/super.html" target="_blank"><b>Documenta√ß√£o: M√©todo super()</b></a>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://www.w3schools.com/java/ref_keyword_super.asp" target="_blank"><b>Documenta√ß√£o: Palavra reservada super</b></a>

<br /><br />

<img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/>**Exemplo 01 - Implementa√ß√£o em Java:** 

**Classe Transporte**

```java
package meios_transporte;

public class Transporte {

	private int capacidade;

	public Transporte(int capacidade) {
		this.capacidade = capacidade;
	}

	public int getCapacidade() {
		return capacidade;
	}

	public void setCapacidade(int capacidade) {
		this.capacidade = capacidade;
	}
	
	public void visualizar() {
		
		System.out.println("\n\n************************************************************");
		System.out.println("Dados do Meio de Transporte:");
		System.out.println("****************************************************************");
		System.out.println("Capacidade (n√∫mero de passageiros: " + this.capacidade);
		
	}
}
```

A Classe Transporte (Superclasse), foi criada com apenas um Atributo (capacidade), conforme o Diagrama de Classes acima. Tamb√©m foi criado o M√©todo Construtor, os M√©todos Get e Set do Atributo e o M√©todo visualizar para exibir os dados do Objeto na tela.

**Classe Terrestre**


```java
package meios_transporte;

public class Terrestre extends Transporte {

	private int numeroRodas;
	protected float velocidade;

	public Terrestre(int capacidade, int numeroRodas, float velocidade) {
		super(capacidade);
		this.numeroRodas = numeroRodas;
		this.velocidade = velocidade;
	}

	public int getNumeroRodas() {
		return numeroRodas;
	}

	public void setNumeroRodas(int numeroRodas) {
		this.numeroRodas = numeroRodas;
	}

	public float getVelocidade() {
		return velocidade;
	}

	public void setVelocidade(float velocidade) {
		this.velocidade = velocidade;
	}

    @Override
	public void visualizar() {

		super.visualizar();
		System.out.println("N√∫mero de rodas: " + this.numeroRodas);
		System.out.println("Velocidade: " + this.velocidade);

	}
}

```

A Classe Terrestre (Subclasse), foi criada como Heran√ßa da Classe Transporte (**extends Transporte**), com dois Atributos (**numeroRodas** e **velocidade**), conforme o Diagrama de Classes acima. Al√©m disso, tamb√©m foram criados o M√©todo Construtor, os M√©todos Get e Set dos Atributos e o M√©todo visualizar para exibir os dados do Objeto na tela. 

Observe que:

- O Atributo velocidade foi definido como **protected**, porque precisaremos ter acesso ao Atributo atrav√©s da Classe Automovel.
- Nos par√¢metros do M√©todo Construtor foi adicionado o Atributo **capacidade**, da Classe Transporte. 
- No corpo do M√©todo Construtor foi adicionado o M√©todo **super** para acessar os Atributos da Classe Transporte (**super(capacidade)**). 
- No M√©todo visualizar foi adicionado o M√©todo **super** para executar o M√©todo **visualizar()** (**super.visualizar()**), da Classe Transporte, para listar os dados dos atributos da Classe Transporte.

**Classe Automovel**

```java
package meios_transporte;

public class Automovel extends Terrestre{

	private String cor;
	private int numeroPortas;
	private String placa;
	private int marcha;
	
	public Automovel(int capacidade, int numeroRodas, float velocidade, String cor, int numeroPortas, String placa, int marcha) {
		super(capacidade, numeroRodas, velocidade);
		this.cor = cor;
		this.numeroPortas = numeroPortas;
		this.placa = placa;
		this.marcha = marcha;
	}

	public String getCor() {
		return cor;
	}

	public void setCor(String cor) {
		this.cor = cor;
	}

	public int getNumeroPortas() {
		return numeroPortas;
	}

	public void setNumeroPortas(int numeroPortas) {
		this.numeroPortas = numeroPortas;
	}

	public String getPlaca() {
		return placa;
	}

	public void setPlaca(String placa) {
		this.placa = placa;
	}
	
	public int getMarcha() {
		return marcha;
	}

	public void setMarcha(int marcha) {
		this.marcha = marcha;
	}

    @Override
	public void visualizar() {

		super.visualizar();
		System.out.println("cor: " + this.cor);
		System.out.println("N√∫mero de portas: " + this.numeroPortas);
		System.out.println("Placa: " + this.placa);
		System.out.println("Marcha: " + this.marcha);
		
	}
}
```

A Classe Automovel (Subclasse), foi criada como Heran√ßa da Classe Terrestre (**extends Terrestre**), com os Atributos (**cor, numeroPortas, placa e marcha**), conforme o Diagrama de Classes acima. Al√©m disso, tamb√©m foram criados o M√©todo Construtor, os M√©todos Get e Set dos Atributos e o M√©todo visualizar para exibir os dados do Objeto na tela. 

Observe que:

- No M√©todo Construtor foram adicionados os Atributos **capacidade**, da Classe Transporte, e **numeroRodas**, da Classe Terrestre, nos par√¢metros do M√©todo. 
- No corpo do M√©todo Construtor foi adicionado o M√©todo **super** para acessar os Atributos da **Classe Terrestre** e da **Classe Transporte**, que foram herdados na Classe Terrestre (**super(capacidade, numeroRodas, velocidade)**). 
- No M√©todo visualizar tamb√©m foi adicionado o M√©todo **super** para executar o M√©todo **visualizar()** (**super.visualizar()**), da Classe Terrestre, para listar os dados dos atributos das Classes Terrestre e Transporte.

**Classe TestaTransporte**

```java
package meios_transporte;

public class TestaTransporte {

	public static void main(String[] args) {

		Automovel aut1 = new Automovel(5, 4, 0.0f, "Verde", 4, "EBN-0301", 0);
		
		aut1.visualizar();

	}

}
```

Na Classe TestaTransporte, foi instanciado uma Objeto da Classe Automovel. Observe que devido as Heran√ßas, o Objeto da Classe Automovel possui 7 par√¢metros: 

- capacidade (herdado da Classe Transporte)
- numeroRodas e velocidade (Herdado da Classe Terrestre)
- cor, numeroPortas, placa e marcha (Atributos da Classe Automovel)

Abaixo, voc√™ confere o resultado do c√≥digo no Console:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```
*********************************************************************
Dados do Meio de Transporte:
*********************************************************************
Capacidade (n√∫mero de passageiros: 5
N√∫mero de rodas: 4
Velocidade: 0.0
cor: Verde
N√∫mero de portas: 4
Placa: EBN-0301
Marcha: 0
```

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="25px"/> <a href="https://github.com/rafaelq80/exemplos_java/tree/main/heranca_polimorfismo/meios_transporte" target="_blank"><b>C√≥digo fonte</b></a>


<br /><br />


> **Dicas sobre Heran√ßa:**
>
> 1. Sempre coloque os m√©todos e atributos comuns para todas as Subclasses na **Superclasse**
> 2. Use heran√ßa para modelar uma rela√ß√£o de ‚Äúestar contido em‚Äù, ou seja, **um objeto da Subclasse √© um objeto da Superclasse**
> 3. N√£o use heran√ßa a menos que todos ou a maioria dos m√©todos herdados da Superclasse fa√ßam sentido na Subclasse

<br />

<h2>3. Sobrescrita de M√©todos</h2>

O ato de sobrescrever um m√©todo ou propriedade significa dar uma nova forma ao mesmo, uma nova vers√£o. Em Java, a  **Sobrescrita de M√©todos** seria **criar um novo M√©todo na Classe filha contendo a mesma assinatura e o mesmo tipo de retorno do M√©todo Sobrescrito**. (Override). 

N√£o confunda **M√©todo Sobrescrito** com **M√©todo Sobrecarregado**. M√©todo Sobrecarregado **permite que M√©todos com o mesmo nome e com as assinaturas diferentes, coexistam em uma mesma Classe**.

A **Sobrescrita** est√° diretamente relacionada √† orienta√ß√£o a objetos, mais especificamente com a heran√ßa. Com a **sobrescrita**, conseguimos especializar os **m√©todos** herdados das superclasses, alterando o seu comportamento nas subclasses por um comportamento mais espec√≠fico.

Para indicar que um M√©todo foi sobrescrito, utilizamos a anota√ß√£o **@Override** (opcional).

> **Anota√ß√£o:** Anota√ß√µes s√£o metadados que podem ser inseridos diretamente no c√≥digo, para  ‚Äúconfigurar‚Äù determinados recursos que antes deveriam ser feitos em  arquivos separados como, por exemplo, no XML. 
>
> **Metadados:** Metadados, ou Metainforma√ß√£o, s√£o dados sobre outros dados. Um  item de um metadado pode dizer do que se trata aquele dado, geralmente  uma informa√ß√£o intelig√≠vel por um computador. Os metadados facilitam o  entendimento dos relacionamentos e a utilidade das informa√ß√µes dos  dados.

<br />

**Exemplo - Sobrescrita de M√©todo:** 

O M√©todo visualizar() da Classe Transporte, est√° implementado da seguinte forma:

```Java
	public void visualizar() {
		
		System.out.println("\n\n************************************************************");
		System.out.println("Dados do Meio de Transporte:");
		System.out.println("****************************************************************");
		System.out.println("Capacidade (n√∫mero de passageiros: " + this.capacidade);
		
	}
```

O M√©todo visualizar() da Classe Terrestre, foi reescrito da seguinte forma:

```java
	@Override
	public void visualizar() {

		super.visualizar();
		System.out.println("N√∫mero de rodas: " + this.numeroRodas);
		System.out.println("Velocidade: " + this.velocidade);

	}
```

O M√©todo visualizar() da Classe Automovel, foi reescrito da seguinte forma:

```java
	@Override
	public void visualizar() {

		super.visualizar();
		System.out.println("cor: " + this.cor);
		System.out.println("N√∫mero de portas: " + this.numeroPortas);
		System.out.println("Placa: " + this.placa);
		System.out.println("Marcha: " + this.marcha);
		
	}
```

Observe que as assinaturas dos 3 M√©todos s√£o as mesmas, entretanto o **M√©todo visualiza das 3 Classes**, possuem implementa√ß√µes diferentes, porqu√™ exibem os Atributos das Classes Herdadas e os seu pr√≥prios Atributos.

No exemplo acima, para que o M√©todo **visualiza** funcione diferente nas **Classes Terrestre e Automovel**, ele precisou ser sobrescrito, porque as **Classes Terrestre e Automovel n√£o possuem acesso direto √†s vari√°veis de inst√¢ncia privadas da Superclasse**, ou seja, esse m√©todo n√£o pode alterar ou acessar diretamente a vari√°vel de inst√¢ncia. Por isso eles executas o M√©todo **super.visualiza()**, para receber os Atributos das Classes Herdadas.

Um ponto de aten√ß√£o importante em rela√ß√£o a sobrescrita √© que um **m√©todo redefinido em uma subclasse** com o **mesmo nome** e **mesma lista de par√¢metros** que o **m√©todo em uma de suas classes antecessoras**, automaticamente oculta o m√©todo da classe ancestral (superclasse) a partir da subclasse, ou seja, ele passa a usar o M√©todo da subclasse.

<br />

<h2>4. Polimorfismo</h2>

O poliformismo deriva da palavra polimorfo, que significa multiforme, ou que pode variar a forma.

Para a POO, polimorfismo √© a habilidade de objetos de classes diferentes responderem a mesma mensagem de
diferentes maneiras, ou seja, v√°rias formas de responder √† mesma mensagem. O Polimorfismo √© a capacidade de um objeto decidir que m√©todo aplicar a si mesmo, embora a mensagem possa ser a mesma, os objetos podem responder diferentemente.

**Veja o Exemplo abaixo:**

um dono de uma f√°brica de brinquedos solicitou que seus engenheiros criassem um mesmo controle remoto para todos
os brinquedos de sua f√°brica. A √∫nica restri√ß√£o era que cada brinquedo atendesse aos comandos espec√≠ficos definidos pelo controle.

<div align="center"><img src="https://i.imgur.com/NM8RVg5.png" title="source: imgur.com" /></div>

Assim quando o brinquedo recebe o sinal MOVER, ele se move de acordo com a sua fun√ß√£o:

- Para o avi√£o, mover significa VOAR;
- Para o barco significa NAVEGAR, e
- Para o autom√≥vel CORRER.

<div align="center"><img src="https://i.imgur.com/KnwNIwl.png" title="source: imgur.com" /></div>

Observe que os brinquedos respondem ao mesmo sinal  de formas diferentes. O Polimorfismo permite que diferentes objetos (avi√£o, barco, autom√≥vel) respondam uma mesma mensagem (mover) de formas diferentes (voar, navegar e correr).

<h3>4.1. Como funciona na pr√°tica?</h3>

- Ao enviar uma mensagem que pede para uma **subclasse** aplicar um **m√©todo** usando certos par√¢metros, a subclasse verifica se ela tem ou n√£o um m√©todo com esse nome e exatamente com os mesmos par√¢metros. 
- Se tiver, usa-o.
- Caso contr√°rio: a **superclasse** torna-se respons√°vel pelo processamento da mensagem e procura por um m√©todo com esse nome e esses par√¢metros. 
- Se encontrar, chama esse m√©todo.

<img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="3%"/>**Exemplo - Controle Remoto** - Implementa√ß√£o em Java: 

**Classe Aviao**

```java
package controle_remoto;

public class Aviao {
	
	public void mover() {
		System.out.println("Voar!");
	}

}
```

**Classe Automovel**

```java
package controle_remoto;

public class Automovel {
	
	public void mover() {
		System.out.println("Correr!");
	}

}
```

**Classe Barco**

```java
package controle_remoto;

public class Barco {

	public void mover() {
		System.out.println("Navegar!");
	}
	
}
```

**Classe ControleRemoto**

```java
package controle_remoto;

public class ControleRemoto {

	public static void main(String[] args) {

		Aviao aviao = new Aviao();
		Automovel automovel = new Automovel();
		Barco barco = new Barco();
		
		System.out.println("Sobrescrita de M√©todos\n");
		System.out.println("Avi√£o Mover");
		aviao.mover();
		
		System.out.println("\nAutom√≥vel Mover");
		automovel.mover();
		
		System.out.println("\nBarco Mover");
		barco.mover();
				
	}
	
}
```

Observe que nas **linhas 13, 16 e 19**, os 3 Objetos est√£o chamando o mesmo M√©todo (**mover()**), entretanto a resposta no Console √© diferente, como vemos abaixo:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do Algoritmo:**

```bash
Sobrescrita de M√©todos

Avi√£o Mover
Voar!

Autom√≥vel Mover
Correr!

Barco Mover
Navegar!
```

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="25px"/> <a href="https://github.com/rafaelq80/exemplos_java/tree/main/heranca_polimorfismo/controle_remoto" target="_blank"><b>C√≥digo fonte</b></a>

<br />

<h3>4.2. Tipos de Polimorfismo</h3>

O Polimorfismo pode ser classificado de duas maneiras:

<h4>4.2.1. Polimorfismo de Sobrecarga (Sobrecarga de M√©todo)</h4>

Permite que um m√©todo de determinado nome tenha comportamentos distintos, em fun√ß√£o de diferentes par√¢metros que ele recebe. Cada m√©todo difere no n√∫mero e no tipo de par√¢metros. Veja o exemplo abaixo:

```java
public class Transporte {

	private int capacidade;

    //M√©todo Construtor com par√¢metros
	public Transporte(int capacidade) {
		this.capacidade = capacidade;
	}
    
    //M√©todo Construtor sem par√¢metros
    public Transporte() {	}
    
}
```

Observe que no exemplo acima temos dois M√©todos com o mesmo nome, na mesma Classe, entretanto com as assinaturas diferentes.

O **polimorfismo de sobrecarga** normalmente acontece sobre os **M√©todos Construtores**, pois √© comum para uma classe ter v√°rias maneiras de instanciar um Objeto, como vemos no exemplo acima.

O construtor apropriado √© chamado comparando a quantidade, os tipos e a ordem dos argumentos especificados na chamada do construtor com a quantidade, os tipos e a ordem dos par√¢metros especificados na defini√ß√£o de cada construtor.

<h4>4.2.2. Polimorfismo de Sobreposi√ß√£o (Sobrescrita de M√©todo)</h4>

√â a redefini√ß√£o de m√©todos em classes descendentes, ou seja, um m√©todo de uma classe filha com o mesmo nome de um m√©todo de uma classe m√£e ir√° sobrepor esse √∫ltimo. O m√©todo redefinido tem preced√™ncia em rela√ß√£o a chamadas de m√©todo nos objetos da subclasse. Veja o Exemplo abaixo:

O M√©todo **visualizar()** da Classe Transporte:

```Java
	public void visualizar() {
		
		System.out.println("\n\n************************************************************");
		System.out.println("Dados do Meio de Transporte:");
		System.out.println("****************************************************************");
		System.out.println("Capacidade (n√∫mero de passageiros: " + this.capacidade);
		
	}
```

O M√©todo **visualizar()** da Classe Terrestre:

```java
	@Override
	public void visualizar() {

		super.visualiza();
		System.out.println("N√∫mero de rodas: " + this.numeroRodas);
		System.out.println("Velocidade: " + this.velocidade);

	}
```

Observe que no exemplo acima temos 2 M√©todos de Classes diferentes, com implementa√ß√µes diferentes, por√©m com com o mesmo nome e com as mesmas assinaturas. 

<br />

------

## üîë**Pontos chave:**

1. **Os Relacionamentos entre classes no Java** definem os Relacionamentos especiais entre os diferentes tipos de classes. 
2. A Heran√ßa √© um tipo de Relacionamento entre Classes no Java e uma das maiores vantagens da Programa√ß√£o Orientada a Objetos, permitindo que o c√≥digo seja reutilizado. Em Java, √© poss√≠vel herdar **atributos** e **comportamentos** (**m√©todos**) de uma classe para outra. 

3. **Heran√ßa Simples:** Cada classe pode ter apenas uma superclasse. Na linguagem Java usa-se a palavra reservada **extends** para declarar que uma classe √© herdeira de outra.
4. **Heran√ßa M√∫ltipla:** √â a capacidade de uma classe possuir mais de uma superclasse e herdar os atributos e m√©todos
   de todas as superclasses. Java n√£o implementa Heran√ßa M√∫ltipla nativamente.
5. O Polimorfismo √© considerado um dos recursos mais importantes da Programa√ß√£o Orientada a Objetos, permitindo que uma a√ß√£o seja executada de diferentes maneiras, fornecendo implementa√ß√µes variadas para m√©todos e interfaces. A palavra **polimorfismo** significa adquirir muitas formas ou assumir fun√ß√µes diferentes. 
6. **Polimorfismo de Sobrecarga:** Permite que um m√©todo de determinado nome tenha comportamentos distintos, em fun√ß√£o de diferentes par√¢metros que ele recebe. Cada m√©todo difere no n√∫mero e no tipo de par√¢metros.
7. **Polimorfismo de Sobreposi√ß√£o:** √â a redefini√ß√£o de m√©todos em classes descendentes, ou seja, um m√©todo de uma classe filha com o mesmo nome de um m√©todo de uma classe m√£e ir√° sobrepor esse √∫ltimo. O m√©todo redefinido tem preced√™ncia em rela√ß√£o a chamadas de m√©todo nos objetos da subclasse.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
