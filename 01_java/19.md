<h1>Stream</h1>



A **API Streams** foi introduzida no Java 8 e √© muito usada para processar **cole√ß√µes de dados** (como listas ou conjuntos). Com ela, √© poss√≠vel trabalhar com esses dados de forma simples, utilizando c√≥digos mais limpos e f√°ceis de manter, evitando erros comuns durante a execu√ß√£o.

Uma **Stream** √© uma sequ√™ncia de objetos que podem passar por v√°rios m√©todos encadeados para produzir um resultado desejado, como filtrar ou ordenar dados.

Muitas pessoas confundem **Stream** com uma **estrutura de dados**, mas elas s√£o coisas diferentes. Uma Stream n√£o armazena dados. Em vez disso, ela processa dados de uma estrutura, como uma **Collection** (lista, conjunto) ou um **Array**.

O processamento simplificado de cole√ß√µes usando Streams foi poss√≠vel gra√ßas ao uso do **Paradigma Funcional** e das **Express√µes Lambda**. O objetivo √© percorrer cada elemento da cole√ß√£o e realizar a√ß√µes, como filtrar, mapear ou transformar os dados.

> **Paradigma Funcional**: Ao contr√°rio da programa√ß√£o imperativa, que usa um conjunto de instru√ß√µes para o computador realizar, a programa√ß√£o funcional usa **fun√ß√µes matem√°ticas** (express√µes lambda). Essas fun√ß√µes recebem dados, aplicam opera√ß√µes e retornam um resultado. A entrada n√£o muda, mas as opera√ß√µes podem ser alteradas para modificar a sa√≠da.

> **Express√£o Lambda**: √â um bloco de c√≥digo que recebe par√¢metros e retorna um valor. Diferente de um m√©todo tradicional, uma express√£o lambda n√£o tem nome e pode ser definida diretamente no corpo de um m√©todo.

Veja como funciona o Pipeline de uma Stream na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/yHxtqpT.png" title="source: imgur.com" /></div>

Como vemos na figura acima, uma Stream possui dois tipos de opera√ß√µes:

- **Opera√ß√µes Intermedi√°rias:** S√£o opera√ß√µes que **retornam uma nova Stream**. Elas permitem que voc√™ encadeie v√°rias opera√ß√µes, como filtrar ou mapear dados. Cada opera√ß√£o intermedi√°ria cria uma nova Stream, permitindo que voc√™ continue processando os dados.
- **Opera√ß√µes Terminais:** S√£o opera√ß√µes que **finalizam o processamento** da Stream e retornam um resultado, como um valor ou um objeto. Ap√≥s a execu√ß√£o de uma opera√ß√£o terminal, a Stream n√£o pode ser alterada nem receber novas opera√ß√µes intermedi√°rias ou terminais. Isso significa que a Stream √© consumida e n√£o pode ser reutilizada.

<br />

<h3>1.1. Streams vs Collections</h3>



√Ä primeira vista, **Collections** e **Streams** podem parecer semelhantes, pois ambas lidam com sequ√™ncias de dados. Mas qual √© a diferen√ßa?

<div align="center"><h2>"As Collections representam dados, enquanto as Streams representam os resultados de opera√ß√µes realizadas sobre esses dados."</h2></div>

A principal diferen√ßa est√° no momento em que os dados s√£o processados.

- **Collections** s√£o estruturas de dados que armazenam os elementos em mem√≥ria. Cada valor √© computado e adicionado √† cole√ß√£o quando inserido, ou seja, os dados j√° est√£o prontos para uso no momento em que s√£o armazenados.
- **Streams**, por outro lado, s√£o sequ√™ncias de dados que **s√≥ s√£o processados sob demanda**. Isso significa que os elementos s√£o **calculados √† medida que voc√™ percorre** a Stream, realizando opera√ß√µes como filtragem, mapeamento ou transforma√ß√£o.

Quando voc√™ trabalha com a interface `Collection`, precisa **gerenciar a itera√ß√£o** dos elementos manualmente (usando la√ßos de repeti√ß√£o). Isso √© chamado de **itera√ß√£o externa**. J√° quando voc√™ usa uma **Stream**, a itera√ß√£o √© feita automaticamente pela pr√≥pria Stream, atrav√©s da **itera√ß√£o interna**. A Stream se encarrega de processar os dados e aplicar as opera√ß√µes definidas, normalmente usando **express√µes lambda** fornecidas pelo desenvolvedor.

√â importante entender que:

- Uma **Stream n√£o √© uma estrutura de dados**. Ela apenas **recebe** uma Collection e realiza opera√ß√µes sobre ela.
- Uma **Stream n√£o altera a Collection original**. Ela gera **novos resultados** com base nas opera√ß√µes aplicadas, mas a estrutura de dados original permanece inalterada.

Na tabela abaixo, vemos um resumo das diferen√ßas entre **Streams e Collections**:

| **Stream**s                                                  | **Collections**                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| N√£o armazenam dados. Elas **operam** sobre a **Collection** de origem, processando seus dados. | **Armazenam e mant√™m** todos os dados em estruturas como List, Set, entre outras. |
| Usam **interfaces funcionais**, como express√µes **lambda**, tornando o c√≥digo mais conciso e funcional. | N√£o utilizam interfaces funcionais. O c√≥digo tende a ser mais imperativo. |
| **S√£o consum√≠veis**. Depois de processadas, uma Stream n√£o pode ser reutilizada e precisa ser criada novamente para outra opera√ß√£o. | **N√£o s√£o consum√≠veis**. Uma Collection pode ser percorrida v√°rias vezes sem necessidade de recriar. |
| Suportam **processamento sequencial e paralelo**, permitindo que voc√™ escolha entre desempenho otimizado ou simplicidade. | Suportam **processamento paralelo**, mas a Collection **Map** tem melhor desempenho nesse caso. |
| **N√£o s√£o modific√°veis**. N√£o √© poss√≠vel adicionar ou remover elementos diretamente de uma Stream. | **S√£o modific√°veis**. √â poss√≠vel adicionar, remover ou alterar elementos diretamente na Collection. |
| **Itera√ß√£o interna**. A Stream faz a itera√ß√£o automaticamente, aplicando as opera√ß√µes definidas pelo desenvolvedor. | **Itera√ß√£o externa**. A itera√ß√£o √© feita manualmente, geralmente com la√ßos de repeti√ß√£o, como o `for-each`. |

<br />

> **Processamento Sequencial:** As opera√ß√µes s√£o executadas **uma ap√≥s a outra**, na ordem em que foram escritas no c√≥digo.
>
> **Processamento Paralelo:** As opera√ß√µes s√£o executadas **simultaneamente**, em paralelo, com o objetivo de **aumentar o desempenho**. Isso √© √∫til quando a **ordem das opera√ß√µes n√£o importa**, permitindo que v√°rias opera√ß√µes sejam feitas ao mesmo tempo, aproveitando melhor o poder de m√∫ltiplos processadores.

<br />

**Sintaxe:**

```java
//Collection numeros
List<Integer> numeros = Arrays.asList(1,2,3,4,5,6,7,8,9,10);

//Gerar a Stream a partir da Collection
Stream<Integer> numerosStream = numeros.stream();

//Gerar a Stream a partir de uma lista de numeros
Stream<Integer> novoNumerosStream = Stream.of(1,2,3,4,5,6,7,8,9,10);
```

As 2 formas acima nos fornecem um Objeto Stream. Chamamos o m√©todo **stream()** sobre o Objeto de cole√ß√£o ou passamos os valores diretamente para o m√©todo **Stream.of()**.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://www.oracle.com/br/technical-resources/articles/java-stream-api.html" target="_blank"><b>Artigo: Java 8: Iniciando o desenvolvimento com a Streams API</b></a>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" target="_blank"><b>Documenta√ß√£o: Stream API</b></a>

<br />

<h2>2. M√©todos Intermedi√°rios</h2>



**M√©todos Intermedi√°rios** ou **Opera√ß√µes Intermedi√°rias** s√£o m√©todos que **retornam uma nova Stream**. Isso permite que voc√™ continue encadeando mais opera√ß√µes sobre os dados. Eles **n√£o alteram a Stream original**, mas criam uma nova, permitindo realizar v√°rias transforma√ß√µes de forma encadeada.

Agora, vamos conhecer os **m√©todos intermedi√°rios mais utilizados** da API Stream:

Nos exemplos abaixo, vamos utilizar as 3 Collections abaixo:

```java
List<Integer> numeros = Arrays.asList(1,2,3,4,5,6,7,8,9,10);

List<Integer> numerosDesordenados = Arrays.asList(6,7,8,1,4,5,9,10,2,3);

List<String> estados = Arrays.asList("S√£o Paulo", "Rio de Janeiro", "Minas Gerais","Espirito Santo", 
"S√£o Paulo", "Rio de Janeiro", "Minas Gerais", "S√£o Paulo", "Rio de Janeiro");
```

<br />

<h3>2.1. Map</h3>



O m√©todo **map()** √© utilizado para aplicar uma opera√ß√£o a cada elemento de uma lista ou cole√ß√£o e transformar os elementos, gerando uma nova cole√ß√£o. 

Vamos ver como podemos usar o `map()` para criar uma nova lista contendo os n√∫meros da lista fornecida, **elevados ao cubo**.



### <img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="4%"/> Exemplo - M√©todo Map:

```java
		System.out.println("\nExemplo - M√©todo Map");
		
		List<Integer> numerosAoCubo = numeros.stream()
		        .map(x -> (int) Math.pow(x,3))
		        .collect(Collectors.toList());
		
		System.out.println("\nNumeros elevados ao Cubo: " + numerosAoCubo);
```

No c√≥digo acima, foi passado como par√¢metro do M√©todo **map()** a **Express√£o Lambda:** `x -> (int) Math.pow(x,3)`. Esta Express√£o Lambda calcula a raiz c√∫bica de todos os elementos e converte pata um n√∫mero inteiro.

Na sequ√™ncia, atrav√©s do **m√©todo terminal `collect()`**, podemos **converter a Stream** em uma nova **Collection**, como uma lista (`List`). No exemplo abaixo, estamos convertendo a Stream de n√∫meros elevados ao cubo em uma lista chamada **`numerosAoCubo`**.

Observe que passamos como par√¢metro do m√©todo `collect()` o **m√©todo `Collectors.toList()`**, que **converte uma Stream em uma Collection do tipo List**.

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exemplo - M√©todo Map

Numeros elevados ao Cubo: [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]
```

<br />

<h3>2.2. Filter</h3>



O m√©todo **filter()** √© utilizado para **filtrar** os elementos de uma lista ou cole√ß√£o com base em uma **condi√ß√£o espec√≠fica**. Ele retorna um novo **Stream** contendo apenas os elementos que atendem √† condi√ß√£o fornecida.

Vamos ver como podemos usar o `filter()` para **filtrar os n√∫meros pares** de uma lista de n√∫meros de 1 a 10.



### <img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="4%"/> Exemplo - M√©todo Filter:

```java
		System.out.println("\nExemplo - M√©todo Filter");
		
		List<Integer> numerosPares = numeros.stream()
		        .filter(x -> x%2==0)
		        .collect(Collectors.toList());

		 System.out.println("\nExibir apenas os Numeros Pares: " + numerosPares);
```

No c√≥digo acima, foi passado como par√¢metro do M√©todo **filter()** a **Express√£o Lambda:** `x -> x%2==0`. Esta Express√£o Lambda calcula o resto da divis√£o de cada elemento da Collection **numeros** e verifica se o resultado foi igual a zero, ou seja, verifica se o resto da divis√£o √© igual zero, o que indica que o n√∫mero √© par.

Na sequ√™ncia, atrav√©s do M√©todo Terminal **collect()**, convertemos a Stream em uma nova Collection chamada **numerosPares**. Observe que foi passado como par√¢metro do M√©todo collect() o M√©todo **Collectors.tolist()**, que **converte uma Stream em uma Collection List**. O resultado do algoritmo voc√™ confere abaixo:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exemplo - M√©todo Filter

Exibir apenas os Numeros Pares: [2, 4, 6, 8, 10]
```

<br />

<h3>2.3. Sorted</h3>



O m√©todo **`sorted()`** √© utilizado para **ordenar os elementos** de uma cole√ß√£o. Ele pode ser aplicado a uma Stream para classificar os dados em ordem crescente ou decrescente.

Abaixo, vamos ver um exemplo de como **ordenar uma cole√ß√£o de n√∫meros inteiros** desordenados em **ordem crescente e decrescente** usando o m√©todo **`sorted()`**:



### <img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="4%"/> Exemplo - M√©todo Sorted:

```java
System.out.println("\nExemplo - M√©todo Sorted");
		 
		 List<Integer> numerosOrdenadosAsc = numerosDesordenados.stream()
				 .sorted()
				 .collect(Collectors.toList());

		 System.out.println("\nExibir os Numeros em Ordem Crescente: " + numerosOrdenadosAsc);
		 
		 List<Integer> numerosOrdenadosDesc = numerosDesordenados.stream()
				 .sorted(Comparator.reverseOrder())
				 .collect(Collectors.toList());

		 System.out.println("\nExibir os Numeros em Ordem Decrescente: " + numerosOrdenadosDesc);
		 
```

No c√≥digo acima, utilizamos o m√©todo **`sorted()`**, que √© respons√°vel por ordenar os dados em **ordem crescente**. Para ordenar em **ordem decrescente**, passamos como par√¢metro do m√©todo `sorted()` o m√©todo **`Comparator.reverseOrder()`**, que **inverte a ordem dos elementos**.

<br />

> **Comparator** √© uma **interface funcional** usada para comparar objetos e definir a ordem de classifica√ß√£o (crescente ou decrescente).
>
> O **Comparator** √© utilizado para ordenar elementos de uma **Collection** (como listas), podendo ser personalizado conforme necess√°rio. Ele compara dois objetos da mesma classe e pode ordenar a Collection de acordo com crit√©rios definidos.
>
> #### Exemplos de M√©todos do **Comparator**:
>
> - **`Comparator.reverseOrder()`**: Inverte a ordem natural dos elementos, fazendo uma ordena√ß√£o **decrescente**.
> - **`Comparator.naturalOrder()`**: Ordena de acordo com a ordem natural dos elementos, fazendo uma ordena√ß√£o **crescente**.
>
> <br />
>
> <div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" target="_blank"><b>Documenta√ß√£o: Interface Comparator</b></a>
>
> <br />

Na sequ√™ncia, atrav√©s do M√©todo Terminal **collect()**, convertemos as 2 Streams em duas novas Collections chamadas **numerosOrdenadosAsc** e **numerosOrdenadosDesc** respectivamente. O resultado do algoritmo voc√™ confere abaixo:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exemplo - M√©todo Sorted

Exibir os Numeros em Ordem Crescente: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

Exibir os Numeros em Ordem Decrescente: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
```

<br />

<h3>2.4. Distinct</h3>



O m√©todo **distinct()** √© utilizado para **remover itens duplicados** de uma **Stream**, ou seja, ele garante que a Collection resultante n√£o ter√° elementos repetidos.

Veja o exemplo abaixo, onde vamos listar os **nomes dos estados** sem repeti√ß√µes, utilizando o m√©todo **`distinct()`**:



### <img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="4%"/> Exemplo - M√©todo Distinct:

```java
		System.out.println("\nExemplo - M√©todo Distinct");
		 
		 List<String> estadosSemRepeticao = estados.stream()
				 .distinct()
				 .collect(Collectors.toList());
				     
		 System.out.println("\nExibir os Estados sem repeti√ß√£o: " + estadosSemRepeticao);
		 
```

No c√≥digo acima, foi executado o M√©todo **distinct()**, respons√°vel por remover os dados duplicados.

Na sequ√™ncia, atrav√©s do M√©todo Terminal **collect()**, convertemos a Stream em uma nova Collection chamada **estadosSemRepeticao**. O resultado do algoritmo voc√™ confere abaixo:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exemplo - M√©todo Distinct

Exibir os Estados sem repeti√ß√£o: [S√£o Paulo, Rio de Janeiro, Minas Gerais, Espirito Santo]
```

No link abaixo, voc√™ pode obter o c√≥digo completo do Exemplo acima.

<br />

<h3>2.5. Limit</h3>



O m√©todo **limit(n)** retorna os primeiros `n` elementos da Stream. √â √∫til quando voc√™ deseja obter apenas uma parte da Collection original.



### <img src="https://i.imgur.com/gsSDe7P.png" width="4%"/> Exemplo - M√©todo Limit:

```java
System.out.println("\nExemplo - M√©todo Limit");

List<Integer> primeirosCinco = numeros.stream()
    .limit(5)
    .collect(Collectors.toList());

System.out.println("\nOs 5 primeiros n√∫meros: " + primeirosCinco);
```

No c√≥digo acima, a opera√ß√£o **limit(5)** restringe o n√∫mero de elementos da Stream para os cinco primeiros da lista `numeros`. Em seguida, a Stream √© convertida em uma nova lista chamada `primeirosCinco`.

<img src="https://i.imgur.com/V2ReOnx.png" width="3%"/> **Resultado:**

```bash
Os 5 primeiros n√∫meros: [1, 2, 3, 4, 5]
```

<br />

<h3>2.6. Skip</h3>



O m√©todo **skip(n)** ignora os `n` primeiros elementos da Stream, retornando os elementos restantes.



### <img src="https://i.imgur.com/gsSDe7P.png" width="4%"/> Exemplo - M√©todo Skip:

```java
System.out.println("\nExemplo - M√©todo Skip");

List<Integer> ignorarCinco = numeros.stream()
    .skip(5)
    .collect(Collectors.toList());

System.out.println("\nIgnorar os 5 primeiros n√∫meros: " + ignorarCinco);
```

Aqui, o m√©todo **skip(5)** descarta os cinco primeiros elementos da lista `numeros`. A nova lista `ignorarCinco` cont√©m apenas os elementos restantes ap√≥s essa opera√ß√£o.

<img src="https://i.imgur.com/V2ReOnx.png" width="3%"/> **Resultado:**

```bash
Ignorar os 5 primeiros n√∫meros: [6, 7, 8, 9, 10]
```

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="25px"/> <a href="https://github.com/rafaelq80/exemplos_java/tree/main/stream/streams_01" target="_blank"><b>C√≥digo fonte - Exemplos - Parte 01</b></a>

<br />

<h2>3. M√©todos Terminais</h2>



**M√©todos Terminais** ou **Opera√ß√µes Terminais** s√£o m√©todos que **finalizam** o processo de transforma√ß√£o de uma Stream e **retornam** um valor ou um objeto. Ap√≥s a execu√ß√£o de uma opera√ß√£o terminal, a Stream n√£o pode ser modificada por outras opera√ß√µes intermedi√°rias ou novas opera√ß√µes terminais.

Antes de continuarmos, adicione a Collection abaixo dentro do seu c√≥digo:

```java
List<String> estados = Arrays.asList("S√£o Paulo", "Rio de Janeiro", "Minas Gerais", 
"Espirito Santo", "Rio Grande do Sul", "Santa Catarina", "Paran√°");
```

<br />

<h3>3.1. Collect</h3>



Como vimos nos exemplos anteriores, a opera√ß√£o **`collect()`** √© um dos m√©todos terminais mais utilizados. Ela √© usada para **coletar** os resultados de uma Stream e criar uma nova Collection (como uma lista, conjunto ou mapa).

No exemplo abaixo, vamos combinar v√°rias opera√ß√µes intermedi√°rias e, no final, coletar o resultado em uma nova **List**:



### <img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="4%"/> Exemplo - M√©todo Collect:

```java
		List <String> estadosR = estados.stream()
		        .filter(x-> x.startsWith("R"))
		        .sorted()
		        .collect(Collectors.toList());

		System.out.println("\nEstados cujo nome come√ßam com a letra R: " + estadosR);
		
```

No c√≥digo acima, foi passado como par√¢metro do M√©todo **filter()** a **Express√£o Lambda:** `x -> x.toString().startsWith("R")`. Esta Express√£o Lambda verifica em cada elemento da Collection **estados**, se o nome do estado inicia com a letra R, atrav√©s do M√©todo **startsWith()**, da Classe String. 

**Exemplo:** 

- **Rio de Janeiro** inicia com a letra R. 
- **S√£o Paulo** n√£o inicia com a letra R.

| <img src="https://i.imgur.com/RfjtOFi.png" title="source: imgur.com" width="100px"/> | <div align="left">**DICA:** *Caso voc√™ tenha d√∫vidas sobre a Classe String, acesse o Cookbook Trabalhando com Strings em Java clicando [aqui](https://github.com/rafaelq80/cookbook_java/blob/main/b02.md)* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

Na sequ√™ncia, ordena em ordem crescente a Stream que cont√©m os estados iniciados com a letra R, atrav√©s do M√©todo **Sorted()**. 

Observe que neste exemplo, foram utilizadas 2 Opera√ß√µes Intermedi√°rias e 1 Opera√ß√£o Terminal, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/BokLPP4.png" title="source: imgur.com" /></div>

Para concluir o pipeline, atrav√©s do M√©todo Terminal **collect()**, convertemos a Stream em uma nova Collection chamada **estadosR**. O resultado do algoritmo voc√™ confere abaixo:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exemplo - M√©todo Collect

Estados cujo nome come√ßam com a letra R: [Rio Grande do Sul, Rio de Janeiro]
```

<br />

<h3>3.2. Count</h3>



A opera√ß√£o terminal **`count()`** retorna o n√∫mero de elementos presentes no resultado final das opera√ß√µes realizadas na Stream. No exemplo a seguir, vamos contar quantos estados terminam com a letra "o":



### <img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="4%"/> Exemplo - M√©todo Count:

```java
		System.out.println("\nExemplo - M√©todo Count");
		
		long numeroEstadosTerminaComO = estados.stream()
		        .filter(x-> x.endsWith("o"))
		        .count();

		System.out.println("\nN√∫mero de Estados cujo nome terminam com a letra O: " + numeroEstadosTerminaComO);

```

No c√≥digo acima, foi passado como par√¢metro do m√©todo **`filter()`** a **express√£o lambda**: `x -> x.endsWith("o")`.

Essa express√£o verifica, para cada elemento da Collection `estados`, se o nome do estado termina com a letra **"o"**, utilizando o m√©todo **`endsWith()`** da classe **`String`**.

O resultado da contagem √© armazenado em uma vari√°vel do tipo **`long`**, chamada **`numeroEstadosTerminaComO`**. A vari√°vel ser√° do tipo `long`, porque o m√©todo `count()` retorna um numero do tipo `long`. 

Esse valor representa quantos estados, dentro da lista, atendem √† condi√ß√£o definida no filtro. O resultado do algoritmo voc√™ confere abaixo:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exemplo - M√©todo Count

N√∫mero de Estados cujo nome terminam com a letra O: 3
```

<br />

<h3>3.3. AllMatch</h3>



A opera√ß√£o terminal **`allMatch()`** verifica se **todos os elementos** da Stream atendem a uma determinada condi√ß√£o. No exemplo abaixo, vamos verificar se todos os estados da lista cont√™m a palavra **"Rio"**:



### <img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="4%"/> Exemplo - M√©todo AllMatch:

```java
		System.out.println("\nExemplo - M√©todo AllMatch");
		
		boolean todosEstadosContemRio = estados.stream()
				.allMatch(x -> x.contains("Rio"));

		System.out.println("\nTodos os Estados cont√©m a palavra Rio? " + todosEstadosContemRio);
		
```

No c√≥digo acima, usamos a **express√£o lambda:**  `x -> x.contains("Rio")` como condi√ß√£o dentro do m√©todo **`allMatch()`**.

Essa express√£o verifica se, em cada elemento da Collection `estados`, o nome do estado cont√©m a palavra **"Rio"**, utilizando o m√©todo **`contains()`** da classe **`String`**.

O resultado da verifica√ß√£o √© armazenado em uma vari√°vel do tipo **`boolean`**, chamada **`todosEstadosContemRio`**. O valor ser√°:

- `true` se **todos** os estados contiverem "Rio";
- `false` se **algum** estado **n√£o** contiver "Rio".

 O resultado do algoritmo voc√™ confere abaixo:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exemplo - M√©todo AllMatch

Todos os Estados cont√©m a palavra Rio? false

```

<br />

<h3>3.4. AnyMatch</h3>



Em compara√ß√£o com a opera√ß√£o **`allMatch()`**, a opera√ß√£o **`anyMatch()`** verifica se **pelo menos um** dos elementos da Stream atende a uma determinada condi√ß√£o. No exemplo abaixo, vamos verificar se **algum estado** da lista cont√©m a palavra **"Rio"**:



### <img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="4%"/> Exemplo - M√©todo AnyMatch:

```java
System.out.println("\nExemplo - M√©todo AnyMatch");
		
		boolean algumEstadoContemRio = estados.stream()
				.anyMatch(x -> x.contains("Rio"));

		System.out.println("\nPelo menos um Estado cont√©m a palavra Rio? " + algumEstadoContemRio);
		
```

No c√≥digo acima, utilizamos a **express√£o lambda:**  `x -> x.contains("Rio")` como condi√ß√£o do m√©todo **`anyMatch()`**.

Essa express√£o verifica, para cada elemento da Collection `estados`, se o nome do estado **cont√©m a palavra "Rio"**, utilizando o m√©todo **`contains()`** da classe **`String`**.

O resultado da verifica√ß√£o √© armazenado em uma vari√°vel do tipo **`boolean`**, chamada **`algumEstadoContemRio`**. O valor ser√°:

- `true` se **algum estado** contiver "Rio";
- `false` se **nenhum estado** contiver "Rio".

O resultado do algoritmo voc√™ confere abaixo:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exemplo - M√©todo AnyMatch

Pelo menos um Estado cont√©m a palavra Rio? true
```

<br />

<h3>3.5. ForEach</h3>



O m√©todo **`forEach()`** √© utilizado para **iterar sobre a Collection resultante da Stream**, de forma semelhante ao la√ßo de repeti√ß√£o `for` tradicional.

Veja o exemplo abaixo, onde, em vez de armazenar os dados em uma nova Collection, apenas exibiremos os elementos diretamente no console:



### <img src="https://i.imgur.com/gsSDe7P.png" title="source: imgur.com" width="4%"/> Exemplo - M√©todo ForEach:

```java
		System.out.println("\nExemplo - M√©todo ForEach");
		
		System.out.println("\nEstados cujo nome iniciam com a letra S:");
		
		estados.stream()
		        .filter(x-> x.startsWith("S"))
		        .forEach(System.out::println);
		
```

No c√≥digo acima, foi utilizada a **express√£o lambda:**  `x -> x.startsWith("S")` como condi√ß√£o no m√©todo **`filter()`**.

Essa express√£o verifica se o nome de cada estado **inicia com a letra "S"**, utilizando o m√©todo **`startsWith()`** da classe **`String`**.

Na sequ√™ncia, com o uso do m√©todo **`forEach()`**, a Stream resultante √© percorrida, e **cada elemento filtrado √© exibido na tela**. O resultado do algoritmo voc√™ confere abaixo:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Exemplo - M√©todo ForEach

Estados cujo nome iniciam com a letra S:
S√£o Paulo
Santa Catarina

```

No link abaixo, voc√™ pode obter o c√≥digo completo do Exemplo acima.

<br />

<h3>3.6. Reduce</h3>



O m√©todo **reduce()** combina todos os elementos da Stream em um √∫nico valor, como soma, multiplica√ß√£o ou concatena√ß√£o.



### <img src="https://i.imgur.com/gsSDe7P.png" width="4%"/> Exemplo - M√©todo Reduce:

```java
System.out.println("\nExemplo - M√©todo Reduce");

int soma = numeros.stream()
    .reduce(0, Integer::sum);

System.out.println("\nSoma dos n√∫meros: " + soma);
```

Neste exemplo, a opera√ß√£o `reduce(0, Integer::sum)` inicia com valor 0 e aplica a soma de todos os n√∫meros da lista.

<img src="https://i.imgur.com/V2ReOnx.png" width="3%"/> **Resultado:**

```bash
Soma dos n√∫meros: 55
```

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="25px"/> <a href="https://github.com/rafaelq80/exemplos_java/tree/main/stream/streams_02" target="_blank"><b>C√≥digo fonte - Exemplos - Parte 02</b></a>
<br />

------

### üîë**Pontos chave:**

- **Stream** √© um pipeline (conjunto) de opera√ß√µes que pode ser utilizado para processar os dados armazenados em uma **Collection** ou **Array**.
- Uma **Stream** possui dois tipos de opera√ß√µes: **intermedi√°rias** e **terminais**.
- As **opera√ß√µes intermedi√°rias** retornam uma nova Stream, permitindo o encadeamento de m√∫ltiplas opera√ß√µes.
- As **opera√ß√µes terminais** encerram o pipeline, retornando um valor ou objeto. Ap√≥s a execu√ß√£o de uma opera√ß√£o terminal, a mesma Stream n√£o poder√° ser reutilizada para novas opera√ß√µes.
- Uma **Stream n√£o √© uma estrutura de dados**; ela **consome** uma estrutura de dados existente (como uma Collection ou Array) para realizar opera√ß√µes sobre seus elementos.
- A **Stream n√£o altera a estrutura de dados original** ‚Äî ela apenas fornece um resultado conforme os m√©todos definidos na pipeline.
- A **Stream n√£o armazena dados**; ela apenas opera sobre os dados da estrutura de origem.
- Streams **n√£o s√£o modific√°veis**, ou seja, **n√£o √© poss√≠vel adicionar ou remover elementos** diretamente por meio delas.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
