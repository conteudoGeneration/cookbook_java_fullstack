<h1>Estruturas de Dados</h1>



As estruturas de dados são formas de organizar e armazenar informações em computadores para que possamos realizar operações de maneira mais eficiente. Elas abrangem um campo amplo e fundamental dentro da ciência da computação e da engenharia de software.

De modo simples, uma estrutura de dados é um contêiner que armazena dados em um formato específico. Esse formato determina quais operações serão realizadas com maior ou menor eficiência. O principal objetivo é compreender as características de cada estrutura para escolher a mais adequada ao problema que se deseja resolver.

Estruturas de dados são utilizadas em praticamente todos os sistemas e softwares desenvolvidos para os mais variados fins. Inclusive, em nosso curso, você já utilizou algumas delas, muitas vezes sem perceber.

<br />

<h3>1.1. Por que precisamos de estruturas de dados ?</h3>



Como as estruturas de dados organizam o armazenamento das informações, e considerando que os dados são a parte mais essencial da ciência da computação, fica evidente a importância dessas estruturas.

Independentemente do problema que você esteja enfrentando, em algum momento terá que lidar com dados — seja o salário de um funcionário, preços de ações, uma lista de compras de um e-commerce ou mesmo uma simples lista telefônica.

Dependendo do contexto, os dados precisam ser armazenados em formatos específicos. Para isso, existem diferentes estruturas de dados que atendem às necessidades de armazenamento e manipulação em variadas situações.

No próximos tópicos, vamos conhecer as principais Estruturas de dados.

<br />

<h2>2. Array</h2>



**Array** foi a primeira estrutura de dados que estudamos e é uma das mais populares, simples e amplamente utilizadas no dia a dia pelas pessoas desenvolvedoras. Trata-se de uma estrutura baseada em índice, o que significa que cada elemento é referenciado por um índice numérico. Além disso, é uma estrutura de tamanho fixo que armazena itens de um mesmo tipo de dado. Os arrays podem ser classificados em três categorias principais:

1. **Unidimensionais (Vetor):** Um array unidimensional é composto por uma única dimensão, ou seja, uma linha contendo N colunas do mesmo tipo, onde N representa o número máximo de elementos que o vetor pode armazenar. Para acessar cada elemento, utilizamos o índice da coluna: `vetor[indice]`.

<div align="center"><img src="https://i.imgur.com/uAj5USU.png" title="source: imgur.com" /></div>

2. **Bidimensionais (Matriz):** Um array bidimensional possui duas dimensões: linha (I) e coluna (J). Aqui, I é o número máximo de linhas e J o número máximo de colunas da matriz. A capacidade total da matriz é dada pela multiplicação do número de linhas pelo número de colunas. Por exemplo, uma matriz 3 x 3 (3 linhas por 3 colunas) pode armazenar até 9 elementos (3 * 3 = 9). Para acessar um elemento específico, utilizamos o par de índices: `matriz[linha][coluna]`.

<div align="center"><img src="https://i.imgur.com/n96Fbia.png" title="source: imgur.com" /></div>

3. **Multidimensionais:** São arrays que possuem três ou mais dimensões. Apesar de, matematicamente, ser impossível representar mais do que três dimensões, na programação é possível trabalhar com arrays tridimensionais ou maiores. Um array tridimensional pode ser visto como uma coleção de matrizes. Para acessar um elemento, utilizamos um conjunto de três índices: `matriz3d[numero_da_matriz][linha][coluna]`.

<div align="center"><img src="https://i.imgur.com/qI8qwAx.png" title="source: imgur.com" /></div>

No tópico Arrays, estudamos a implementação de arrays unidimensionais (vetores) e bidimensionais (matrizes). No tópico Collections, aprendemos também sobre arrays dinâmicos, ou seja, estruturas semelhantes a arrays, porém sem tamanho fixo, que podem crescer ou diminuir conforme a necessidade.

<br />

<h2>3. HashMap</h2> 



**HashMap** foi a segunda estrutura de dados estudada no tópico **Collections**, durante a abordagem da coleção **Set**. Um **HashMap** é uma estrutura baseada em pares do tipo **chave-valor**, onde cada valor é associado a uma chave única. Os elementos são organizados com base no **hash code** gerado a partir da chave.

Ao adicionar um elemento, o HashMap calcula automaticamente um código hash (por meio de uma função de dispersão) para a chave fornecida. Esse código determina a posição onde o valor será armazenado na tabela de forma eficiente. Como esse cálculo depende do conteúdo da chave, a posição final do par chave-valor pode parecer aleatória na estrutura interna, mas é estrategicamente definida para otimizar o acesso.

Essa organização torna o **HashMap** muito eficiente para operações de busca, inserção e remoção, quando realizadas por chave.

<div align="center"><img src="https://i.imgur.com/xSBwPjD.png" title="source: imgur.com" /></div>

<br />

<h2>4. Fila</h2>



A **Fila** é uma estrutura de dados do tipo **FIFO** (*First-In, First-Out*), ou seja, **o primeiro elemento que entra é o primeiro a sair**. A ideia central é simples: só é possível **inserir um novo elemento no final da fila** e **remover um elemento do início**. Essa lógica é semelhante às filas que enfrentamos no dia a dia — a primeira pessoa a chegar é a primeira a ser atendida.

<div align="center"><img src="https://i.imgur.com/h43C5MC.png" title="source: imgur.com" /></div>

Na imagem acima, observamos que a fila permite manipulação nas duas extremidades: **inserções** ocorrem na **cauda** (fim da fila) e **remoções** ocorrem na **frente** (início da fila).

<br />

<h3>4.1. A Collection Queue</h3>



Para implementarmos a estrutura de dados Fila em Java, utilizamos a Collection **Queue**, que representa uma **lista ordenada de elementos**, seguindo rigorosamente o princípio **FIFO**. Elementos são adicionados no final da lista e removidos do início.

**Sintaxe:**

```java
Queue<T> fila = new LinkedList<T>();
```

O construtor acima cria um objeto da classe **LinkedList** vazio. O item `<T>` representa um **tipo genérico** em Java (Java Generics), permitindo definir o tipo de objeto que será armazenado na fila. Esse tipo deve obrigatoriamente ser uma **classe** — podendo ser uma **classe wrapper** (como `Integer`, `Double`, `String`) ou uma **classe personalizada** criada pela pessoa desenvolvedora.

<br />

<h3>4.2. Por quê utilizamos a Classe LinkedList?</h3>



A **classe LinkedList** implementa uma estrutura chamada **lista duplamente encadeada**, formada por nós (elementos) que armazenam:

 - o dado em si;
 - um ponteiro para o **nó anterior**;
 - um ponteiro para o **próximo nó** da lista.

 > Em programação, um **ponteiro** é uma variável especial que **armazena o endereço de memória** de outra variável. Ou seja, um ponteiro **aponta para** a localização de um dado na memória, em vez de armazenar diretamente o valor desse dado.
 >
 > Embora o Java **não utilize ponteiros de forma explícita**, como ocorre em linguagens como C ou C++, o conceito de **referência** — que funciona como uma forma segura e controlada de ponteiro — está presente e é essencial para o funcionamento da linguagem.
 >
 > Ao criar um objeto em Java, ele é alocado na **heap** (área de memória dinâmica), e a variável correspondente armazena uma **referência** para esse objeto — ou seja, um identificador gerenciado pela **JVM** (Java Virtual Machine) que indica onde o objeto está localizado na memória.

 Além disso, existe um ponteiro chamado **HEAD**, que aponta para o **primeiro elemento da lista**. Se a lista estiver vazia, o HEAD apontará para `null`.

 <div align="center"><img src="https://i.imgur.com/s67yOIi.png" title="source: imgur.com" /></div>

 Na imagem acima, vemos que o ponteiro **HEAD** indica o início da lista. Cada elemento da lista conhece o seu antecessor e o seu sucessor. O último elemento da lista aponta para `null`, indicando que não há elementos posteriores.

Essa estrutura permite que a **LinkedList** realize inserções e remoções com eficiência nas extremidades, o que a torna ideal para a implementação da estrutura de dados Fila.

<br />

<h3>4.3. Principais Métodos da Classe Queue</h3>



Na tabela abaixo, listamos os principais Métodos para trabalharmos com a Collection **Queue**:

**✅ - Tabela - Métodos da Classe Queue**

| Método               | Descrição                                                    |
| -------------------- | ------------------------------------------------------------ |
| `add(elemento)`      | Adiciona um elemento ao final da fila.                       |
| `size()`             | Retorna o número total de elementos na fila.                 |
| `clear()`            | Remove todos os elementos da fila.                           |
| `remove()`           | Remove e retorna o primeiro elemento da fila.                |
| `isEmpty()`          | Verifica se a fila está vazia. Retorna `true` se estiver vazia, caso contrário, `false`. |
| `contains(elemento)` | Verifica se a fila contém o elemento especificado.           |
| `peek()`             | Retorna, **sem remover**, o primeiro elemento da fila, ou `null` se estiver vazia. |
| `poll()`             | Retorna **e remove** o primeiro elemento da fila, ou `null` se estiver vazia. |

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html" target="_blank"><b>Artigo: Java Tutorials: Collection Queue</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html" target="_blank"><b>Documentação: Collection Queue</b></a></div>

<br />

Vamos construir uma aplicação simples de **chamada de senhas em um painel de atendimento**, utilizando a **Collection `Queue`** para simular o funcionamento da fila de espera. A estrutura armazenará uma lista de números inteiros representando as senhas a serem chamadas.

Esses números serão objetos da **classe wrapper `Integer`**, uma vez que as Collections em Java **não aceitam tipos primitivos**, como `int`. Em seguida, realizaremos alguns testes práticos com os principais métodos da interface `Queue`,  para manipular e exibir as senhas em ordem de atendimento.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 01 - Fila

```java
package exemplos_estruturas_dados;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;

public class Exemplo01 {

	public static void main(String[] args) {

		Queue<Integer> fila = new LinkedList<Integer>();

		System.out.println("========== SISTEMA DE CHAMADA DE SENHAS ==========\n");

		// Adiciona senhas de 0 a 10
		System.out.println("[1] Adicionando senhas de 0 a 10 na fila...");
		for (int i = 0; i <= 10; i++) {
			fila.add(i);
		}
		System.out.println("Fila atual: " + fila);

		// Remove o primeiro elemento
		System.out.println("\n[2] Chamando a primeira senha (remove): " + fila.remove());
		System.out.println("Fila após a remoção: " + fila);

		// Adiciona o número 11
		System.out.println("\n[3] Adicionando nova senha (11): " + fila.add(11));
		System.out.println("Fila atualizada: " + fila);

		// Exibe o primeiro elemento (sem remover)
		System.out.println("\n[4] Próxima senha a ser chamada (peek): " + fila.peek());

		// Exibe o tamanho da fila
		System.out.println("\n[5] Quantidade de senhas na fila: " + fila.size());

		// Verifica se a senha 4 está na fila
		System.out.println("\n[6] A senha 4 está na fila? " + fila.contains(4));

		// Exibe e remove o primeiro elemento
		System.out.println("\n[7] Chamando e removendo a próxima senha (poll): " + fila.poll());
		System.out.println("Fila atual: " + fila);

		// Iteração sobre os elementos restantes
		System.out.println("\n[8] Senhas restantes na fila (iterando):");
		Iterator<Integer> iterator = fila.iterator();
		while (iterator.hasNext()) {
			System.out.println("→ Senha: " + iterator.next());
		}

		// Limpa a fila
		System.out.println("\n[9] Limpando todas as senhas da fila...");
		fila.clear();

		// Verifica se a fila está vazia
		System.out.println("[10] A fila está vazia? " + fila.isEmpty());

		System.out.println("\n==================================================");
		System.out.println("Sistema finalizado.");
	}
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
========== SISTEMA DE CHAMADA DE SENHAS ==========

[1] Adicionando senhas de 0 a 10 na fila...
Fila atual: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

[2] Chamando a primeira senha (remove): 0
Fila após a remoção: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

[3] Adicionando nova senha (11): true
Fila atualizada: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]

[4] Próxima senha a ser chamada (peek): 1

[5] Quantidade de senhas na fila: 11

[6] A senha 4 está na fila? true

[7] Chamando e removendo a próxima senha (poll): 1
Fila atual: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]

[8] Senhas restantes na fila (iterando):
→ Senha: 2
→ Senha: 3
→ Senha: 4
→ Senha: 5
→ Senha: 6
→ Senha: 7
→ Senha: 8
→ Senha: 9
→ Senha: 10
→ Senha: 11

[9] Limpando todas as senhas da fila...
[10] A fila está vazia? true

==================================================
Sistema finalizado.
```

Confira os comentários inseridos no código para compreender o funcionamento do programa. Eles explicam, passo a passo, a lógica aplicada na manipulação da fila, desde a adição de números inteiros na estrutura até as operações de remoção e consulta dos elementos.

<br />

<h2>5. Pilha</h2>



Uma **Pilha** é uma estrutura de dados do tipo **LIFO** — *“Last In, First Out”* (último a entrar, primeiro a sair). Isso significa que o último elemento inserido na pilha será o primeiro a ser retirado. A característica fundamental da pilha é que as operações de inserção e remoção acontecem apenas no **topo** da estrutura.

O nome *“pilha”* vem da analogia com objetos do cotidiano, como uma pilha de pratos: o último prato colocado em cima é o primeiro a ser retirado.

<div align="center"><img src="https://i.imgur.com/y8maSln.png" title="source: imgur.com" /></div>

Observe na imagem acima que as duas operações básicas em uma pilha são:

- **PUSH** (empilhar): insere um elemento no topo da pilha.
- **POP** (desempilhar): remove o elemento do topo da pilha e o retorna (ou não).

<br />

<h3>5.1. A Collection Deque como Pilha</h3>



Para implementarmos a estrutura de dados **Pilha** em Java, utilizamos a Collection **Deque** (*Double-Ended Queue* - Fila dupla), que permite a manipulação de elementos em ambas as extremidades da estrutura. Ao usarmos `Deque` como uma pilha, seguimos o princípio **LIFO (Last-In, First-Out)**, onde **o último elemento inserido é o primeiro a ser removido**.

**Sintaxe:**

```java
Deque<T> pilha = new ArrayDeque<T>();
```

O construtor acima cria um objeto da classe **ArrayDeque** vazio. O item `<T>` representa um **tipo genérico** em Java (Java Generics), permitindo definir o tipo de objeto que será armazenado na pilha. Esse tipo deve obrigatoriamente ser uma **classe** — podendo ser uma **classe wrapper** (como `Integer`, `Double`, `String`) ou uma **classe personalizada** criada pela pessoa desenvolvedora.

> [!TIP]
>
> Embora o nome da classe seja `ArrayDeque`, quando utilizada com os métodos adequados (`push`, `pop`, `peek`), ela se comporta como uma pilha moderna e eficiente.

<br />

<h3>4.2. Por que utilizar a classe ArrayDeque?</h3>



A classe **ArrayDeque** é uma alternativa moderna à antiga classe `Stack`, que é considerada **legacy** (obsoleta para novos projetos). Ela é implementada internamente com um **array redimensionável**, oferecendo desempenho superior na maioria dos cenários.

Diferente da `Stack`, que herda de `Vector` (uma estrutura sincronizada e mais pesada), o `ArrayDeque` **não é sincronizado** e, portanto, é **mais leve e rápido** em contextos de execução `single-thread`, como a Linguagem Java.

> [!NOTE]
>
> **Single-thread** significa que o programa roda **uma tarefa por vez**, em **uma única linha de execução**.
>
> **Multi-thread** significa que o programa pode rodar **mais de uma tarefa ao mesmo tempo**, em **múltiplas linhas de execução (threads)**.

Além disso, a `ArrayDeque` é versátil: pode ser usada como **fila ou pilha**, dependendo dos métodos que escolhemos utilizar.

A coleção **`ArrayDeque` não oferece acesso por índice** como a coleção `ArrayList`, pois ela **não implementa a interface `List`**, mas sim a interface `Deque`. Portanto, o método **`get(index)` não está disponível diretamente no `ArrayDeque`**.

Caso seja necessário acessar elementos por índice, é preciso primeiro converter a estrutura para um array, utilizando o método **`toArray()`**, ou para uma lista, criando uma nova instância de **`ArrayList` a partir do** `deque` (`new ArrayList<>(deque)`). Vale lembrar que essas conversões criam uma cópia dos elementos, o que pode impactar a eficiência dependendo do uso.

> **Pensando em um exemplo do dia a dia: Stack vs ArrayDeque**
>
> - O `Stack` é como **um cofre com chave**: toda vez que alguém vai colocar ou tirar algo, precisa abrir e fechar a chave (seguro, mas mais lento devido à sincronização).
> - O `ArrayDeque` é como **uma gaveta aberta**: qualquer pessoa pode colocar ou tirar coisas rapidamente (rápido, mas perigoso se várias pessoas tentarem mexer ao mesmo tempo – `multi-thread`).
>
> 👉 Como a maioria dos programas Java roda em **single-thread**, o `ArrayDeque` geralmente apresenta **melhor desempenho** do que o `Stack`.

<br />

<h3>4.3. Principais Métodos da Collection Deque (modo Pilha)</h3>



Na tabela abaixo, listamos os principais Métodos para trabalharmos com a Collection **Deque**:

**✅ - Tabela - Métodos da Classe Deque**

| Método               | Descrição                                                    |
| -------------------- | ------------------------------------------------------------ |
| `push(elemento)`     | Adiciona um elemento no topo da pilha.                       |
| `pop()`              | Remove e retorna o elemento do topo da pilha.                |
| `peek()`             | Retorna, **sem remover**, o elemento do topo da pilha.       |
| `size()`             | Retorna o número total de elementos na pilha.                |
| `clear()`            | Remove todos os elementos da pilha.                          |
| `isEmpty()`          | Verifica se a pilha está vazia.                              |
| `contains(elemento)` | Verifica se a pilha contém o elemento especificado.          |
| `toArray()`          | Retorna um array com todos os elementos da pilha (útil para iteração). |

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/deque.html" target="_blank"><b>Artigo: Java Tutorials: Collection Deque</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html" target="_blank"><b>Documentação: Collection Deque</b></a></div>

<br />

Vamos construir uma aplicação simples de **controle de pratos empilhados**, utilizando a **Collection `Deque`** para simular o funcionamento de uma pilha, onde o último prato adicionado será o primeiro a ser retirado (LIFO).

A estrutura armazenará uma lista de elementos do tipo `String`, representando os nomes dos pratos empilhados.

Em seguida, realizaremos alguns testes práticos com os principais métodos da classe `Stack`, para manipular e exibir os pratos conforme a ordem correta da pilha.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 02 - Pilha

```java
package exemplos_estruturas_dados;

import java.util.ArrayDeque;
import java.util.Deque;

public class Exemplo02 {

    public static void main(String[] args) {

        // Criação de uma pilha usando ArrayDeque
        Deque<String> pilha = new ArrayDeque<>();

        // Variável para identificar a posição do elemento na pilha
        int contador = 0;
        
        // Adiciona elementos no topo da pilha
        pilha.push("Prato Verde");
        pilha.push("Prato Azul");
        pilha.push("Prato Branco");
        pilha.push("Prato Amarelo");
        pilha.push("Prato Vermelho");

        // Exibe os elementos da pilha do topo para a base
        System.out.println("\nElementos da Pilha (topo → base):");
        contador = pilha.size();
        
        for (String prato : pilha) {
        	System.out.printf("[%d] %s%n", contador, prato);
        	contador --;
        }
       
        // Remove o elemento do topo da pilha
        System.out.println("\nRetirar elemento: " + pilha.pop());

        // Exibe os elementos da pilha após remoção
        System.out.println("\nElementos da Pilha (topo → base):");
        contador = pilha.size();
        
        for (String prato : pilha) {
        	System.out.printf("[%d] %s%n", contador, prato);
        	contador --;
        }

        // Remove mais um elemento do topo da pilha
        System.out.println("\nRetirar elemento: " + pilha.pop());

        // Exibe os elementos da pilha após nova remoção
        System.out.println("\nElementos da Pilha (topo → base):");
        contador = pilha.size();
        
        for (String prato : pilha) {
        	System.out.printf("[%d] %s%n", contador, prato);
        	contador --;
        }

        // Mostra o elemento atual no topo da pilha sem removê-lo
        System.out.println("\nElemento no topo da Pilha: " + pilha.peek());

        // Adiciona um novo elemento ao topo da pilha
        pilha.push("Prato Roxo");

        // Informa que um novo prato foi adicionado
        System.out.println("\nAdicionar Elemento Prato Roxo");

        // Exibe a pilha atualizada após adição
        System.out.println("\nPilha Atualizada (topo → base):");
        contador = pilha.size();
        
        for (String prato : pilha) {
        	System.out.printf("[%d] %s%n", contador, prato);
        	contador --;
        }
        
        // Exibe o tamanho atual da pilha
        System.out.println("\nTamanho da Pilha: " + pilha.size());

        // Verifica se a pilha contém um elemento específico
        System.out.println("\nO Elemento Prato Verde existe na Pilha? " + pilha.contains("Prato Verde"));

        // Exibe todos os elementos da pilha usando uma nova iteração
        System.out.println("\nExibir todos os Elementos da Pilha por Iteração (topo → base):");
        contador = pilha.size();
        
        for (String prato : pilha) {
        	System.out.printf("[%d] %s%n", contador, prato);
        	contador --;
        }

        // Limpa todos os elementos da pilha
        pilha.clear();

        // Verifica se a pilha está vazia
        System.out.println("\nA Pilha está vazia? " + pilha.isEmpty());
    }
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash

Elementos da Pilha (topo → base):
[5] Prato Vermelho
[4] Prato Amarelo
[3] Prato Branco
[2] Prato Azul
[1] Prato Verde

Retirar elemento: Prato Vermelho

Elementos da Pilha (topo → base):
[4] Prato Amarelo
[3] Prato Branco
[2] Prato Azul
[1] Prato Verde

Retirar elemento: Prato Amarelo

Elementos da Pilha (topo → base):
[3] Prato Branco
[2] Prato Azul
[1] Prato Verde

Elemento no topo da Pilha: Prato Branco

Adicionar Elemento Prato Roxo

Pilha Atualizada (topo → base):
[4] Prato Roxo
[3] Prato Branco
[2] Prato Azul
[1] Prato Verde

Tamanho da Pilha: 4

O Elemento Prato Verde existe na Pilha? true

Exibir todos os Elementos da Pilha por Iteração (topo → base):
[4] Prato Roxo
[3] Prato Branco
[2] Prato Azul
[1] Prato Verde

A Pilha está vazia? true
```

Confira os comentários inseridos no código para compreender o funcionamento do programa. Eles explicam, passo a passo, a lógica aplicada na manipulação da pilha, desde a adição de números inteiros na estrutura até as operações de remoção e consulta dos elementos.

<br />

<h2>6. Outras Estruturas de dados</h2>



Neste tópico, faremos uma breve introdução a outras estruturas de dados amplamente utilizadas, especialmente em pesquisas e manipulação avançada de informações. O objetivo é fornecer um overview para que você identifique onde aprofundar seus estudos, com referências que poderão complementar seu aprendizado.

<br />

> [!NOTE]
>
> **ALERTA DE BSM** 
>
> *Mantenha a Orientação ao Futuro em relação às Estruturas de Dados!*
>
> Este tema é vasto e essencial para o desenvolvimento profissional. Embora seja amplamente utilizado no cotidiano dos desenvolvedores, dominar estruturas de dados exige tempo, prática constante e muita persistência.

<br />

<h3>6.1 Lista Encadeada (Linked List)</h3>



A **Lista Encadeada** é uma estrutura sequencial composta por uma série de elementos organizados linearmente, onde cada elemento (ou nó) contém dados e um ponteiro para o próximo nó na sequência. Por isso, o acesso aos elementos é sequencial — o acesso aleatório não é possível diretamente.

O primeiro elemento da lista é apontado por um ponteiro chamado **Head** (cabeça), enquanto o último nó é conhecido como **Tail** (cauda).

Existem duas formas principais de implementar listas encadeadas:

- **Lista Encadeada Simples (Singly Linked List):** Os elementos são percorridos em uma única direção, utilizando um ponteiro chamado **next** que aponta para o próximo nó da lista.

<div align="center"><img src="https://i.imgur.com/75ATOqR.png" title="source: imgur.com" /></div>

- **Lista Duplamente Encadeada (Doubly Linked List):** Os elementos possuem dois ponteiros: um para o próximo nó (**next**) e outro para o nó anterior (**prev**), permitindo a navegação em ambas as direções, para frente e para trás.

 <div align="center"><img src="https://i.imgur.com/s67yOIi.png" title="source: imgur.com" /></div>

Essa estrutura torna as operações de inserção e remoção mais eficientes, pois para adicionar ou excluir um nó, basta ajustar os ponteiros dos nós vizinhos, sem a necessidade de mover todos os elementos.

O uso típico de listas encadeadas ocorre quando precisamos:

- Adicionar ou remover elementos no início ou no fim da lista;
- Acessar e percorrer os elementos sequencialmente;
- Implementar outras estruturas, como pilhas e filas, com eficiência.

<br />

<h3>6.2. Árvore (Tree)</h3>



Uma **Árvore** é uma estrutura hierárquica em que os dados são organizados em níveis, com cada elemento (nó) podendo ter um ou mais “filhos”. Diferentemente da lista encadeada, que é linear, a árvore permite relacionamentos ramificados entre os dados.

Diversos tipos de árvores foram desenvolvidos para atender a necessidades específicas, entre os mais comuns estão:

- Árvore Binária de Pesquisa (Binary Search Tree — BST)
- Árvore Red-Black
- Árvore Splay
- Árvore AVL

Árvores são estruturas fundamentais na representação e manipulação de dados hierárquicos, sendo amplamente utilizadas no desenvolvimento web. Por exemplo, a **DOM (Document Object Model)** de uma página HTML é organizada como uma árvore, onde cada elemento HTML é um nó conectado a seus elementos filhos, permitindo a navegação e alteração dinâmica da estrutura da página. 

<br />

<h4>6.2.1. Árvores Binárias de Busca</h4>



A Árvore Binária de Pesquisa é uma árvore binária onde os nós são organizados segundo uma ordem, garantindo que para cada nó, todos os elementos à esquerda sejam menores e todos os elementos à direita sejam maiores. Cada nó contém:

- Uma **chave (key)**, que representa o valor do nó;
- Um ponteiro para o nó filho esquerdo (valores menores);
- Um ponteiro para o nó filho direito (valores maiores);
- Um ponteiro para o nó pai.

<div align="center"><img src="https://i.imgur.com/BsD6Z1f.png" title="source: imgur.com" /></div>

Essa estrutura é amplamente usada para implementar mecanismos eficientes de busca, ordenação e processamento de expressões.

O estudo aprofundado das estruturas de dados é fundamental para qualquer profissional de tecnologia. Dominar essas estruturas amplia a capacidade de resolver problemas complexos com eficiência, além de otimizar o desempenho das aplicações.

Por isso, é essencial manter uma prática contínua, explorando tanto conceitos teóricos quanto implementações práticas, ampliando o conhecimento sobre algoritmos e suas aplicações. A familiaridade com diversas estruturas de dados possibilita escolher a ferramenta ideal para cada problema, tornando seu código mais robusto e eficiente. Portanto, dedique-se ao aprendizado progressivo dessas bases essenciais para a carreira em desenvolvimento de software e ciência da computação.

<br />

------

## 🔑**Pontos chave:**

1. **Estruturas de Dados** são formas de organizar e armazenar informações em computadores, com o objetivo de realizar operações com maior eficiência, como inserção, remoção, ordenação e busca.
2. O uso de estruturas de dados é fundamental no desenvolvimento de sistemas, algoritmos e aplicações eficientes, sendo aplicadas desde tarefas simples, como armazenar uma lista de nomes, até estruturas complexas de bancos de dados ou inteligência artificial.
3. Um dos principais benefícios é a **reutilização**: ao entender e implementar uma estrutura corretamente, é possível aplicá-la em diferentes contextos e projetos.
4. **Array** é uma estrutura baseada em **índice numérico**, de **tamanho fixo** e que armazena **elementos de um mesmo tipo**. Existem arrays unidimensionais (vetores), bidimensionais (matrizes) e multidimensionais.
5. **HashMap** é uma estrutura do tipo **chave-valor**, onde os elementos são organizados com base em um **hash code** gerado a partir da chave. Proporciona operações de inserção, busca e remoção eficientes, sendo amplamente utilizado para mapeamentos e associações dinâmicas de dados.
6. **Fila (Queue)** segue o princípio **FIFO (First In, First Out)**: o primeiro elemento inserido é o primeiro a ser removido. Em Java, a `Queue` pode ser implementada com `LinkedList`, aproveitando sua estrutura de lista duplamente encadeada.
7. **Pilha (Stack)** adota o princípio **LIFO (Last In, First Out)**: o último elemento inserido é o primeiro a ser removido. Ideal para resolver problemas onde é necessário reverter ordens ou manter controle de histórico (ex: navegação, desfazer ações, chamadas de métodos).
8. A pilha foi implementada utilizando a interface **`Deque`**, por meio da classe **`ArrayDeque`**, que oferece uma alternativa moderna e eficiente à antiga classe `Stack`, permitindo operações de inserção e remoção no topo com alto desempenho.
9. **Listas Encadeadas (Linked Lists)** armazenam elementos de forma sequencial, onde cada elemento aponta para o próximo (ou também para o anterior, no caso das listas duplamente encadeadas). Permitem inserções e remoções eficientes em posições específicas, mesmo sem acesso direto via índice.
10. **Árvores (Trees)** são estruturas hierárquicas em que cada elemento pode ter vários filhos. Árvores são amplamente utilizadas em algoritmos de busca, estruturação de dados hierárquicos, expressões lógicas e interfaces gráficas. Um exemplo real é a **DOM (Document Object Model)** do HTML, que é estruturada como uma árvore.
11. **Árvores Binárias de Busca (BSTs)** garantem uma ordenação entre os nós: os valores menores ficam à esquerda, e os maiores à direita. Esse tipo de árvore é ideal para operações de busca rápida e ordenação dinâmica.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
