<h1>Estruturas de Dados</h1>



As estruturas de dados s√£o formas de organizar e armazenar informa√ß√µes em computadores para que possamos realizar opera√ß√µes de maneira mais eficiente. Elas abrangem um campo amplo e fundamental dentro da ci√™ncia da computa√ß√£o e da engenharia de software.

De modo simples, uma estrutura de dados √© um cont√™iner que armazena dados em um formato espec√≠fico. Esse formato determina quais opera√ß√µes ser√£o realizadas com maior ou menor efici√™ncia. O principal objetivo √© compreender as caracter√≠sticas de cada estrutura para escolher a mais adequada ao problema que se deseja resolver.

Estruturas de dados s√£o utilizadas em praticamente todos os sistemas e softwares desenvolvidos para os mais variados fins. Inclusive, em nosso curso, voc√™ j√° utilizou algumas delas, muitas vezes sem perceber.

<br />

<h3>1.1. Por que precisamos de estruturas de dados ?</h3>



Como as estruturas de dados organizam o armazenamento das informa√ß√µes, e considerando que os dados s√£o a parte mais essencial da ci√™ncia da computa√ß√£o, fica evidente a import√¢ncia dessas estruturas.

Independentemente do problema que voc√™ esteja enfrentando, em algum momento ter√° que lidar com dados ‚Äî seja o sal√°rio de um funcion√°rio, pre√ßos de a√ß√µes, uma lista de compras de um e-commerce ou mesmo uma simples lista telef√¥nica.

Dependendo do contexto, os dados precisam ser armazenados em formatos espec√≠ficos. Para isso, existem diferentes estruturas de dados que atendem √†s necessidades de armazenamento e manipula√ß√£o em variadas situa√ß√µes.

No pr√≥ximos t√≥picos, vamos conhecer as principais Estruturas de dados.

<br />

<h2>2. Array</h2>



**Array** foi a primeira estrutura de dados que estudamos e √© uma das mais populares, simples e amplamente utilizadas no dia a dia pelas pessoas desenvolvedoras. Trata-se de uma estrutura baseada em √≠ndice, o que significa que cada elemento √© referenciado por um √≠ndice num√©rico. Al√©m disso, √© uma estrutura de tamanho fixo que armazena itens de um mesmo tipo de dado. Os arrays podem ser classificados em tr√™s categorias principais:

1. **Unidimensionais (Vetor):** Um array unidimensional √© composto por uma √∫nica dimens√£o, ou seja, uma linha contendo N colunas do mesmo tipo, onde N representa o n√∫mero m√°ximo de elementos que o vetor pode armazenar. Para acessar cada elemento, utilizamos o √≠ndice da coluna: `vetor[indice]`.

<div align="center"><img src="https://i.imgur.com/uAj5USU.png" title="source: imgur.com" /></div>

2. **Bidimensionais (Matriz):** Um array bidimensional possui duas dimens√µes: linha (I) e coluna (J). Aqui, I √© o n√∫mero m√°ximo de linhas e J o n√∫mero m√°ximo de colunas da matriz. A capacidade total da matriz √© dada pela multiplica√ß√£o do n√∫mero de linhas pelo n√∫mero de colunas. Por exemplo, uma matriz 3 x 3 (3 linhas por 3 colunas) pode armazenar at√© 9 elementos (3 * 3 = 9). Para acessar um elemento espec√≠fico, utilizamos o par de √≠ndices: `matriz[linha][coluna]`.

<div align="center"><img src="https://i.imgur.com/n96Fbia.png" title="source: imgur.com" /></div>

3. **Multidimensionais:** S√£o arrays que possuem tr√™s ou mais dimens√µes. Apesar de, matematicamente, ser imposs√≠vel representar mais do que tr√™s dimens√µes, na programa√ß√£o √© poss√≠vel trabalhar com arrays tridimensionais ou maiores. Um array tridimensional pode ser visto como uma cole√ß√£o de matrizes. Para acessar um elemento, utilizamos um conjunto de tr√™s √≠ndices: `matriz3d[numero_da_matriz][linha][coluna]`.

<div align="center"><img src="https://i.imgur.com/qI8qwAx.png" title="source: imgur.com" /></div>

No t√≥pico Arrays, estudamos a implementa√ß√£o de arrays unidimensionais (vetores) e bidimensionais (matrizes). No t√≥pico Collections, aprendemos tamb√©m sobre arrays din√¢micos, ou seja, estruturas semelhantes a arrays, por√©m sem tamanho fixo, que podem crescer ou diminuir conforme a necessidade.

<br />

<h2>3. HashMap</h2> 



**HashMap** foi a segunda estrutura de dados estudada no t√≥pico **Collections**, durante a abordagem da cole√ß√£o **Set**. Um **HashMap** √© uma estrutura baseada em pares do tipo **chave-valor**, onde cada valor √© associado a uma chave √∫nica. Os elementos s√£o organizados com base no **hash code** gerado a partir da chave.

Ao adicionar um elemento, o HashMap calcula automaticamente um c√≥digo hash (por meio de uma fun√ß√£o de dispers√£o) para a chave fornecida. Esse c√≥digo determina a posi√ß√£o onde o valor ser√° armazenado na tabela de forma eficiente. Como esse c√°lculo depende do conte√∫do da chave, a posi√ß√£o final do par chave-valor pode parecer aleat√≥ria na estrutura interna, mas √© estrategicamente definida para otimizar o acesso.

Essa organiza√ß√£o torna o **HashMap** muito eficiente para opera√ß√µes de busca, inser√ß√£o e remo√ß√£o, quando realizadas por chave.

<div align="center"><img src="https://i.imgur.com/xSBwPjD.png" title="source: imgur.com" /></div>

<br />

<h2>4. Fila</h2>



A **Fila** √© uma estrutura de dados do tipo **FIFO** (*First-In, First-Out*), ou seja, **o primeiro elemento que entra √© o primeiro a sair**. A ideia central √© simples: s√≥ √© poss√≠vel **inserir um novo elemento no final da fila** e **remover um elemento do in√≠cio**. Essa l√≥gica √© semelhante √†s filas que enfrentamos no dia a dia ‚Äî a primeira pessoa a chegar √© a primeira a ser atendida.

<div align="center"><img src="https://i.imgur.com/h43C5MC.png" title="source: imgur.com" /></div>

Na imagem acima, observamos que a fila permite manipula√ß√£o nas duas extremidades: **inser√ß√µes** ocorrem na **cauda** (fim da fila) e **remo√ß√µes** ocorrem na **frente** (in√≠cio da fila).

<br />

<h3>4.1. A Collection Queue</h3>



Para implementarmos a estrutura de dados Fila em Java, utilizamos a Collection **Queue**, que representa uma **lista ordenada de elementos**, seguindo rigorosamente o princ√≠pio **FIFO**. Elementos s√£o adicionados no final da lista e removidos do in√≠cio.

**Sintaxe:**

```java
Queue<T> fila = new LinkedList<T>();
```

O construtor acima cria um objeto da classe **LinkedList** vazio. O item `<T>` representa um **tipo gen√©rico** em Java (Java Generics), permitindo definir o tipo de objeto que ser√° armazenado na fila. Esse tipo deve obrigatoriamente ser uma **classe** ‚Äî podendo ser uma **classe wrapper** (como `Integer`, `Double`, `String`) ou uma **classe personalizada** criada pela pessoa desenvolvedora.

<br />

<h3>4.2. Por qu√™ utilizamos a Classe LinkedList?</h3>



A **classe LinkedList** implementa uma estrutura chamada **lista duplamente encadeada**, formada por n√≥s (elementos) que armazenam:

 - o dado em si;
 - um ponteiro para o **n√≥ anterior**;
 - um ponteiro para o **pr√≥ximo n√≥** da lista.

 > Em programa√ß√£o, um **ponteiro** √© uma vari√°vel especial que **armazena o endere√ßo de mem√≥ria** de outra vari√°vel. Ou seja, um ponteiro **aponta para** a localiza√ß√£o de um dado na mem√≥ria, em vez de armazenar diretamente o valor desse dado.
 >
 > Embora o Java **n√£o utilize ponteiros de forma expl√≠cita**, como ocorre em linguagens como C ou C++, o conceito de **refer√™ncia** ‚Äî que funciona como uma forma segura e controlada de ponteiro ‚Äî est√° presente e √© essencial para o funcionamento da linguagem.
 >
 > Ao criar um objeto em Java, ele √© alocado na **heap** (√°rea de mem√≥ria din√¢mica), e a vari√°vel correspondente armazena uma **refer√™ncia** para esse objeto ‚Äî ou seja, um identificador gerenciado pela **JVM** (Java Virtual Machine) que indica onde o objeto est√° localizado na mem√≥ria.

 Al√©m disso, existe um ponteiro chamado **HEAD**, que aponta para o **primeiro elemento da lista**. Se a lista estiver vazia, o HEAD apontar√° para `null`.

 <div align="center"><img src="https://i.imgur.com/s67yOIi.png" title="source: imgur.com" /></div>

 Na imagem acima, vemos que o ponteiro **HEAD** indica o in√≠cio da lista. Cada elemento da lista conhece o seu antecessor e o seu sucessor. O √∫ltimo elemento da lista aponta para `null`, indicando que n√£o h√° elementos posteriores.

Essa estrutura permite que a **LinkedList** realize inser√ß√µes e remo√ß√µes com efici√™ncia nas extremidades, o que a torna ideal para a implementa√ß√£o da estrutura de dados Fila.

<br />

<h3>4.3. Principais M√©todos da Classe Queue</h3>



Na tabela abaixo, listamos os principais M√©todos para trabalharmos com a Collection **Queue**:

**‚úÖ - Tabela - M√©todos da Classe Queue**

| M√©todo               | Descri√ß√£o                                                    |
| -------------------- | ------------------------------------------------------------ |
| `add(elemento)`      | Adiciona um elemento ao final da fila.                       |
| `size()`             | Retorna o n√∫mero total de elementos na fila.                 |
| `clear()`            | Remove todos os elementos da fila.                           |
| `remove()`           | Remove e retorna o primeiro elemento da fila.                |
| `isEmpty()`          | Verifica se a fila est√° vazia. Retorna `true` se estiver vazia, caso contr√°rio, `false`. |
| `contains(elemento)` | Verifica se a fila cont√©m o elemento especificado.           |
| `peek()`             | Retorna, **sem remover**, o primeiro elemento da fila, ou `null` se estiver vazia. |
| `poll()`             | Retorna **e remove** o primeiro elemento da fila, ou `null` se estiver vazia. |

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html" target="_blank"><b>Artigo: Java Tutorials: Collection Queue</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html" target="_blank"><b>Documenta√ß√£o: Collection Queue</b></a></div>

<br />

Vamos construir uma aplica√ß√£o simples de **chamada de senhas em um painel de atendimento**, utilizando a **Collection `Queue`** para simular o funcionamento da fila de espera. A estrutura armazenar√° uma lista de n√∫meros inteiros representando as senhas a serem chamadas.

Esses n√∫meros ser√£o objetos da **classe wrapper `Integer`**, uma vez que as Collections em Java **n√£o aceitam tipos primitivos**, como `int`. Em seguida, realizaremos alguns testes pr√°ticos com os principais m√©todos da interface `Queue`,  para manipular e exibir as senhas em ordem de atendimento.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 01 - Fila

```java
package exemplos_estruturas_dados;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;

public class Exemplo01 {

	public static void main(String[] args) {

		Queue<Integer> fila = new LinkedList<Integer>();

		System.out.println("========== SISTEMA DE CHAMADA DE SENHAS ==========\n");

		// Adiciona senhas de 0 a 10
		System.out.println("[1] Adicionando senhas de 0 a 10 na fila...");
		for (int i = 0; i <= 10; i++) {
			fila.add(i);
		}
		System.out.println("Fila atual: " + fila);

		// Remove o primeiro elemento
		System.out.println("\n[2] Chamando a primeira senha (remove): " + fila.remove());
		System.out.println("Fila ap√≥s a remo√ß√£o: " + fila);

		// Adiciona o n√∫mero 11
		System.out.println("\n[3] Adicionando nova senha (11): " + fila.add(11));
		System.out.println("Fila atualizada: " + fila);

		// Exibe o primeiro elemento (sem remover)
		System.out.println("\n[4] Pr√≥xima senha a ser chamada (peek): " + fila.peek());

		// Exibe o tamanho da fila
		System.out.println("\n[5] Quantidade de senhas na fila: " + fila.size());

		// Verifica se a senha 4 est√° na fila
		System.out.println("\n[6] A senha 4 est√° na fila? " + fila.contains(4));

		// Exibe e remove o primeiro elemento
		System.out.println("\n[7] Chamando e removendo a pr√≥xima senha (poll): " + fila.poll());
		System.out.println("Fila atual: " + fila);

		// Itera√ß√£o sobre os elementos restantes
		System.out.println("\n[8] Senhas restantes na fila (iterando):");
		Iterator<Integer> iterator = fila.iterator();
		while (iterator.hasNext()) {
			System.out.println("‚Üí Senha: " + iterator.next());
		}

		// Limpa a fila
		System.out.println("\n[9] Limpando todas as senhas da fila...");
		fila.clear();

		// Verifica se a fila est√° vazia
		System.out.println("[10] A fila est√° vazia? " + fila.isEmpty());

		System.out.println("\n==================================================");
		System.out.println("Sistema finalizado.");
	}
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
========== SISTEMA DE CHAMADA DE SENHAS ==========

[1] Adicionando senhas de 0 a 10 na fila...
Fila atual: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

[2] Chamando a primeira senha (remove): 0
Fila ap√≥s a remo√ß√£o: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

[3] Adicionando nova senha (11): true
Fila atualizada: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]

[4] Pr√≥xima senha a ser chamada (peek): 1

[5] Quantidade de senhas na fila: 11

[6] A senha 4 est√° na fila? true

[7] Chamando e removendo a pr√≥xima senha (poll): 1
Fila atual: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]

[8] Senhas restantes na fila (iterando):
‚Üí Senha: 2
‚Üí Senha: 3
‚Üí Senha: 4
‚Üí Senha: 5
‚Üí Senha: 6
‚Üí Senha: 7
‚Üí Senha: 8
‚Üí Senha: 9
‚Üí Senha: 10
‚Üí Senha: 11

[9] Limpando todas as senhas da fila...
[10] A fila est√° vazia? true

==================================================
Sistema finalizado.
```

Confira os coment√°rios inseridos no c√≥digo para compreender o funcionamento do programa. Eles explicam, passo a passo, a l√≥gica aplicada na manipula√ß√£o da fila, desde a adi√ß√£o de n√∫meros inteiros na estrutura at√© as opera√ß√µes de remo√ß√£o e consulta dos elementos.

<br />

<h2>5. Pilha</h2>



Uma **Pilha** √© uma estrutura de dados do tipo **LIFO** ‚Äî *‚ÄúLast In, First Out‚Äù* (√∫ltimo a entrar, primeiro a sair). Isso significa que o √∫ltimo elemento inserido na pilha ser√° o primeiro a ser retirado. A caracter√≠stica fundamental da pilha √© que as opera√ß√µes de inser√ß√£o e remo√ß√£o acontecem apenas no **topo** da estrutura.

O nome *‚Äúpilha‚Äù* vem da analogia com objetos do cotidiano, como uma pilha de pratos: o √∫ltimo prato colocado em cima √© o primeiro a ser retirado.

<div align="center"><img src="https://i.imgur.com/y8maSln.png" title="source: imgur.com" /></div>

Observe na imagem acima que as duas opera√ß√µes b√°sicas em uma pilha s√£o:

- **PUSH** (empilhar): insere um elemento no topo da pilha.
- **POP** (desempilhar): remove o elemento do topo da pilha e o retorna (ou n√£o).

<br />

<h3>5.1. A Collection Deque como Pilha</h3>



Para implementarmos a estrutura de dados **Pilha** em Java, utilizamos a Collection **Deque** (*Double-Ended Queue* - Fila dupla), que permite a manipula√ß√£o de elementos em ambas as extremidades da estrutura. Ao usarmos `Deque` como uma pilha, seguimos o princ√≠pio **LIFO (Last-In, First-Out)**, onde **o √∫ltimo elemento inserido √© o primeiro a ser removido**.

**Sintaxe:**

```java
Deque<T> pilha = new ArrayDeque<T>();
```

O construtor acima cria um objeto da classe **ArrayDeque** vazio. O item `<T>` representa um **tipo gen√©rico** em Java (Java Generics), permitindo definir o tipo de objeto que ser√° armazenado na pilha. Esse tipo deve obrigatoriamente ser uma **classe** ‚Äî podendo ser uma **classe wrapper** (como `Integer`, `Double`, `String`) ou uma **classe personalizada** criada pela pessoa desenvolvedora.

> [!TIP]
>
> Embora o nome da classe seja `ArrayDeque`, quando utilizada com os m√©todos adequados (`push`, `pop`, `peek`), ela se comporta como uma pilha moderna e eficiente.

<br />

<h3>4.2. Por que utilizar a classe ArrayDeque?</h3>



A classe **ArrayDeque** √© uma alternativa moderna √† antiga classe `Stack`, que √© considerada **legacy** (obsoleta para novos projetos). Ela √© implementada internamente com um **array redimension√°vel**, oferecendo desempenho superior na maioria dos cen√°rios.

Diferente da `Stack`, que herda de `Vector` (uma estrutura sincronizada e mais pesada), o `ArrayDeque` **n√£o √© sincronizado** e, portanto, √© **mais leve e r√°pido** em contextos de execu√ß√£o `single-thread`, como a Linguagem Java.

> [!NOTE]
>
> **Single-thread** significa que o programa roda **uma tarefa por vez**, em **uma √∫nica linha de execu√ß√£o**.
>
> **Multi-thread** significa que o programa pode rodar **mais de uma tarefa ao mesmo tempo**, em **m√∫ltiplas linhas de execu√ß√£o (threads)**.

Al√©m disso, a `ArrayDeque` √© vers√°til: pode ser usada como **fila ou pilha**, dependendo dos m√©todos que escolhemos utilizar.

A cole√ß√£o **`ArrayDeque` n√£o oferece acesso por √≠ndice** como a cole√ß√£o `ArrayList`, pois ela **n√£o implementa a interface `List`**, mas sim a interface `Deque`. Portanto, o m√©todo **`get(index)` n√£o est√° dispon√≠vel diretamente no `ArrayDeque`**.

Caso seja necess√°rio acessar elementos por √≠ndice, √© preciso primeiro converter a estrutura para um array, utilizando o m√©todo **`toArray()`**, ou para uma lista, criando uma nova inst√¢ncia de **`ArrayList` a partir do** `deque` (`new ArrayList<>(deque)`). Vale lembrar que essas convers√µes criam uma c√≥pia dos elementos, o que pode impactar a efici√™ncia dependendo do uso.

> **Pensando em um exemplo do dia a dia: Stack vs ArrayDeque**
>
> - O `Stack` √© como **um cofre com chave**: toda vez que algu√©m vai colocar ou tirar algo, precisa abrir e fechar a chave (seguro, mas mais lento devido √† sincroniza√ß√£o).
> - O `ArrayDeque` √© como **uma gaveta aberta**: qualquer pessoa pode colocar ou tirar coisas rapidamente (r√°pido, mas perigoso se v√°rias pessoas tentarem mexer ao mesmo tempo ‚Äì `multi-thread`).
>
> üëâ Como a maioria dos programas Java roda em **single-thread**, o `ArrayDeque` geralmente apresenta **melhor desempenho** do que o `Stack`.

<br />

<h3>4.3. Principais M√©todos da Collection Deque (modo Pilha)</h3>



Na tabela abaixo, listamos os principais M√©todos para trabalharmos com a Collection **Deque**:

**‚úÖ - Tabela - M√©todos da Classe Deque**

| M√©todo               | Descri√ß√£o                                                    |
| -------------------- | ------------------------------------------------------------ |
| `push(elemento)`     | Adiciona um elemento no topo da pilha.                       |
| `pop()`              | Remove e retorna o elemento do topo da pilha.                |
| `peek()`             | Retorna, **sem remover**, o elemento do topo da pilha.       |
| `size()`             | Retorna o n√∫mero total de elementos na pilha.                |
| `clear()`            | Remove todos os elementos da pilha.                          |
| `isEmpty()`          | Verifica se a pilha est√° vazia.                              |
| `contains(elemento)` | Verifica se a pilha cont√©m o elemento especificado.          |
| `toArray()`          | Retorna um array com todos os elementos da pilha (√∫til para itera√ß√£o). |

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/deque.html" target="_blank"><b>Artigo: Java Tutorials: Collection Deque</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html" target="_blank"><b>Documenta√ß√£o: Collection Deque</b></a></div>

<br />

Vamos construir uma aplica√ß√£o simples de **controle de pratos empilhados**, utilizando a **Collection `Deque`** para simular o funcionamento de uma pilha, onde o √∫ltimo prato adicionado ser√° o primeiro a ser retirado (LIFO).

A estrutura armazenar√° uma lista de elementos do tipo `String`, representando os nomes dos pratos empilhados.

Em seguida, realizaremos alguns testes pr√°ticos com os principais m√©todos da classe `Stack`, para manipular e exibir os pratos conforme a ordem correta da pilha.

<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 02 - Pilha

```java
package exemplos_estruturas_dados;

import java.util.ArrayDeque;
import java.util.Deque;

public class Exemplo02 {

    public static void main(String[] args) {

        // Cria√ß√£o de uma pilha usando ArrayDeque
        Deque<String> pilha = new ArrayDeque<>();

        // Vari√°vel para identificar a posi√ß√£o do elemento na pilha
        int contador = 0;
        
        // Adiciona elementos no topo da pilha
        pilha.push("Prato Verde");
        pilha.push("Prato Azul");
        pilha.push("Prato Branco");
        pilha.push("Prato Amarelo");
        pilha.push("Prato Vermelho");

        // Exibe os elementos da pilha do topo para a base
        System.out.println("\nElementos da Pilha (topo ‚Üí base):");
        contador = pilha.size();
        
        for (String prato : pilha) {
        	System.out.printf("[%d] %s%n", contador, prato);
        	contador --;
        }
       
        // Remove o elemento do topo da pilha
        System.out.println("\nRetirar elemento: " + pilha.pop());

        // Exibe os elementos da pilha ap√≥s remo√ß√£o
        System.out.println("\nElementos da Pilha (topo ‚Üí base):");
        contador = pilha.size();
        
        for (String prato : pilha) {
        	System.out.printf("[%d] %s%n", contador, prato);
        	contador --;
        }

        // Remove mais um elemento do topo da pilha
        System.out.println("\nRetirar elemento: " + pilha.pop());

        // Exibe os elementos da pilha ap√≥s nova remo√ß√£o
        System.out.println("\nElementos da Pilha (topo ‚Üí base):");
        contador = pilha.size();
        
        for (String prato : pilha) {
        	System.out.printf("[%d] %s%n", contador, prato);
        	contador --;
        }

        // Mostra o elemento atual no topo da pilha sem remov√™-lo
        System.out.println("\nElemento no topo da Pilha: " + pilha.peek());

        // Adiciona um novo elemento ao topo da pilha
        pilha.push("Prato Roxo");

        // Informa que um novo prato foi adicionado
        System.out.println("\nAdicionar Elemento Prato Roxo");

        // Exibe a pilha atualizada ap√≥s adi√ß√£o
        System.out.println("\nPilha Atualizada (topo ‚Üí base):");
        contador = pilha.size();
        
        for (String prato : pilha) {
        	System.out.printf("[%d] %s%n", contador, prato);
        	contador --;
        }
        
        // Exibe o tamanho atual da pilha
        System.out.println("\nTamanho da Pilha: " + pilha.size());

        // Verifica se a pilha cont√©m um elemento espec√≠fico
        System.out.println("\nO Elemento Prato Verde existe na Pilha? " + pilha.contains("Prato Verde"));

        // Exibe todos os elementos da pilha usando uma nova itera√ß√£o
        System.out.println("\nExibir todos os Elementos da Pilha por Itera√ß√£o (topo ‚Üí base):");
        contador = pilha.size();
        
        for (String prato : pilha) {
        	System.out.printf("[%d] %s%n", contador, prato);
        	contador --;
        }

        // Limpa todos os elementos da pilha
        pilha.clear();

        // Verifica se a pilha est√° vazia
        System.out.println("\nA Pilha est√° vazia? " + pilha.isEmpty());
    }
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash

Elementos da Pilha (topo ‚Üí base):
[5] Prato Vermelho
[4] Prato Amarelo
[3] Prato Branco
[2] Prato Azul
[1] Prato Verde

Retirar elemento: Prato Vermelho

Elementos da Pilha (topo ‚Üí base):
[4] Prato Amarelo
[3] Prato Branco
[2] Prato Azul
[1] Prato Verde

Retirar elemento: Prato Amarelo

Elementos da Pilha (topo ‚Üí base):
[3] Prato Branco
[2] Prato Azul
[1] Prato Verde

Elemento no topo da Pilha: Prato Branco

Adicionar Elemento Prato Roxo

Pilha Atualizada (topo ‚Üí base):
[4] Prato Roxo
[3] Prato Branco
[2] Prato Azul
[1] Prato Verde

Tamanho da Pilha: 4

O Elemento Prato Verde existe na Pilha? true

Exibir todos os Elementos da Pilha por Itera√ß√£o (topo ‚Üí base):
[4] Prato Roxo
[3] Prato Branco
[2] Prato Azul
[1] Prato Verde

A Pilha est√° vazia? true
```

Confira os coment√°rios inseridos no c√≥digo para compreender o funcionamento do programa. Eles explicam, passo a passo, a l√≥gica aplicada na manipula√ß√£o da pilha, desde a adi√ß√£o de n√∫meros inteiros na estrutura at√© as opera√ß√µes de remo√ß√£o e consulta dos elementos.

<br />

<h2>6. Outras Estruturas de dados</h2>



Neste t√≥pico, faremos uma breve introdu√ß√£o a outras estruturas de dados amplamente utilizadas, especialmente em pesquisas e manipula√ß√£o avan√ßada de informa√ß√µes. O objetivo √© fornecer um overview para que voc√™ identifique onde aprofundar seus estudos, com refer√™ncias que poder√£o complementar seu aprendizado.

<br />

> [!NOTE]
>
> **ALERTA DE BSM** 
>
> *Mantenha a Orienta√ß√£o ao Futuro em rela√ß√£o √†s Estruturas de Dados!*
>
> Este tema √© vasto e essencial para o desenvolvimento profissional. Embora seja amplamente utilizado no cotidiano dos desenvolvedores, dominar estruturas de dados exige tempo, pr√°tica constante e muita persist√™ncia.

<br />

<h3>6.1 Lista Encadeada (Linked List)</h3>



A **Lista Encadeada** √© uma estrutura sequencial composta por uma s√©rie de elementos organizados linearmente, onde cada elemento (ou n√≥) cont√©m dados e um ponteiro para o pr√≥ximo n√≥ na sequ√™ncia. Por isso, o acesso aos elementos √© sequencial ‚Äî o acesso aleat√≥rio n√£o √© poss√≠vel diretamente.

O primeiro elemento da lista √© apontado por um ponteiro chamado **Head** (cabe√ßa), enquanto o √∫ltimo n√≥ √© conhecido como **Tail** (cauda).

Existem duas formas principais de implementar listas encadeadas:

- **Lista Encadeada Simples (Singly Linked List):** Os elementos s√£o percorridos em uma √∫nica dire√ß√£o, utilizando um ponteiro chamado **next** que aponta para o pr√≥ximo n√≥ da lista.

<div align="center"><img src="https://i.imgur.com/75ATOqR.png" title="source: imgur.com" /></div>

- **Lista Duplamente Encadeada (Doubly Linked List):** Os elementos possuem dois ponteiros: um para o pr√≥ximo n√≥ (**next**) e outro para o n√≥ anterior (**prev**), permitindo a navega√ß√£o em ambas as dire√ß√µes, para frente e para tr√°s.

 <div align="center"><img src="https://i.imgur.com/s67yOIi.png" title="source: imgur.com" /></div>

Essa estrutura torna as opera√ß√µes de inser√ß√£o e remo√ß√£o mais eficientes, pois para adicionar ou excluir um n√≥, basta ajustar os ponteiros dos n√≥s vizinhos, sem a necessidade de mover todos os elementos.

O uso t√≠pico de listas encadeadas ocorre quando precisamos:

- Adicionar ou remover elementos no in√≠cio ou no fim da lista;
- Acessar e percorrer os elementos sequencialmente;
- Implementar outras estruturas, como pilhas e filas, com efici√™ncia.

<br />

<h3>6.2. √Årvore (Tree)</h3>



Uma **√Årvore** √© uma estrutura hier√°rquica em que os dados s√£o organizados em n√≠veis, com cada elemento (n√≥) podendo ter um ou mais ‚Äúfilhos‚Äù. Diferentemente da lista encadeada, que √© linear, a √°rvore permite relacionamentos ramificados entre os dados.

Diversos tipos de √°rvores foram desenvolvidos para atender a necessidades espec√≠ficas, entre os mais comuns est√£o:

- √Årvore Bin√°ria de Pesquisa (Binary Search Tree ‚Äî BST)
- √Årvore Red-Black
- √Årvore Splay
- √Årvore AVL

√Årvores s√£o estruturas fundamentais na representa√ß√£o e manipula√ß√£o de dados hier√°rquicos, sendo amplamente utilizadas no desenvolvimento web. Por exemplo, a **DOM (Document Object Model)** de uma p√°gina HTML √© organizada como uma √°rvore, onde cada elemento HTML √© um n√≥ conectado a seus elementos filhos, permitindo a navega√ß√£o e altera√ß√£o din√¢mica da estrutura da p√°gina. 

<br />

<h4>6.2.1. √Årvores Bin√°rias de Busca</h4>



A √Årvore Bin√°ria de Pesquisa √© uma √°rvore bin√°ria onde os n√≥s s√£o organizados segundo uma ordem, garantindo que para cada n√≥, todos os elementos √† esquerda sejam menores e todos os elementos √† direita sejam maiores. Cada n√≥ cont√©m:

- Uma **chave (key)**, que representa o valor do n√≥;
- Um ponteiro para o n√≥ filho esquerdo (valores menores);
- Um ponteiro para o n√≥ filho direito (valores maiores);
- Um ponteiro para o n√≥ pai.

<div align="center"><img src="https://i.imgur.com/BsD6Z1f.png" title="source: imgur.com" /></div>

Essa estrutura √© amplamente usada para implementar mecanismos eficientes de busca, ordena√ß√£o e processamento de express√µes.

O estudo aprofundado das estruturas de dados √© fundamental para qualquer profissional de tecnologia. Dominar essas estruturas amplia a capacidade de resolver problemas complexos com efici√™ncia, al√©m de otimizar o desempenho das aplica√ß√µes.

Por isso, √© essencial manter uma pr√°tica cont√≠nua, explorando tanto conceitos te√≥ricos quanto implementa√ß√µes pr√°ticas, ampliando o conhecimento sobre algoritmos e suas aplica√ß√µes. A familiaridade com diversas estruturas de dados possibilita escolher a ferramenta ideal para cada problema, tornando seu c√≥digo mais robusto e eficiente. Portanto, dedique-se ao aprendizado progressivo dessas bases essenciais para a carreira em desenvolvimento de software e ci√™ncia da computa√ß√£o.

<br />

------

## üîë**Pontos chave:**

1. **Estruturas de Dados** s√£o formas de organizar e armazenar informa√ß√µes em computadores, com o objetivo de realizar opera√ß√µes com maior efici√™ncia, como inser√ß√£o, remo√ß√£o, ordena√ß√£o e busca.
2. O uso de estruturas de dados √© fundamental no desenvolvimento de sistemas, algoritmos e aplica√ß√µes eficientes, sendo aplicadas desde tarefas simples, como armazenar uma lista de nomes, at√© estruturas complexas de bancos de dados ou intelig√™ncia artificial.
3. Um dos principais benef√≠cios √© a **reutiliza√ß√£o**: ao entender e implementar uma estrutura corretamente, √© poss√≠vel aplic√°-la em diferentes contextos e projetos.
4. **Array** √© uma estrutura baseada em **√≠ndice num√©rico**, de **tamanho fixo** e que armazena **elementos de um mesmo tipo**. Existem arrays unidimensionais (vetores), bidimensionais (matrizes) e multidimensionais.
5. **HashMap** √© uma estrutura do tipo **chave-valor**, onde os elementos s√£o organizados com base em um **hash code** gerado a partir da chave. Proporciona opera√ß√µes de inser√ß√£o, busca e remo√ß√£o eficientes, sendo amplamente utilizado para mapeamentos e associa√ß√µes din√¢micas de dados.
6. **Fila (Queue)** segue o princ√≠pio **FIFO (First In, First Out)**: o primeiro elemento inserido √© o primeiro a ser removido. Em Java, a `Queue` pode ser implementada com `LinkedList`, aproveitando sua estrutura de lista duplamente encadeada.
7. **Pilha (Stack)** adota o princ√≠pio **LIFO (Last In, First Out)**: o √∫ltimo elemento inserido √© o primeiro a ser removido. Ideal para resolver problemas onde √© necess√°rio reverter ordens ou manter controle de hist√≥rico (ex: navega√ß√£o, desfazer a√ß√µes, chamadas de m√©todos).
8. A pilha foi implementada utilizando a interface **`Deque`**, por meio da classe **`ArrayDeque`**, que oferece uma alternativa moderna e eficiente √† antiga classe `Stack`, permitindo opera√ß√µes de inser√ß√£o e remo√ß√£o no topo com alto desempenho.
9. **Listas Encadeadas (Linked Lists)** armazenam elementos de forma sequencial, onde cada elemento aponta para o pr√≥ximo (ou tamb√©m para o anterior, no caso das listas duplamente encadeadas). Permitem inser√ß√µes e remo√ß√µes eficientes em posi√ß√µes espec√≠ficas, mesmo sem acesso direto via √≠ndice.
10. **√Årvores (Trees)** s√£o estruturas hier√°rquicas em que cada elemento pode ter v√°rios filhos. √Årvores s√£o amplamente utilizadas em algoritmos de busca, estrutura√ß√£o de dados hier√°rquicos, express√µes l√≥gicas e interfaces gr√°ficas. Um exemplo real √© a **DOM (Document Object Model)** do HTML, que √© estruturada como uma √°rvore.
11. **√Årvores Bin√°rias de Busca (BSTs)** garantem uma ordena√ß√£o entre os n√≥s: os valores menores ficam √† esquerda, e os maiores √† direita. Esse tipo de √°rvore √© ideal para opera√ß√µes de busca r√°pida e ordena√ß√£o din√¢mica.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
