<h1>Programa√ß√£o Orientada a Objetos - Parte 01</h1>
<br />

<h2>Classes, Objetos e Encapsulamento</h2>



Em geral, quanto maior o software, mais complexo se torna o seu desenvolvimento, devido √† quantidade de partes que o comp√µem e ao relacionamento entre essas partes.

Uma das principais raz√µes para dificuldades na implementa√ß√£o, testes e manuten√ß√£o de sistemas est√° na forma como eles s√£o projetados. Quando se adota uma l√≥gica de projeto focada exclusivamente nas funcionalidades, o sistema √© estruturado com base apenas no que ele **faz**, e n√£o **em como ou por que ele funciona daquela maneira no mundo real**. Nessa abordagem funcional, muitas vezes n√£o h√° uma preocupa√ß√£o em representar os elementos do dom√≠nio de forma pr√≥xima √† realidade, o que pode comprometer a flexibilidade e a evolu√ß√£o do sistema ao longo do tempo.

O problema √© que, com o passar do tempo, os processos e procedimentos dentro das empresas mudam ‚Äî e, inevitavelmente, o software precisa acompanhar essas mudan√ßas. Se o sistema foi constru√≠do apenas com base em funcionalidades espec√≠ficas (como *"emitir relat√≥rio"*, *"calcular imposto"*, *"gerar pedido"*), qualquer altera√ß√£o nos processos pode exigir uma reestrutura√ß√£o significativa do c√≥digo, ou at√© a sua reescrita completa. A menos, √© claro, que se opte por remendos improvisados, conhecidos no jarg√£o dos desenvolvedores como POG ‚Äî ‚ÄúPrograma√ß√£o Orientada a Gambiarras‚Äù.

Diante dessas dificuldades, alguns desenvolvedores passaram a refletir:

**"Se as fun√ß√µes de uma empresa e de um sistema mudam com frequ√™ncia, ent√£o n√£o posso us√°-las como base estrutural para minha aplica√ß√£o."**

Essa foi a **primeira grande conclus√£o**. Em seguida, surgiu a **pergunta fundamental**:

**"O que √© que, em uma empresa e nos seus processos, raramente muda?"**

A resposta est√° nas **coisas** ‚Äî nos **elementos** que fazem parte do dom√≠nio e que representam entidades tang√≠veis ou conceituais com estabilidade relativa. S√£o os **objetos**: produtos, clientes, funcion√°rios, departamentos, documentos, formul√°rios, equipamentos, entre outros.

Esses elementos costumam permanecer constantes ao longo do tempo, mesmo quando os processos mudam. Com base nisso, surgiu uma nova abordagem:

**"Vamos estruturar o software com foco nos objetos envolvidos nos processos, e n√£o apenas nos processos em si."**

A partir dessa abordagem conceitual, que prioriza a modelagem baseada nos elementos do mundo real, surgiu a **Programa√ß√£o Orientada a Objetos (POO)**.

<br />

<h2>1. Programa√ß√£o Orientada a Objetos (POO)</h2>



A **Programa√ß√£o Orientada a Objetos** (POO) √© um paradigma de programa√ß√£o que prop√µe a modelagem de sistemas com base nos objetos do mundo real ‚Äî sejam eles **concretos** (como uma *Pessoa*, *Carro*, *Produto*) ou **abstratos** (como *Contrato*, *Transa√ß√£o*, *Sess√£o*), favorecendo a modulariza√ß√£o, o reuso e a manuten√ß√£o do c√≥digo.

A principal ideia √© simular no ambiente computacional a forma como os objetos se comportam e interagem no mundo real:

- No mundo real, objetos interagem entre si para realizar tarefas.
- Em um sistema orientado a objetos, os programas s√£o compostos por objetos que se comunicam atrav√©s de mensagens (m√©todos), manipulando seus pr√≥prios dados (atributos) e executando comportamentos (a√ß√µes).

> **Abstrato**, segundo o dicion√°rio:
>
> *Algo que n√£o √© concreto; que resulta da abstra√ß√£o. Opera unicamente com ideias, com associa√ß√µes de ideias, n√£o diretamente com a realidade sens√≠vel. Possui um alto grau de generaliza√ß√£o.*

Com base na **teoria geral dos sistemas**, um sistema pode ser definido como **um conjunto de entidades que interagem entre si com o objetivo de produzir um resultado comum**. A POO parte exatamente dessa ideia: cada **objeto do sistema** representa uma entidade com responsabilidades bem definidas, contribuindo para o funcionamento global da aplica√ß√£o.

<br />

<h2>2. Objetos</h2>



No mundo real, objetos podem ser **animados ou inanimados**, mas **todos eles possuem caracter√≠sticas que podem ser classificadas como atributos e comportamentos**. Esses elementos s√£o fundamentais para representar objetos de forma estruturada em um sistema orientado a objetos.

Na imagem abaixo, temos alguns exemplos de objetos representados de maneira gen√©rica:

<div align="center"><img src="https://i.imgur.com/MJIvLag.png" title="source: imgur.com" /></div>

Observe que os objetos apresentados ‚Äî *Animal*, *Pessoa*, *Produto* e *Conta* ‚Äî s√£o definidos de forma abstrata, ou seja, **sem detalhamento espec√≠fico**.

Vamos analisar o objeto **Conta**. Sabemos que se trata de uma **conta banc√°ria**, por√©m, n√£o foram informados detalhes como:

1. Qual √© o n√∫mero da conta?
2. Qual √© o n√∫mero da ag√™ncia banc√°ria?
3. Quem √© o titular da conta?
4. Qual √© o tipo da conta?
5. Qual √© o saldo dispon√≠vel?

Neste momento da modelagem orientada a objetos, o foco est√° na **identifica√ß√£o dos objetos gen√©ricos**, ou seja, em uma **abstra√ß√£o inicial** do sistema. A ideia √© representar **conceitos amplos** que servir√£o como base para a constru√ß√£o de entidades mais espec√≠ficas posteriormente. A **generaliza√ß√£o** facilita o entendimento e a estrutura√ß√£o do sistema, permitindo uma transi√ß√£o gradual do mundo real para o modelo computacional.

<br />

<h3>2.1. Vantagens da modelagem orientada a objetos</h3>



Modelar um sistema com base em objetos proporciona diversas vantagens:

- **Facilidade na concep√ß√£o do sistema:** a transi√ß√£o do mundo real para o modelo orientado a objetos √© mais natural e intuitiva.
- **Facilidade na compreens√£o do modelo:** por refletir a realidade, o modelo pode ser entendido facilmente por pessoas que conhecem o dom√≠nio do problema, mesmo que n√£o dominem a tecnologia.
- **Facilidade no gerenciamento e manuten√ß√£o:** objetos representam entidades relativamente est√°veis ao longo do tempo. Em geral, **os objetos permanecem os mesmos**, e as mudan√ßas ocorrem nas formas como eles interagem. Isso reduz o impacto das altera√ß√µes no c√≥digo.

<br />

<h3>2.2. O que s√£o Objetos em Programa√ß√£o?</h3>



Em programa√ß√£o ‚Äî e tamb√©m no mundo real ‚Äî um **objeto** √© uma **entidade que possui identidade, estado e comportamento**.

- **Identidade:** √© o nome ou a refer√™ncia que identifica o objeto.
- **Estado:** √© representado pelos **atributos** (tamb√©m chamados de campos ou vari√°veis de inst√¢ncia).
- **Comportamento:** √© representado pelos **m√©todos**, ou seja, as a√ß√µes que o objeto pode executar.

Na linguagem Java, por exemplo, um objeto √© uma inst√¢ncia de uma **classe**, que define sua estrutura (atributos) e seu comportamento (m√©todos). Al√©m disso, **um atributo pode ser outro objeto**, o que permite composi√ß√µes mais complexas ‚Äî isso √© conhecido como **composi√ß√£o de objetos**, e √© uma das bases do reuso e modularidade no paradigma orientado a objetos.

**Em resumo:**

> Um **objeto** √© como uma **estrutura de dados evolu√≠da**, que **combina dados (atributos) com comportamentos (m√©todos)** em uma √∫nica entidade.

Essa abordagem √© o que torna a Programa√ß√£o Orientada a Objetos uma das mais utilizadas no desenvolvimento de sistemas modernos, sendo amplamente suportada por linguagens como Java, C++, C#, Python, entre outras.

<br />

<h2>3. Classes</h2>



No paradigma da Programa√ß√£o Orientada a Objetos (POO), **uma classe √© uma estrutura que define um novo tipo de dado**, combinando atributos (dados) e m√©todos (comportamentos). A classe funciona como um **molde** ou **projeto** a partir do qual objetos podem ser criados.

Uma analogia comum e eficaz √© comparar **a classe com a planta de uma casa**, e **o objeto com a casa constru√≠da a partir dessa planta**:

<div align="center"><img src="https://i.imgur.com/0zF5E7u.png" title="source: imgur.com" /></div>

Perceba que a **classe √© um conceito abstrato**, que se torna **concreto** com a cria√ß√£o de objetos. Esse processo de cria√ß√£o de um objeto a partir de uma classe √© chamado de **instancia√ß√£o**.

<div align="center"><img src="https://i.imgur.com/Q40v71w.png" title="source: imgur.com" /></div>

Na imagem acima, vemos que assim como uma planta pode ser usada para construir v√°rias casas, uma classe pode ser usada para instanciar diversos objetos:

<br />

<h3>3.1.Estrutura de uma Classe</h3>



Toda classe √© composta, essencialmente, por dois elementos principais:

- **Atributos** ‚Äì respons√°veis por representar as caracter√≠sticas do objeto.
- **M√©todos** ‚Äì respons√°veis por representar os comportamentos (a√ß√µes) que o objeto pode realizar ou sofrer.

Vamos observar um exemplo pr√°tico para ilustrar:

<div align="center"><img src="https://i.imgur.com/UT537p6.png" title="source: imgur.com" /></div>

Neste exemplo, definimos a classe **Conta** com os **atributos**:

- `n√∫mero`
- `ag√™ncia`
- `titular`
- `tipo` 
- `saldo`. 

Com essas informa√ß√µes, conseguimos detalhar a conta e responder perguntas como:

- Qual √© o n√∫mero da conta?
- Qual √© o tipo da conta?
- Quem √© o titular?

Cada **classe representa um conceito** (como `Conta`, `Pessoa`, `Animal`, `Produto`), e **cada conceito √© descrito por seus atributos** ‚Äî que, em geral, s√£o **substantivos**.

J√° os **m√©todos** descrevem as **a√ß√µes que um objeto pode executar ou sofrer** ‚Äî como `sacar`, `depositar`, `transferir`, entre outros. Essas a√ß√µes, por conven√ß√£o, s√£o representadas por **verbos**, como demonstrado a seguir:

<div align="center"><img src="https://i.imgur.com/ejIJiIy.png" title="source: imgur.com" /></div>

Observe que todos os m√©todos definidos atuar√£o diretamente sobre o objeto `Conta`, ou seja, incidem sobre os dados e comportamentos da inst√¢ncia criada a partir da classe.

<br />

<h3>3.2.Objetos e Inst√¢ncias</h3>



Na computa√ß√£o, um **sistema orientado a objetos** √© formado por **objetos que interagem entre si** por meio da **troca de mensagens**, ou seja, chamadas de m√©todos. Esses objetos s√£o **inst√¢ncias de classes**, e compartilham uma estrutura comum, mas possuem dados pr√≥prios.

- A **classe** √© uma **defini√ß√£o est√°tica**, um modelo.
- O **objeto** √© uma **entidade din√¢mica**, criada a partir da classe.
- Todos os objetos s√£o **inst√¢ncias de uma classe**, ou seja, s√£o a concretiza√ß√£o de um conceito.

**Exemplo Pr√°tico:** 

<div align="center"><img src="https://i.imgur.com/abOgmEY.png" title="source: imgur.com" /></div>

Neste exemplo:

- `Conta` √© a **classe** que define um modelo gen√©rico de conta banc√°ria.
- `Objeto01` e o `Objeto 02` s√£o **inst√¢ncias da classe Conta**, ou seja, **objetos concretos criados a partir desse modelo**.

Cada objeto possui seus pr√≥prios valores para os atributos definidos na classe `Conta`, mas compartilham os mesmos m√©todos e estrutura b√°sica.

<br />

<h3>3.3. Representa√ß√£o Gr√°fica</h3>



Na Programa√ß√£o Orientada a Objetos, a representa√ß√£o gr√°fica de uma **classe** √© feita por meio do **Diagrama de Classes**, um dos diagramas mais importantes da **UML (Unified Modeling Language)** ‚Äî a Linguagem de Modelagem Unificada. A UML √© um padr√£o amplamente adotado para a **visualiza√ß√£o, especifica√ß√£o, constru√ß√£o e documenta√ß√£o de sistemas orientados a objetos**.

Os **Diagramas de Classe** s√£o fundamentais na modelagem de sistemas orientados a objetos, pois:

- **Facilitam a comunica√ß√£o** entre analistas, desenvolvedores e demais stakeholders, promovendo um entendimento comum da estrutura e do funcionamento do sistema.
- **Apoiam a documenta√ß√£o t√©cnica**, servindo como uma representa√ß√£o visual clara e organizada das classes, atributos, m√©todos e seus relacionamentos.
- **Servem como refer√™ncia para a implementa√ß√£o**, especialmente em linguagens orientadas a objetos como Java, C#, Python, entre outras.
- **Tornam expl√≠cita a estrutura do sistema**, refletindo os princ√≠pios da Programa√ß√£o Orientada a Objetos e permitindo a an√°lise de depend√™ncias, hierarquias e responsabilidades entre os componentes.

Na imagem abaixo, temos o Diagrama de Classes da classe `Conta`:

```mermaid
classDiagram
class Conta {
 - numero : int
 - agencia : int
 - tipo : int
 - titular : String
 - saldo : float
 + int getNumero()
 + int getAgencia()
 + int getTipo()
 + String getTitular()
 + float getSaldo()
 + void setNumero(int numero)
 + void setAgencia(int agencia)
 + void setTipo(int tipo)
 + void setTitular(String titular)
 + void setSaldo(float saldo)
 + boolean sacar(float valor)
 + void depositar(float valor)
 + void visualizar()
}
```

O **Diagrama de Classes** √© organizado em tr√™s se√ß√µes principais:

<div align="center"><img src="https://i.imgur.com/KX6iOwP.png" title="source: imgur.com" /></div>

<br />

### ‚úÖ Estrutura do Diagrama de Classes

1. **Nome da Classe**
   - Localizado na parte superior. 
   - Geralmente √© escrito com a primeira letra mai√∫scula, seguindo a conven√ß√£o da linguagem Java.
   - **Exemplo:** `Gato`

2. **Atributos (ou Propriedades)**
   - Representam os **dados** ou caracter√≠sticas da classe.
   - S√£o escritos com o seguinte padr√£o:
     `visibilidade nome : tipo`
   - **Exemplo:** `- idade : int`

3. **M√©todos (ou Opera√ß√µes)**

   - Representam os **comportamentos** ou a√ß√µes que a classe pode executar.
   - Seguem o padr√£o: `visibilidade nome(par√¢metros) : tipoRetorno`
   - Exemplo: `+ comer(quantidade: float) : void`

<br />

### ‚úÖ Conven√ß√µes de Visibilidade

Os s√≠mbolos antes dos atributos e m√©todos indicam a **visibilidade** (ou modificador de acesso):

| S√≠mbolo | Visibilidade                            | Acesso permitido por                |
| ------- | --------------------------------------- | ----------------------------------- |
| `+`     | **P√∫blica**                             | Qualquer classe                     |
| `-`     | **Privada**                             | Apenas a pr√≥pria classe             |
| `#`     | **Protegida**                           | A pr√≥pria classe e suas subclasses  |
| `~`     | **Friendly** (*padr√£o/package-private*) | Qualquer classe do **mesmo pacote** |

<br />

<h2>4. Modificadores</h2>



Os modificadores merecem um t√≥pico √† parte.

Em Java, os **modificadores** s√£o palavras-chave utilizadas para definir a **visibilidade**, o **n√≠vel de acesso** e algumas **caracter√≠sticas especiais** de uma classe, m√©todo ou atributo.

Eles s√£o fundamentais para o controle da estrutura e do encapsulamento no c√≥digo, permitindo estabelecer **quem pode acessar** ou **modificar** determinados membros da aplica√ß√£o.

<br />

<h3>4.1. Modificadores de Visibilidade</h3>



Os **Modificadores de Visibilidade**, tamb√©m chamados de **Modificadores de Acesso**, determinam como uma **classe**, **atributo** ou **m√©todo** poder√° ser acessado ao longo do desenvolvimento do sistema. Em outras palavras, eles definem **quem pode acessar o qu√™** dentro do c√≥digo.

Um conceito essencial para entender visibilidade em Java √© o de **pacotes** (`package`), visto no t√≥pico <a href="13.md">**M√©todos**</a>. Caso voc√™ tenha alguma d√∫vida, acesse o conte√∫do.

<br />

<h4>4.1.1. Modificadores de Acesso - Classes</h4>



As classes podem utilizar apenas dois modificadores de acesso:

### ‚úÖ Modificadores de Acesso - Classes

| **Modificador**              | **Descri√ß√£o**                                                |
| ---------------------------- | ------------------------------------------------------------ |
| **padr√£o** (sem modificador) | Tamb√©m chamado de *friendly*. A classe poder√° ser acessada apenas por outras classes **dentro do mesmo pacote**. |
| **public**                   | A classe poder√° ser acessada por qualquer outra classe, independentemente do pacote em que estiver. |

<br />

> [!NOTE]
>
> **ALERTA DE BSM** 
>
> *Mantenha a Aten√ß√£o aos Detalhes!* 
>
> Ao definir o modificador de uma classe: `padr√£o` e `public`, lembre-se que eles s√£o mutuamente exclusivos, ou seja, **n√£o podem ser combinados.**

<br />

<h4>4.1.2. Modificadores de Acesso - M√©todos e Atributos</h4>



M√©todos e atributos podem utilizar quatro modificadores de acesso distintos:

### ‚úÖ Modificadores de Acesso - M√©todos e Atributos

| **Modificador**              | **Descri√ß√£o**                                                | UML  |
| ---------------------------- | ------------------------------------------------------------ | ---- |
| **padr√£o** (sem modificador) | O acesso √© permitido apenas por classes **dentro do mesmo pacote**. | ~    |
| **public**                   | O acesso √© permitido por **qualquer classe**, em qualquer pacote. O m√©todo s√≥ pode ser acessado se a classe tamb√©m for p√∫blica. | +    |
| **protected**                | Permite acesso √†s classes **do mesmo pacote** e tamb√©m a qualquer **subclasse**, mesmo que esteja em outro pacote. | #    |
| **private**                  | O acesso √© restrito **apenas √† pr√≥pria classe** onde foi declarado. | -    |

<br />

> [!NOTE]
>
> **ALERTA DE BSM** 
>
> *Mantenha a Aten√ß√£o aos Detalhes!* 
>
> Ao definir o modificador de uma classe: `padr√£o`, `public`, `private` e `protected`, lembre-se que eles s√£o mutuamente exclusivos, ou seja, **n√£o podem ser combinados.**

<br />

> [!TIP]
>
> Na modelagem de classes, √© comum adotar a pr√°tica de manter **atributos como `private`** e **m√©todos como `public`**, promovendo o **encapsulamento**, que ser√° explorado no pr√≥ximo t√≥pico.

<br />

A imagem abaixo ilustra a hierarquia dos modificadores de acesso, do mais restrito ao mais permissivo:

<div align="center"><img src="https://i.imgur.com/NdEp3gV.png" title="source: imgur.com" /></div>

A imagem acima mostra o n√≠vel de visibilidade dos Atributos e M√©todos, do n√≠vel de acesso mais restrito (Private) ao n√≠vel de acesso total e irrestrito (Public). Na tabela abaixo temos um resumo:

### ‚úÖ Modificadores de Acesso - Hierarquia

| Modificador   | Classe | Pacote | Sub Classe | Mundo |
| ------------- | :----: | :----: | :--------: | :---: |
| **public**    |   ‚úî    |   ‚úî    |     ‚úî      |   ‚úî   |
| **protected** |   ‚úî    |   ‚úî    |     ‚úî      |   ‚ùå   |
| **padr√£o**    |   ‚úî    |   ‚úî    |     ‚ùå      |   ‚ùå   |
| **private**   |   ‚úî    |   ‚ùå    |     ‚ùå      |   ‚ùå   |

<br />

> [!IMPORTANT]
>
> Os modificadores de acesso aplicados a um atributo ou m√©todo determinam quais classes podem interagir com esses elementos, respeitando o n√≠vel de visibilidade definido. 

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html" target="_blank"><b>Documenta√ß√£o: Modificadores de acesso</b></a></div>

<br />

<h3>4.2. Modificadores Non-Access</h3>



Os **Modificadores Non-Access** definem **comportamentos espec√≠ficos** de uma classe, m√©todo ou atributo, como possibilidade de heran√ßa, sobrescrita, imutabilidade, entre outros.

<br />

<h4>4.2.1. Modificadores Non-Access - Classes</h4>



As classes podem utilizar os seguintes modificadores Non-Access:

### ‚úÖ Modificadores Non-Access - Classes

| **Modificador** | **Descri√ß√£o**                                                |
| --------------- | ------------------------------------------------------------ |
| **abstract**    | Indica que a classe **n√£o pode ser instanciada diretamente**. Deve ser obrigatoriamente herdada por outra classe. |
| **final**       | Impede que a classe seja herdada. Nenhuma outra classe poder√° herd√°-la. |

<br />

> [!NOTE]
>
> **ALERTA DE BSM** 
>
> *Mantenha a Aten√ß√£o aos Detalhes!* 
>
> Uma classe n√£o pode ser ao mesmo tempo `abstract` e `final`, pois **uma impede heran√ßa e a outra exige heran√ßa**.

<br />

<h4>4.2.2. Modificadores Non-Access - M√©todos</h4>



M√©todos podem utilizar os seguintes modificadores non-access:

### ‚úÖ Modificadores Non-Access - M√©todos

| **Modificador** | **Descri√ß√£o**                                                |
| --------------- | ------------------------------------------------------------ |
| **abstract**    | Define a **assinatura do m√©todo sem implementa√ß√£o**. A implementa√ß√£o √© obrigat√≥ria na primeira subclasse concreta. A classe que o cont√©m tamb√©m deve ser `abstract`. |
| **final**       | Impede que o m√©todo seja sobrescrito por subclasses.         |
| **static**      | O m√©todo **pertence √† classe**, e n√£o a uma inst√¢ncia. Pode ser chamado diretamente pela classe, sem necessidade de criar um objeto. |

<br />

 **Regras importantes:**

- Um m√©todo `static` n√£o pode acessar diretamente atributos ou m√©todos de uma  inst√¢ncia.
- Um m√©todo **nunca pode ser** `abstract` e `final` ao mesmo tempo.
- Um m√©todo **nunca pode ser** `abstract` e `private`.
- Um m√©todo `final` **n√£o pode ser sobrescrito**.
- Um m√©todo `abstract` **n√£o possui corpo**, apenas a assinatura.

<br />

<h4>4.2.3. Modificadores Non-Access - Atributos</h4>



Atributos tamb√©m podem utilizar modificadores non-access, como:

### ‚úÖ Modificadores Non-Access - Atributos

| **Modificador** | **Descri√ß√£o**                                                |
| --------------- | ------------------------------------------------------------ |
| **final**       | Torna o atributo **constante**: seu valor **n√£o pode ser alterado** ap√≥s a inicializa√ß√£o. |
| **static**      | Define que o atributo **pertence √† classe**, e n√£o √†s inst√¢ncias. √â compartilhado entre todos os objetos. |

<br />

> [!IMPORTANT]
>
> Um atributo `final static` √© uma **constante global**, geralmente declarada com letras mai√∫sculas: `public static final double PI = 3.14;`

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://www.w3schools.com/java/java_modifiers.asp" target="_blank"><b>Documenta√ß√£o: Modificadores Non-Access</b></a></div>
<br />

## <img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/> Exemplo 01: Classe Conta

<br />

> [!WARNING]
>
> A partir deste ponto, estamos partindo do princ√≠pio de que o projeto **Conta Banc√°ria** j√° foi devidamente criado e que a **Classe Menu** foi implementada conforme os conte√∫dos:
>
>  - <a href="pr01.md">Projeto Conta Banc√°ria - Classe Menu</a>
>  - <a href="pr02.md">Projeto Conta Banc√°ria - Classe Menu - Colorido</a>
>
>  Caso ainda n√£o tenha conclu√≠do essas etapas, recomendamos que voc√™ retorne aos t√≥picos indicados antes de prosseguir.

<br />

A seguir, iniciaremos a constru√ß√£o da **Classe `Conta`**, que faz parte do projeto **Conta Banc√°ria**. Essa classe ser√° desenvolvida **passo a passo**, com o objetivo de facilitar o entendimento de cada componente que a comp√µe ‚Äî desde os atributos e construtores at√© os m√©todos respons√°veis pelas opera√ß√µes banc√°rias.

Durante a implementa√ß√£o, ser√£o explicados os conceitos envolvidos, como encapsulamento, visibilidade, assinatura de m√©todos e boas pr√°ticas de organiza√ß√£o do c√≥digo em Java.

Esse processo guiado permitir√° compreender, de forma pr√°tica e progressiva, como estruturar uma classe orientada a objetos no contexto de um sistema banc√°rio.

<br />

<h2>üë£ Passo 01 - Classe Conta - Criar os atributos</h2>



**C√≥digo Java**

```java
public class Conta {

    /*Atributos da Classe Conta*/
	private int numero;
	private int agencia;
	private int tipo;
	private String titular;
	private float saldo;
  
}
```

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/classdecl.html" target="_blank"><b>Documenta√ß√£o: Declara√ß√£o de Classes</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/variables.html" target="_blank"><b>Documenta√ß√£o: Declara√ß√£o de Atributos</b></a></div>

<br />

<h2>5. M√©todos Especiais</h2>



Ao desenvolver nossas **classes como modelos para cria√ß√£o de objetos**, √© essencial implementar alguns **m√©todos especiais** que definem o comportamento padr√£o desses objetos. Um dos principais √© o **m√©todo construtor**, respons√°vel pela inicializa√ß√£o correta de cada inst√¢ncia da classe.

<br />

<h3>5.1. M√©todo Construtor</h3>



Para criar (ou instanciar) um novo objeto a partir de uma classe, utilizamos o **m√©todo construtor** ‚Äî um m√©todo especial projetado exclusivamente para essa finalidade.

As principais caracter√≠sticas de um m√©todo construtor s√£o:

- Define as a√ß√µes executadas durante a **inicializa√ß√£o de um objeto**.
- √â **invocado automaticamente** sempre que um novo objeto da classe √© criado.
- **N√£o possui tipo de retorno**, nem mesmo `void`, o que o diferencia de outros m√©todos.
- O **nome do construtor deve ser exatamente igual ao nome da classe**.
- Pode **receber par√¢metros**, geralmente com os mesmos nomes dos atributos da classe, para facilitar a atribui√ß√£o inicial dos valores.
- Toda **classe deve ter pelo menos um construtor**. Se nenhum for declarado, o compilador Java cria automaticamente um **construtor padr√£o** (default), sem par√¢metros, que inicializa os atributos com valores padr√£o (`0` para n√∫meros, `false` para booleanos e `null` para refer√™ncias).
- Se a pessoa desenvolvedora **definir manualmente qualquer construtor**, o construtor padr√£o **n√£o ser√° gerado automaticamente**. Caso seja necess√°rio, dever√° ser criado explicitamente.
- √â poss√≠vel definir **v√°rios construtores** para a mesma classe utilizando o conceito de **sobrecarga de m√©todos** (que ser√° abordado mais adiante). Essa pr√°tica permite criar objetos de maneiras diferentes, dependendo da necessidade do sistema.

<br />

<h2>üë£ Passo 02 - Classe Conta - Criar o M√©todo Construtor</h2>



**C√≥digo Java**

```java
public class Conta {

     /*Atributos da Classe Conta*/
	private int numero;
	private int agencia;
	private int tipo;
	private String titular;
	private float saldo;
  
    /*M√©todo Construtor da Classe Conta - com todos os par√¢metros*/
	public Conta(int numero, int agencia, int tipo, String titular, float saldo) {
		this.numero = numero;
		this.agencia = agencia;
		this.tipo = tipo;
		this.titular = titular;
		this.saldo = saldo;
	}
    
}	
```

Observe que o **M√©todo Construtor** foi declarado como `public` para permitir que outras classes do sistema tenham acesso a ele e possam **instanciar novos objetos da classe `Conta`**. Essa visibilidade √© fundamental, pois garante que a classe esteja dispon√≠vel para ser utilizada externamente no contexto da aplica√ß√£o.

Al√©m disso, note que foi utilizada a palavra-chave **`this`** em cada atribui√ß√£o de atributo. Isso ocorre porque, quando os **nomes dos par√¢metros do construtor** s√£o **iguais aos nomes dos atributos da classe**, √© necess√°rio usar `this` para **diferenciar o atributo da vari√°vel local (par√¢metro)**.

Em outras palavras, `this.nome` faz refer√™ncia ao atributo da classe, enquanto `nome` sozinho se refere ao par√¢metro recebido. Esse recurso √© essencial para evitar ambiguidades e garantir que os valores passados no momento da cria√ß√£o do objeto sejam corretamente atribu√≠dos aos atributos da inst√¢ncia.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html" target="_blank"><b>Documenta√ß√£o: M√©todo Construtor</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html" target="_blank"><b>Documenta√ß√£o: Palavra reservada this</b></a></div>


<br />

<h3>5.2. M√©todos Get e Set</h3>



Os m√©todos *get* e *set* s√£o t√©cnicas padronizadas para o gerenciamento de acesso aos atributos de uma classe. Atrav√©s desses m√©todos, √© poss√≠vel controlar quando e como os atributos podem ser consultados ou modificados. Esse controle torna o c√≥digo mais seguro, limpo e de f√°cil manuten√ß√£o, uma vez que evita a exposi√ß√£o direta dos atributos.

A utiliza√ß√£o desses m√©todos √© especialmente importante quando os atributos da classe s√£o declarados como **privados** (`private`), o que significa que s√≥ podem ser acessados diretamente de dentro da pr√≥pria classe. Para manipul√°-los externamente, devemos utilizar os m√©todos p√∫blicos `get` e `set`.

<br />

<h4>5.2.1. M√©todos SET</h4>



Os m√©todos *set* s√£o utilizados para **modificar o valor dos atributos** da classe. Tamb√©m conhecidos como *setters*, seguem a conven√ß√£o de nomenclatura `setNomeDoAtributo`.

Por exemplo, se o atributo se chama `numero`, o m√©todo que altera seu valor deve se chamar `setNumero(int numero)`. O valor desejado √© passado como **par√¢metro**, e a atribui√ß√£o √© feita dentro do corpo do m√©todo.

√â importante destacar que, nesses m√©todos, √© **recomend√°vel aplicar valida√ß√µes** nos dados recebidos antes de atribu√≠-los ao atributo. Dessa forma, evitamos o armazenamento de dados incorretos ou inconsistentes.

**Exemplo: M√©todo `setNumero` da classe `Conta`:**

```java
	public void setNumero(int numero) {
		this.numero = numero;
	}
```

Observe o uso da palavra-chave **`this`**. Ela √© necess√°ria para indicar que estamos nos referindo ao atributo da classe, j√° que o nome da vari√°vel passada como par√¢metro √© o mesmo (`numero`).

Cada atributo da classe pode (e deve) possuir seu pr√≥prio m√©todo `set`, sempre respeitando a conven√ß√£o de nomenclatura.

<br />

<h4>5.2.2. M√©todos GET</h4>



Os m√©todos *get* s√£o utilizados para **consultar ou retornar o valor atual de um atributo**. Tamb√©m chamados de *getters*, seguem a conven√ß√£o `getNomeDoAtributo`.

Se o atributo for `numero`, o nome do m√©todo ser√° `getNumero()`. Diferente dos *setters*, os *getters* **n√£o recebem par√¢metros** e simplesmente retornam o valor armazenado no atributo.

Esses m√©todos tamb√©m s√£o conhecidos como **m√©todos de acesso** ou **m√©todos de consulta**, pois oferecem uma forma segura de obter informa√ß√µes dos objetos.

**Exemplo: M√©todo `getNumero` da classe `Conta`:**

```java
	public int getNumero() {
		return numero;
	}
```

Perceba que o m√©todo apenas retorna o valor do atributo. Quando necess√°rio, tamb√©m √© poss√≠vel incluir regras de neg√≥cio ou formata√ß√£o dentro do m√©todo `get`.

Embora os m√©todos `get` e `set` permitam acessar atributos privados, esse acesso continua **restrito** √† l√≥gica definida pelo programador, o que garante maior seguran√ßa e encapsulamento.

<br />

<h4>5.2.3. Vantagens de utilizar os M√©todos getters e setters</h4>



1. Permitem **controlar o acesso** aos atributos da classe, seguindo os princ√≠pios do encapsulamento.
2. √â poss√≠vel **restringir a leitura ou modifica√ß√£o** de atributos, simplesmente omitindo o `get` ou o `set` correspondente.
3. Os `setters` possibilitam **validar os dados antes de armazen√°-los**, garantindo integridade dos objetos.
4. Os `getters` permitem **ocultar o tipo ou o formato interno** de um atributo, oferecendo uma interface mais flex√≠vel ao usu√°rio da classe.
5. Facilitam futuras **altera√ß√µes internas**, sem impactar diretamente as demais classes que utilizam os objetos.

<br />

<h2>üë£ Passo 03 - Classe Conta - Criar os M√©todos Get e Set</h2>



**C√≥digo Java**

```java
public class Conta {

     /*Atributos da Classe Conta*/
	private int numero;
	private int agencia;
	private int tipo;
	private String titular;
	private float saldo;
  
    /*M√©todo Construtor da Classe Conta - com todos os par√¢metros*/
	public Conta(int numero, int agencia, int tipo, String titular, float saldo) {
		this.numero = numero;
		this.agencia = agencia;
		this.tipo = tipo;
		this.titular = titular;
		this.saldo = saldo;
	}
    
    /*M√©todos Get e Set da Classe Conta*/
    public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public int getAgencia() {
		return agencia;
	}

	public void setAgencia(int agencia) {
		this.agencia = agencia;
	}

	public int getTipo() {
		return tipo;
	}

	public void setTipo(int tipo) {
		this.tipo = tipo;
	}

	public String getTitular() {
		return titular;
	}

	public void setTitular(String titular) {
		this.titular = titular;
	}

	public float getSaldo() {
		return saldo;
	}

	public void setSaldo(float saldo) {
		this.saldo = saldo;
	}
    
}	
```

Os m√©todos *get* e *set* s√£o fundamentais para acessar e modificar os atributos da classe `Conta`. Esses m√©todos seguem o princ√≠pio do encapsulamento da programa√ß√£o orientada a objetos, permitindo que os dados sejam acessados ou alterados de forma controlada, sem expor diretamente os atributos da classe. 

Os m√©todos *get* retornam os valores atuais dos atributos, enquanto os m√©todos *set* permitem atribuir novos valores aos atributos, garantindo assim maior seguran√ßa e flexibilidade no gerenciamento das informa√ß√µes da conta.

**√â importante destacar que, caso um atributo n√£o possua seus respectivos m√©todos *get* ou *set*, a leitura ou a altera√ß√£o desse valor n√£o ser√° poss√≠vel fora da pr√≥pria classe**. Isso pode limitar funcionalidades importantes, como a visualiza√ß√£o do titular ou a atualiza√ß√£o do saldo. Por isso, √© essencial garantir que todos os atributos relevantes estejam acompanhados de seus m√©todos de acesso e modifica√ß√£o, conforme a necessidade do projeto.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://www.w3schools.com/java/java_encapsulation.asp" target="_blank"><b>Documenta√ß√£o: M√©todos GET e SET</b></a></div>

<br />

### 5.3. M√©todos Auxiliares



Al√©m dos m√©todos construtores, getters e setters, uma classe pode conter **m√©todos auxiliares**, que representam **a√ß√µes espec√≠ficas que os objetos daquela classe podem executar**. No caso da Classe `Conta`, vamos implementar os m√©todos `sacar()`, `depositar()` e `visualizar()`.

Esses m√©todos s√£o fundamentais para simular opera√ß√µes comuns em contas banc√°rias:

- O **m√©todo `sacar()`** permite realizar uma retirada de valor da conta, desde que haja saldo suficiente.
- O **m√©todo `depositar()`** possibilita adicionar valores ao saldo da conta.
- E o **m√©todo `visualizar()`** exibe as informa√ß√µes detalhadas da conta, como n√∫mero, ag√™ncia, tipo, titular e saldo.

Essas funcionalidades aumentam a **interatividade com os objetos da classe** e tornam a aplica√ß√£o mais din√¢mica, permitindo que o usu√°rio manipule os dados de forma pr√°tica e segura.

<br />

<h2>üë£ Passo 04 - Classe Conta - Criar os M√©todos Auxiliares</h2>



**C√≥digo Java**

```java
public class Conta {

     /*Atributos da Classe Conta*/
	private int numero;
	private int agencia;
	private int tipo;
	private String titular;
	private float saldo;
  
    /*M√©todo Construtor da Classe Conta - com todos os par√¢metros*/
	public Conta(int numero, int agencia, int tipo, String titular, float saldo) {
		this.numero = numero;
		this.agencia = agencia;
		this.tipo = tipo;
		this.titular = titular;
		this.saldo = saldo;
	}
    
    /*M√©todos Get e Set da Classe Conta*/
    public int getNumero() {
		return numero;
	}

	public void setNumero(int numero) {
		this.numero = numero;
	}

	public int getAgencia() {
		return agencia;
	}

	public void setAgencia(int agencia) {
		this.agencia = agencia;
	}

	public int getTipo() {
		return tipo;
	}

	public void setTipo(int tipo) {
		this.tipo = tipo;
	}

	public String getTitular() {
		return titular;
	}

	public void setTitular(String titular) {
		this.titular = titular;
	}

	public float getSaldo() {
		return saldo;
	}

	public void setSaldo(float saldo) {
		this.saldo = saldo;
	}
    
    // M√©todos Auxiliares
   public boolean sacar(float valor) {

		if (this.saldo < valor) {
			System.out.println("\n Saldo Insuficiente!");
			return false;
		}

		this.saldo = this.saldo - valor;
		return true;
	}

	public void depositar(float valor) {

		this.saldo = this.saldo + valor;

	}
	
	public void visualizar() {

		String tipo = "";
		
		switch(this.tipo) {
		case 1:
			tipo = "Conta Corrente";
		break;
		case 2:
			tipo = "Conta Poupan√ßa";
		break;
		}
		
		System.out.println("\n\n***********************************************************");
		System.out.println("Dados da Conta:");
		System.out.println("***********************************************************");
		System.out.println("Numero da Conta: " + this.numero);
		System.out.println("Ag√™ncia: " + this.agencia);
		System.out.println("Tipo da Conta: " + tipo);
		System.out.println("Titular: " + this.titular);
		System.out.println("Saldo: " + this.saldo);

	}
    
    
}	
```

O m√©todo `sacar(float valor)` realiza uma verifica√ß√£o para garantir que o valor solicitado n√£o seja maior que o saldo dispon√≠vel. Caso o saldo seja insuficiente, uma mensagem de alerta √© exibida, e o m√©todo retorna `false`. Se o saque for poss√≠vel, o valor √© subtra√≠do do saldo e o m√©todo retorna `true`.

O m√©todo `depositar(float valor)` √© mais direto: ele simplesmente adiciona o valor informado ao saldo atual da conta. Essa opera√ß√£o n√£o exige valida√ß√µes adicionais, j√° que n√£o h√° restri√ß√µes para dep√≥sitos positivos. Ambos os m√©todos utilizam o `setSaldo()` e o `getSaldo()` para manter o encapsulamento dos atributos, respeitando as boas pr√°ticas da programa√ß√£o orientada a objetos.

Por fim, o m√©todo `visualizar()` tem a fun√ß√£o de exibir os principais dados da conta. Ele identifica o tipo da conta com base em seu valor num√©rico (1 para Conta Corrente e 2 para Conta Poupan√ßa) e imprime as informa√ß√µes formatadas no console, incluindo n√∫mero da conta, ag√™ncia, tipo, titular e saldo. Esse m√©todo √© √∫til para facilitar a confer√™ncia dos dados durante a execu√ß√£o do programa.

<br />

## 6. Encapsulamento



O **Encapsulamento** √© um dos pilares da Programa√ß√£o Orientada a Objetos e consiste em **proteger os atributos de uma classe contra acessos diretos e n√£o controlados**, restringindo sua manipula√ß√£o apenas por meio de **m√©todos espec√≠ficos**.

Essa abordagem garante que os dados internos de um objeto sejam acessados e modificados de maneira **segura, controlada e coerente**, evitando comportamentos inesperados ou inconsist√™ncias.

Na pr√°tica, o encapsulamento √© implementado atrav√©s da combina√ß√£o de:

- **Atributos privados** (`private`), que n√£o podem ser acessados diretamente por outras classes.
- **M√©todos p√∫blicos** (`public`), chamados de **getters** e **setters**, que controlam o acesso e a modifica√ß√£o dos atributos.

<br />

<h3>6.1. Por que encapsular?</h3>



O encapsulamento tem como principal objetivo **evitar que atributos sejam alterados de forma indevida ou acidental**, protegendo a integridade dos dados da aplica√ß√£o. Ao centralizar o acesso e a altera√ß√£o por meio de m√©todos, √© poss√≠vel validar, restringir ou at√© mesmo bloquear certas opera√ß√µes.

Por exemplo, na classe `Conta`, n√£o √© permitido alterar diretamente (atribui√ß√£o) o valor do atributo `saldo`. Em vez disso, criamos m√©todos auxiliares como `sacar()` e `depositar()`, que garantem que a opera√ß√£o s√≥ seja executada se atender a crit√©rios definidos (como n√£o sacar um valor maior que o saldo dispon√≠vel).

Al√©m disso, os m√©todos `get` e `set` permitem:

- Restringir a leitura ou escrita de determinados dados.
- Validar as informa√ß√µes antes de armazen√°-las.
- Manter a consist√™ncia do estado interno do objeto.

> **Importante:** Mesmo que os m√©todos `get` e `set` ofere√ßam acesso aos atributos privados, o controle est√° centralizado neles. Cabe ao programador decidir como e quando os dados podem ser lidos ou modificados.

<br />

<h3>6.2. M√©todos Auxiliares e o Encapsulamento</h3>



Na classe `Conta`, al√©m dos m√©todos `get` e `set`, criamos m√©todos auxiliares que operam sobre os dados encapsulados:

- **`sacar()`**: verifica o saldo e realiza a retirada de valor.
- **`depositar()`**: adiciona um valor ao saldo da conta.
- **`visualizar()`**: exibe as informa√ß√µes da conta de forma estruturada.

Esses m√©todos **interagem com os atributos de forma controlada**, refor√ßando a aplica√ß√£o do encapsulamento. Assim, qualquer l√≥gica relacionada √† manipula√ß√£o do saldo, por exemplo, est√° concentrada dentro da pr√≥pria classe.

<br />

<h3>6.3. Vantagens do Encapsulamento</h3>



O uso do encapsulamento traz diversas vantagens no desenvolvimento orientado a objetos:

- **Seguran√ßa e prote√ß√£o dos dados**: impede modifica√ß√µes diretas e indesejadas nos atributos.
- **Valida√ß√£o centralizada**: permite aplicar regras de neg√≥cio no momento da leitura ou altera√ß√£o dos dados.
- **Facilidade de manuten√ß√£o**: altera√ß√µes na l√≥gica interna da classe n√£o afetam diretamente as outras partes do sistema.
- **Reutiliza√ß√£o e modularidade**: classes encapsuladas s√£o mais organizadas, coesas e reutiliz√°veis.
- **Desenvolvimento mais √°gil e confi√°vel**: como os dados s√£o acessados via m√©todos, o desenvolvedor n√£o precisa conhecer a implementa√ß√£o interna da classe.

<br />

> ‚ö†Ô∏è **Ponto de Aten√ß√£o: Encapsulamento vs Seguran√ßa da Informa√ß√£o**
>
> Embora compartilhem objetivos semelhantes, √© importante **n√£o confundir encapsulamento com seguran√ßa da informa√ß√£o**:
>
> - **Encapsulamento** √© um conceito de design de software, focado na **prote√ß√£o l√≥gica dos dados dentro do c√≥digo**.
> - **Seguran√ßa da informa√ß√£o** abrange pr√°ticas e tecnologias mais amplas, como **criptografia, autentica√ß√£o, controle de acesso, backups, monitoramento e auditoria**, em n√≠vel de sistema, rede e infraestrutura.
>
> Em resumo: **encapsular protege o c√≥digo; seguran√ßa da informa√ß√£o protege os dados como um todo**.

<br />

<h2>7. Instanciando um Objeto</h2>



Para que possamos utilizar a Classe `Conta` e acessar seus atributos e m√©todos, precisamos **instanciar objetos** a partir dela. Para isso, utilizaremos a classe `Menu`, que ser√° respons√°vel por executar a aplica√ß√£o e interagir com o usu√°rio.

Dentro da classe `Menu`, implementamos o **m√©todo `main()`**, ponto de entrada de qualquer aplica√ß√£o Java. √â a partir dele que o programa ser√° iniciado e os objetos da classe `Conta` ser√£o criados e manipulados.

<br />

<h2>üë£ Passo 05 - Classe Menu - Instanciar Objetos da Classe Conta</h2>



**C√≥digo Java**

```java
package conta;

import java.util.Scanner;
import conta.model.Conta;
import conta.util.Cores;

public class Menu {

	public static void main(String[] args) {
		
		// Teste da Classe Conta
		
         // Instanciar um novo objeto da classe Conta
         Conta c1 = new Conta(1, 123, 1, "Adriana Sanches", 10000.0f);
		
         // Visualizar os dados
         c1.visualizar();
         
         // Alterar o Saldo e o nome do Titular
         c1.setSaldo(15000.0f);
		c1.setTitular("Maria Joaquina");
		c1.visualizar();
		
         // Sacar
         c1.sacar(12000.0f);
		c1.visualizar();
		
         // Depositar
         c1.depositar(5000.0f);
		c1.visualizar();

		// C√≥digo da Classe Menu...
    }
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash

***********************************************************
Dados da Conta:
***********************************************************
Numero da Conta: 1
Ag√™ncia: 123
Tipo da Conta: Conta Corrente
Titular: Adriana Sanches
Saldo: 10000.0


***********************************************************
Dados da Conta:
***********************************************************
Numero da Conta: 1
Ag√™ncia: 123
Tipo da Conta: Conta Corrente
Titular: Maria Joaquina
Saldo: 15000.0


***********************************************************
Dados da Conta:
***********************************************************
Numero da Conta: 1
Ag√™ncia: 123
Tipo da Conta: Conta Corrente
Titular: Maria Joaquina
Saldo: 3000.0


***********************************************************
Dados da Conta:
***********************************************************
Numero da Conta: 1
Ag√™ncia: 123
Tipo da Conta: Conta Corrente
Titular: Maria Joaquina
Saldo: 8000.0
```

Neste √∫ltimo passo, criamos e testamos um objeto da classe `Conta`, identificado como `c1`. 

Para instanci√°-lo, utilizamos o **m√©todo construtor** da classe `Conta`, com a palavra reservada `new`, que aloca dinamicamente o objeto na mem√≥ria. Todos os atributos necess√°rios (n√∫mero, ag√™ncia, tipo, titular e saldo) foram passados como argumentos na cria√ß√£o do objeto.

A partir do objeto instanciado, podemos acessar os m√©todos da classe por meio da sintaxe **objeto.m√©todo()**. 

Por exemplo, ao chamar `c1.visualizar()`, exibimos todos os dados da conta no console. 

J√° os m√©todos `setSaldo()` e `setTitular()` permitem alterar dinamicamente os dados do objeto. 

M√©todos como `sacar()` e `depositar()` tamb√©m podem ser chamados para modificar o saldo da conta de forma segura e controlada.

Esse exemplo pr√°tico demonstra como √© poss√≠vel manipular os dados de um objeto a partir de seus m√©todos p√∫blicos, refor√ßando o conceito de encapsulamento na Programa√ß√£o Orientada a Objetos.

<br />

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/objectcreation.html" target="_blank"><b>Documenta√ß√£o: Instanciando Objetos</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://www.w3schools.com/java/ref_keyword_new.asp" target="_blank"><b>Documenta√ß√£o: Palavra reservada new</b></a></div>

<div align="left"><img src="https://i.imgur.com/JSfXyzm.png" title="source: imgur.com" width="30px"/> <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/usingobject.html" target="_blank"><b>Documenta√ß√£o: Usando Objetos</b></a></div>

<br />

<h2>8. Record</h2>



Os **Records** foram introduzidos no Java 14 e se tornaram um recurso definitivo a partir do Java 16. Eles representam um tipo especial de **classe imut√°vel**, projetada para armazenar dados de forma simples e sem a necessidade de muito c√≥digo repetitivo (*boilerplate*).

Assim como classes tradicionais, que acabamos de estudar, os **records** s√£o usados para criar **objetos**, mas com caracter√≠sticas pr√≥prias que os diferenciam:

- Estrutura fixa e imut√°vel.
- Construtor gerado automaticamente.
- Foco em representar **dados**, n√£o comportamentos complexos.

> Enquanto as **classes tradicionais** podem ser projetadas para m√∫ltiplos comportamentos e estados mut√°veis, os **records** priorizam a simplicidade e a imutabilidade.

<br />

<h3>8.1. O que √© um Record?</h3>



Um **record** em Java:

- √â uma forma especial de declarar uma classe **imut√°vel**.
- Todos os campos definidos no cabe√ßalho s√£o **final** e obrigatoriamente inicializados no momento da cria√ß√£o.
- Pode implementar interfaces.
- N√£o pode estender outras classes.
- Pode conter m√©todos e construtores adicionais, mas n√£o pode ter campos fora do cabe√ßalho principal.

**Sintaxe:**

```java
public record NomeDoRecord(TipoCampo1 campo1, TipoCampo2 campo2) {}
```

<br />

<h3>8.2. Por que utilizar Records?</h3>



Os **records** s√£o √∫teis quando precisamos criar classes para **armazenar dados simples** de forma r√°pida, evitando a repeti√ß√£o de c√≥digo que normalmente escrever√≠amos em classes tradicionais, como:

- Atributos privados.
- Construtor que inicializa todos os atributos.
- M√©todos `getters`.

### Principais vantagens:

- **Menos c√≥digo:** o compilador gera automaticamente m√©todos essenciais.
- **Imutabilidade:** os dados n√£o podem ser alterados ap√≥s a cria√ß√£o.
- **Leitura f√°cil:** a defini√ß√£o √© clara e concisa.
- **Perfeito para DTOs (Data Transfer Objects)** e respostas de API.

<br />

<img src="https://i.imgur.com/T9MiDNG.png" title="source: imgur.com" width="5%"/>**Exemplo - Record**

<br />

> [!WARNING]
>
> **ATEN√á√ÉO!**
>
> Este exemplo √© **apenas ilustrativo**. **N√£o inclua estes c√≥digos em nenhuma classe ou arquivo** do Projeto Conta Banc√°ria. O c√≥digo abaixo serve apenas para fins de estudo e compreens√£o dos conceitos apresentados.

<br />

**Classe Pessoa**

```java
public record Pessoa(String nome, int idade) { }
```

**Classe TestaPessoa**

```java
public class TestaPessoa {
    public static void main(String[] args) {
        
        Pessoa p1 = new Pessoa("Renata Lima", 25);

        System.out.printf("Nome: %s%n", p1.nome());
        System.out.printf("Idade: %d%n", p1.idade()); 
        System.out.println(p1);

    }
}
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/>**Resultado do C√≥digo:**

```bash
Nome: Renata Lima
Idade: 25
Pessoa[nome=Renata Lima, idade=25]
```

No exemplo acima o compilador criou o construtor e os m√©todos `nome()` e `idade()` (equivalentes a getters).

<br />

------

## üîë**Pontos chave:**

1. A **Programa√ß√£o Orientada a Objetos (POO)** √© um paradigma que prop√µe modelar sistemas com base em entidades do mundo real, chamadas **objetos**, que possuem **atributos** (estado) e **m√©todos** (comportamento).
2. O paradigma orientado a objetos **favorece a modulariza√ß√£o, o reuso e a manuten√ß√£o do c√≥digo**, pois permite representar de forma mais pr√≥xima a realidade os elementos envolvidos no dom√≠nio do sistema.
3. A **modelagem orientada a objetos** proporciona uma compreens√£o mais intuitiva do sistema, facilitando a comunica√ß√£o entre equipe t√©cnica e especialistas do dom√≠nio.
4. Um **objeto** √© qualquer entidade com **identidade, estado e comportamento**. Ele √© uma inst√¢ncia de uma **classe**, que funciona como molde para sua cria√ß√£o.
5. As **classes** definem a estrutura dos objetos e s√£o compostas por **atributos** (dados) e **m√©todos** (a√ß√µes). A cria√ß√£o de um objeto a partir de uma classe √© chamada de **instancia√ß√£o**.
6. Objetos s√£o **instanciados** a partir das classes. Eles t√™m valores atribu√≠dos a seus atributos e executam a√ß√µes (ou as a√ß√µes s√£o executadas neles) por meio de m√©todos.
7. Os **modificadores de acesso** definem a visibilidade dos elementos da aplica√ß√£o (classes, atributos e m√©todos), sendo os principais: `public`, `private`, `protected` e `padr√£o` (sem modificador).
8. Os **modificadores non-access** definem comportamentos adicionais, como heran√ßa (`abstract`), impedimento de sobrescrita (`final`) e associa√ß√£o direta √† classe (`static`).
9. O **m√©todo construtor** √© respons√°vel por inicializar os atributos de um objeto no momento da sua cria√ß√£o. Ele n√£o possui tipo de retorno e deve ter o mesmo nome da classe.
10. Os m√©todos **set** s√£o utilizados para **atribuir ou alterar valores dos atributos** de uma classe. Por isso, s√£o chamados de **setters**. Seguindo a conven√ß√£o Java, se o nome do atributo for `titular`, o nome do m√©todo ser√° `setTitular(String titular)`, indicando que ele recebe um par√¢metro do mesmo tipo do atributo e modifica seu valor.
11. Os m√©todos **get** t√™m a fun√ß√£o de **acessar e retornar os valores dos atributos**. S√£o conhecidos como **getters**. De acordo com a mesma conven√ß√£o, se o atributo for `titular`, o m√©todo correspondente ser√° `getTitular()`, que n√£o recebe par√¢metros e retorna o valor atual do atributo.
12. O **encapsulamento** √© promovido ao tornar atributos privados e exp√¥-los atrav√©s de m√©todos p√∫blicos `get` e `set`, controlando o acesso aos dados internos dos objetos.
13. **Record** √© uma forma especial de classe imut√°vel, focada em representar dados.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
