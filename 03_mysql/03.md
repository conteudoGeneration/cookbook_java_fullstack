<h1>Banco de Dados Relacional com MySQL Server - Parte 02</h1>



No conte√∫do anterior, aprendemos como criar um Banco de dados e modificar a sua estrutura. Vimos ainda como criar consultas simples, inserir, atualizar e apagar dados da tabela. Neste conte√∫do, veremos como criar consultas mais elaboradas e entender como funcionam os Relacionamentos entre tabelas.

O que veremos por aqui:

1. Recriar o Banco de dados db_quitanda
2. Consultas
3. Relacionamento entre Tabelas

<br />

<h2>1. Recriar o Banco de dados db_quitanda</h2>



Antes de continuarmos, vamos recriar o Banco de dados **db_quitanda**, adicionando uma segunda tabela, chamada **tb_categorias**, que ir√° classificar os produtos por tipo (Fruta, Legumes, entre outros). O Diagrama de Entidade Relacionamentos ficar√° da seguinte forma:

<div align="center"><img src="https://i.imgur.com/tNNzcgG.png" title="source: imgur.com" width="75%"/></div>

1. Na **Barra de Ferramentas** do MySQL Workbench, crie uma nova query clicando no bot√£o <img src="https://i.imgur.com/3TvmDLp.png" title="source: imgur.com" width="7%"/> **Create new SQL Query**:

<div align="center"><img src="https://i.imgur.com/UEMsH1p.png" title="source: imgur.com" width="75%"/></div>

2. Primeiro, vamos apagar o Banco de dados **db_quitanda**, atrav√©s do c√≥digo abaixo:

```sql
DROP DATABASE db_quitanda;
```

3. Na sequ√™ncia, vamos recriar o Banco de dados **db_quitanda** com a tabela **tb_produtos**, atrav√©s do c√≥digo abaixo:

```sql
CREATE DATABASE db_quitanda;

USE db_quitanda;

CREATE TABLE tb_produtos(
    id BIGINT AUTO_INCREMENT,
	nome VARCHAR(255) NOT NULL,
	quantidade INT,
    datavalidade DATE,
	preco DECIMAL(6,2) NOT NULL,
    PRIMARY KEY (id)
);
```

4. Vamos inserir os dados na tabela **tb_produtos**, atrav√©s do c√≥digo abaixo:

```sql
INSERT INTO tb_produtos(nome, quantidade, datavalidade, preco) 
values ("tomate",100, "2023-12-15", 8.00);
INSERT INTO tb_produtos(nome, quantidade, datavalidade, preco) 
values ("ma√ß√£",20, "2023-12-15", 5.00);
INSERT INTO tb_produtos(nome, quantidade, datavalidade, preco) 
values ("laranja",50, "2023-12-15", 10.00);
INSERT INTO tb_produtos(nome, quantidade, datavalidade, preco) 
values ("banana",200, "2023-12-15", 12.00);
INSERT INTO tb_produtos(nome, quantidade, datavalidade, preco) 
values ("uva",1200, "2023-12-15", 30.00);
INSERT INTO tb_produtos(nome, quantidade, datavalidade, preco) 
values ("p√™ra",500, "2023-12-15", 2.99);
```

5. Vamos criar a tabela **tb_categorias**, atrav√©s do c√≥digo abaixo:

```sql
CREATE TABLE tb_categorias(
	id bigint AUTO_INCREMENT PRIMARY KEY,
	descricao VARCHAR(255) NOT NULL
);
```

6. Para visualizar a **Tabela tb_categorias no Banco de Dados db_quitanda**, Na janela **Navigator**, localizada no lado esquerdo da tela, clique no bot√£o **Refresh** <img src="https://imgur.com/tGmDMEL.png" title="source: imgur.com" />.

<div align="center"><img src="https://i.imgur.com/kVeQuNX.png" title="source: imgur.com" /></div>

7. Clique no tri√¢ngulo ao lado do **Banco de Dados db_quitanda**:

<div align="center"><img src="https://i.imgur.com/2pWtOoX.png" title="source: imgur.com" /></div>

8. Clique no tri√¢ngulo ao lado do item **Tables**:

<div align="center"><img src="https://i.imgur.com/qJWeXkt.png" title="source: imgur.com" width="50%"/></div>

9. Veremos as tabelas **tb_produtos** e **tb_categorias** dentro do **Banco de Dados db_quitanda**:

<div align="center"><img src="https://i.imgur.com/J58Xd5f.png" title="source: imgur.com" width="50%"/></div>

10. Na sequ√™ncia, insira os registros abaixo na Tabela **tb_categorias**:

```sql
INSERT INTO tb_categorias (descricao)
VALUES ("Frutas");

INSERT INTO tb_categorias (descricao)
VALUES ("Verduras");

INSERT INTO tb_categorias (descricao)
VALUES ("Legumes");

INSERT INTO tb_categorias (descricao)
VALUES ("Temperos");

INSERT INTO tb_categorias (descricao)
VALUES ("Ovos");

INSERT INTO tb_categorias (descricao)
VALUES ('Outros');
```

11. Execute a seguinte query abaixo, para visualizar os dados:

```sql
SELECT * FROM tb_categorias;
```

12. Observe que ap√≥s executar a query acima, voc√™ ver√° este resultado:

<div align="center"><img src="https://i.imgur.com/DtfFCAp.png" title="source: imgur.com" /></div>

<br />

<h2><img src="https://i.imgur.com/ZL3AFqF.png" title="source: imgur.com" width="5%"/> Modificando a Estrutura da Tabela - Criando o Relacionamento</h2>



Vamos revisitar o comando **ALTER** para fazer mais algumas altera√ß√µes na estrutura da nossa tabela **tb_produtos**. Precisamos criar o Relacionamento entre as Tabelas **tb_produtos** e **tb_categorias**, mas antes precisamos criar o atributo que ser√° a **Chave Estrangeira** da Tabela **tb_categorias** na Tabela **tb_produtos**, chamado **categoriaid**, atrav√©s da query abaixo:

```sql
ALTER TABLE tb_produtos ADD categoriaid BIGINT;
```

Observe que o atributo **categoriaid** possui o mesmo formato do atributo **id**, Chave Prim√°ria da Tabela **tb_categorias**.

Na sequ√™ncia, vamos adicionar uma Constraint (restri√ß√£o), indicando que o atributo **categoriaid** ser√° Chave Estrangeira (Foreign Key), da tabela **tb_categorias**:

```sql
ALTER TABLE tb_produtos ADD CONSTRAINT fk_produtos_categorias 
FOREIGN KEY (categoriaid) REFERENCES tb_categorias (id);
```

A clausula **ADD CONSTRAINT** faz parte do comando **ALTER** e tem a fun√ß√£o de adicionar uma nova **Constraint** na tabela.

> As **Constraints SQL** s√£o usadas para especificar regras para os dados em uma tabela. Elas s√£o usadas para limitar o tipo de dados que podem entrar em uma tabela, garantindo a precis√£o e a confiabilidade dos dados na tabela. 
>
> Se houver alguma viola√ß√£o entre a restri√ß√£o e a a√ß√£o de dados, a a√ß√£o ser√° abortada. As restri√ß√µes podem ser n√≠vel de coluna ou n√≠vel de tabela. As restri√ß√µes de n√≠vel de coluna se aplicam a uma coluna e as restri√ß√µes de n√≠vel de tabela se aplicam a toda a tabela.
>
> **Exemplos:** `PRIMARY KEY`, `FOREIGN KEY`, entre outras.

A clausula **FOREIGN KEY** faz parte do comando **ALTER** e tem a fun√ß√£o de indicar o atributo que ser√° **Chave Estrangeira** da tabela.

A clausula **REFERENCES** faz parte do comando **ALTER** e tem a fun√ß√£o de indicar a tabela e o atributo que ser√° relacionado com a **Chave Estrangeira** da tabela.

Execute a query abaixo para visualizar Tabela **tb_produtos**:

```sql
SELECT * FROM tb_produtos;
```

Observe que ap√≥s executar a query acima, Tabela **tb_produtos** ganhou um novo atributo (**categoriaid**):

<div align="center"><img src="https://i.imgur.com/ar3Ptge.png" title="source: imgur.com" /></div>

<br />

<div align="left"><img src="https://i.imgur.com/38hZn7Z.png" title="source: imgur.com" width="25px"/> <a href="https://www.w3schools.com/sql/sql_foreignkey.asp" target="_blank"><b>Documenta√ß√£o: <i>Foreign key - W3Schools</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/38hZn7Z.png" title="source: imgur.com" width="25px"/> <a href="https://www.w3schools.com/sql/sql_alter.asp" target="_blank"><b>Documenta√ß√£o: <i>Alter Table - W3Schools</i></b></a></div>

<br />

Para finalizar, vamos atualizar os dados das 6 linhas da nossa Tabela **tb_produtos**, preenchendo o atributo **categoriaid**:

```sql
UPDATE tb_produtos SET categoriaid = 3 WHERE id = 1;
UPDATE tb_produtos SET categoriaid = 1 WHERE id = 2;
UPDATE tb_produtos SET categoriaid = 1 WHERE id = 3;
UPDATE tb_produtos SET categoriaid = 1 WHERE id = 4;
UPDATE tb_produtos SET categoriaid = 1 WHERE id = 5;
UPDATE tb_produtos SET categoriaid = 1 WHERE id = 6;
```

<br />

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="120px"/> | <div align="left"> **ALERTA DE BSM:** *Mantenha a Aten√ß√£o aos Detalhes ao atualizar os dados da Tabela tb_produtos. Um erro muito comum √© inserir um id na Chave Estrangeira que n√£o existe na Chave Prim√°ria da Tabela tb_categorias. Lembre-se que devido ao Relacionamento, o atributo categoriaid aceitar√° um id apenas se ele existir na Tabela tb_categorias.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

Vamos Inserir mais alguns registros na Tabela **tb_produtos**:

```sql
INSERT INTO tb_produtos (nome, quantidade, datavalidade, preco, categoriaid)
VALUES ("Batata doce", 2000, "2022-03-09", 10.00, 3);

INSERT INTO tb_produtos (nome, quantidade, datavalidade, preco, categoriaid)
VALUES ("Alface", 300, "2022-03-10", 7.00, 2);

INSERT INTO tb_produtos (nome, quantidade, datavalidade, preco, categoriaid)
VALUES ("Cebola", 1020, "2022-03-08", 5.00, 3);

INSERT INTO tb_produtos (nome, quantidade, datavalidade, preco, categoriaid)
VALUES("Ovo Branco", 1000, "2022-03-07", 15.00, 5);

INSERT INTO tb_produtos (nome, quantidade, datavalidade, preco, categoriaid)
VALUES("Agri√£o", 1500, "2022-03-06", 3.00, 2);

INSERT INTO tb_produtos (nome, quantidade, datavalidade, preco, categoriaid)
VALUES("Cenoura", 1800, "2022-03-09", 3.50, 3);

INSERT INTO tb_produtos (nome, quantidade, datavalidade, preco, categoriaid)
VALUES ("Pimenta", 1100, "2022-03-15", 10.00, 4);

INSERT INTO tb_produtos (nome, quantidade, datavalidade, preco, categoriaid)
VALUES ("Alecrim", 130, "2022-03-10", 5.00, 4);

INSERT INTO tb_produtos (nome, quantidade, datavalidade, preco, categoriaid)
VALUES ("Manga", 200, "2022-03-07", 5.49, 1);

INSERT INTO tb_produtos (nome, quantidade, datavalidade, preco, categoriaid)
VALUES ("Couve", 100, "2022-03-12", 1.50, 2);

INSERT INTO tb_produtos (nome, quantidade, datavalidade, preco, categoriaid)
VALUES("Rabanete", 1200, "2022-03-15", 13.00, 3);

INSERT INTO tb_produtos (nome, quantidade, datavalidade, preco, categoriaid)
VALUES ("Grapefruit", 3000, "2022-03-13", 50.00, 1);

INSERT INTO tb_produtos (nome, quantidade, preco)
VALUES("Sacola Cinza", 1118, 0.50);

INSERT INTO tb_produtos (nome, quantidade, preco)
VALUES("Sacola Verde", 1118, 0.50);
```

Para verificar como a tabela ficou, execute a seguinte query:

```sql
SELECT * FROM tb_produtos;
```

Observe que ap√≥s executar a query acima, Tabela **tb_produtos** passou a ter 20 registros:

<div align="center"><img src="https://i.imgur.com/QwcMoOK.png" title="source: imgur.com" /></div>

Vamos conhecer mais algumas op√ß√µes do comando **SELECT**.

<br />

<h2>2. Consultas</h2>

<br />

<h2><img src="https://i.imgur.com/ZL3AFqF.png" title="source: imgur.com" width="30px"/>Selecionando dados e ordenando</h2>



Al√©m de consultar, n√≥s tamb√©m podemos ordenar os registros de acordo com um campo desejado. Para ordenar os dados, utilizamos clausula **ORDER BY** no final do comando SELECT, seguido pelo(s) atributo(s) que se deseja utilizar como crit√©rio(s) de ordena√ß√£o. Em seguida, adicione a clausula **ASC** para ordenar de forma Crescente ou **DESC** para ordenar de forma Decrescente. 

<br />

| <img src="https://i.imgur.com/RfjtOFi.png" title="source: imgur.com" width="100px"/> | <div align="left">**DICA:** *Caso voc√™ n√£o acrescente as Clausulas ASC ou DESC, o MySQL ir√° considerar a ordena√ß√£o Crescente com a ordena√ß√£o padr√£o.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<h4>SELECT com ORDER BY</h4>

```sql
SELECT * FROM tb_produtos ORDER BY nome ASC;
```

Ao executar a query, observe que todos os dados da tabela estar√£o ordenados pelo nome do produto, em ordem crescente:

<div align="center"><img src="https://i.imgur.com/GX4tqSw.png" title="source: imgur.com" /></div>

<br />

```sql
SELECT * FROM tb_produtos ORDER BY nome DESC;
```

Ao executar a query, observe que todos os dados da tabela estar√£o ordenados pelo nome do produto, em ordem decrescente:

<div align="center"><img src="https://i.imgur.com/CFXe14u.png" title="source: imgur.com" /></div>

Voc√™ tamb√©m pode ordenar por 2 ou mais campos da tabela. Na consulta abaixo, a tabela ser√° ordenada por ordem de nome e preco:

```sql
SELECT * FROM tb_produtos ORDER BY nome, preco ASC;
```

<br />

<div align="left"><img src="https://i.imgur.com/38hZn7Z.png" title="source: imgur.com" width="25px"/> <a href="https://www.w3schools.com/sql/sql_orderby.asp" target="_blank"><b>Documenta√ß√£o: <i>Order By - W3Schools</i></b></a></div>

<br />

<h2><img src="https://i.imgur.com/ZL3AFqF.png" title="source: imgur.com" width="30px"/>Selecionando dados dentro de uma lista de crit√©rios</h3>


Procurar v√°rios registros utilizando uma lista de crit√©rios de busca na clausula **WHERE**, ao inv√©s utilizarmos v√°rios **Operadores L√≥gicos OR**, podemos simplificar esta consulta, atrav√©s do operador **IN**.

**Exemplo**: Queremos retornar todos os produtos cujo pre√ßo seja igual a R$ 5,00, R$ 10,00 ou R$ 15,00. Nesse caso executamos a seguinte query: 

<h4>SELECT com o operador IN</h4>

```sql
SELECT * FROM tb_produtos WHERE preco IN (5.00, 10.00, 15.00);
```

Ao executar a query, observe que todos os dados da tabela cujo pre√ßo seja igual a R$ 5,00, R$ 10,00 ou R$ 15,00 ser√£o exibidos:

<div align="center"><img src="https://i.imgur.com/eFrNQqg.png" title="source: imgur.com" /></div>

<br />

<div align="left"><img src="https://i.imgur.com/38hZn7Z.png" title="source: imgur.com" width="25px"/> <a href="https://www.w3schools.com/sql/sql_in.asp" target="_blank"><b>Documenta√ß√£o: <i>In - W3Schools</i></b></a></div>

<br />

<h2><img src="https://i.imgur.com/ZL3AFqF.png" title="source: imgur.com" width="30px"/>Selecionando dados dentro de um intervalo</h2>



Quando desejamos procurar valores que est√£o dentro de um intervalo de valores, ao inv√©s utilizarmos os **Operadores Relacionais > e <** em conjunto com o **Operador L√≥gico AND**, utilizamos o operador **BETWEEN**. Esses valores podem ser n√∫mero, texto ou data. 

**Exemplo**: queremos retornar todos os produtos que tem o seu pre√ßo **ENTRE** R$ 5,00 e R$ 15,00. Nesse caso executamos a seguinte query: 

<h4>SELECT com o operador BETWEEN</h4>

```sql
SELECT * FROM tb_produtos WHERE preco BETWEEN 5.00 AND 15.00;
```

Ao executar a query, observe que todos os dados da tabela cujo pre√ßo esteja entre R$ 5,00 e R$ 15,00 ser√£o exibidos:

<div align="center"><img src="https://i.imgur.com/sqy4nqQ.png" title="source: imgur.com" /></div>

<br />

<div align="left"><img src="https://i.imgur.com/38hZn7Z.png" title="source: imgur.com" width="25px"/> <a href="https://www.w3schools.com/sql/sql_between.asp" target="_blank"><b>Documenta√ß√£o: <i>Between - W3Schools</i></b></a></div>

<br />

<h2><img src="https://i.imgur.com/ZL3AFqF.png" title="source: imgur.com" width="30px"/>Selecionando dados que contenham um texto espec√≠fico (Busca textual)</h2>



Quando desejamos procurar um padr√£o de texto especifico em uma coluna, usamos o comando **LIKE**. Esse comando √© utilizado em conjunto com os caracteres "**coringa (wildcards)**": **(%)** e **(_)**. Esse tipo de busca √© muito comum na Internet, quando desejamos buscar um produto pelo nome por exemplo.

| Padr√£o      | Descri√ß√£o                                                    |
| ----------- | ------------------------------------------------------------ |
| **%texto**  | O conte√∫do procurado deve terminar com o texto digitado (texto) |
| **texto%**  | O conte√∫do procurado deve come√ßar com o texto digitado (texto) |
| **%texto%** | O conte√∫do procurado deve conter o texto digitado (texto) em qualquer posi√ß√£o (inicio, meio ou fim do texto). |

**Exemplo**: Queremos retornar todos os produtos que contenham a s√≠laba "**ra**". Nesse caso executamos a seguinte query: 

<h4>SELECT com o operador LIKE</h4>

```sql
SELECT * FROM tb_produtos WHERE nome LIKE "%ra%";
```

Ao executar a query, observe que todos os dados da tabela cujo nome possua em qualquer parte a s√≠laba **ra** ser√£o exibidos:

<div align="center"><img src="https://i.imgur.com/JSdl8PV.png" title="source: imgur.com" /></div>

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="120px"/> | **IMPORTANTE:** O MySQL n√£o faz diferen√ßa entre letras mai√∫sculas e min√∫sculas, entretanto existem alguns Banco de dados Relacionais que diferenciam. Veja abaixo como descobrir se o Banco de dados √© Case Sensitive ou Case Insensitive? |
| ------------------------------------------------------------ | :----------------------------------------------------------- |

<br />

> **Meu Banco de dados √© Case Sensitive ou Case Insensitive?**
>
> **Case Sensitive (CS)** √© o nome dado para o Banco de dados que diferencia letras mai√∫sculas de letras min√∫sculas. 
>
> **Case Insensitive (CI)** √© o nome dado para o Banco de dados que n√£o diferencia letras mai√∫sculas de letras min√∫sculas.
>
> **Accent Sensitive (AS)** √© o nome dado para o Banco de dados que diferencia caracteres acentuados.
>
> **Accent Insensitive (AI)** √© o nome dado para o Banco de dados que n√£o diferencia caracteres acentuados. 
>
> Para descobrir como o seu Banco de dados trabalha com strings, voc√™ precisa descobrir qual √© a **Collation** dele. A **Collation** nada mais √© do que a forma como os caracteres s√£o codificados e como o Banco de dados os interpreta. 
>
> Para descobrir qual √© a Collation do Banco de dados **db_quitanda** no MySQL, vamos utilizar a query abaixo:
>
> ```sql
> SELECT @@collation_database;
> ```
>
> O resultado voc√™ confere abaixo:
>
> <div align="center"><img src="https://i.imgur.com/PfUzWHV.png" title="source: imgur.com" /></div>
>
> Observe as duas siglas no final da Collation:
>
> - **CI ü°¢ Case Insensitive**
> - **AI ü°¢ Accent Insensitive**
>
> O Nosso Banco de dados **n√£o diferencia letras mai√∫sculas de letras min√∫sculas (CI)** e **n√£o diferencia caracteres acentuados e n√£o acentuados (AI)**.

<br />

| <img src="https://i.imgur.com/RfjtOFi.png" title="source: imgur.com" width="100px"/> | <div align="left">**DICA:** *A estrat√©gia para retornar qualquer produto, onde em qualquer parte do seu nome possua um determinado texto, seja no come√ßo ou no fim (`"%texto%"`), √© a mais utilizada.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<div align="left"><img src="https://i.imgur.com/38hZn7Z.png" title="source: imgur.com" width="25px"/> <a href="https://www.w3schools.com/sql/sql_like.asp" target="_blank"><b>Documenta√ß√£o: <i>Like - W3Schools</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/38hZn7Z.png" title="source: imgur.com" width="25px"/> <a href="https://dev.mysql.com/doc/refman/8.0/en/charset-unicode-sets.html" target="_blank"><b>Documenta√ß√£o: <i>Collation - MySQL</i></b></a></div>

<br />

<h2><img src="https://i.imgur.com/ZL3AFqF.png" title="source: imgur.com" width="30px"/>Selecionando dados com Fun√ß√µes Matem√°ticas</h2>



As vezes precisamos efetuar c√°lculos em uma tabela como a m√©dia de pre√ßo, ou encontrar o produto com o maior pre√ßo, ou com o menor pre√ßo, para analisarmos os dados da nossa tabela. O SQL nos oferece algumas fun√ß√µes, que retornam estas informa√ß√µes de um modo simples e direto. Veja na tabela abaixo:

| Operador            | Descri√ß√£o                                                    |
| ------------------- | ------------------------------------------------------------ |
| **COUNT(atributo)** | Conta quantas linhas n√£o nulas um atributo possui. **COUNT(*)** indica o n√∫mero de linhas da tabela. |
| **AVG(atributo)**   | Calcula a m√©dia dos valores de um atributo.                  |
| **SUM(atributo)**   | Calcula a soma dos valores de um atributo.                   |
| **MAX(atributo)**   | Encontra o maior valor nas linhas de um atributo.            |
| **MIN(atributo)**   | Encontra o menor valor nas linhas de um atributo.            |

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="120px"/> | **IMPORTANTE:** Estas s√£o as fun√ß√µes mais utilizadas, que o SQL nos oferece. Se voc√™ consultar a documenta√ß√£o ver√°s que existe muitas outras fun√ß√µes, que trabalham n√£o somente com n√∫meros, mas com datas e strings tamb√©m. |
| ------------------------------------------------------------ | :----------------------------------------------------------- |

<br />

**Exemplo**: Desejamos calcular a m√©dia de pre√ßo de todos os produtos. Nesse caso executamos a seguinte query:

<h4>SELECT com fun√ß√µes</h4>

```sql
SELECT AVG(Preco) AS Media FROM tb_produtos;
```

A clausula **AS** √© parte integrante do comando **SELECT** e tem a fun√ß√£o de criar um apelido (alias) para o resultado da fun√ß√£o, que na pr√°tica funcionar√° como o t√≠tulo da coluna que exibir√° os c√°lculos.

O resultado da query ser√° exibido logo abaixo:

<div align="center"><img src="https://i.imgur.com/cQMGiHW.png" title="source: imgur.com" /></div>

Observe que foi calculado o pre√ßo m√©dio de todos os produtos.

<br />

<div align="left"><img src="https://i.imgur.com/38hZn7Z.png" title="source: imgur.com" width="25px"/> <a href="https://www.w3schools.com/sql/sql_count_avg_sum.asp#gsc.tab=0" target="_blank"><b>Documenta√ß√£o: <i>Fun√ß√µes COUNT(), AVG() e SUM() - W3Schools</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/38hZn7Z.png" title="source: imgur.com" width="25px"/> <a href="https://www.w3schools.com/sql/sql_min_max.asp" target="_blank"><b>Documenta√ß√£o: <i>Fun√ß√µes MIN() e MAX() - W3Schools</i></b></a></div>

<br />

<h2>3. Relacionamento entre Tabelas</h2>



Como vimos anteriormente, a principal caracter√≠stica de um Banco de dados Relacional √© a capacidade definir Relacionamentos entre as tabelas de acordo com as necessidades. Os Relacionamentos, al√©m de otimizar o Banco de dados, ele tamb√©m ajuda a evitar a duplicidade de dados, o que gera diversos problemas de consist√™ncia das informa√ß√µes. 

Os Relacionamentos s√£o classificados de acordo com a quantidade de objetos envolvidos em cada lado da rela√ß√£o, de  tr√™s formas diferentes:

- **Relacionamento 1‚Ä¶1 (um para um):** Cada uma das duas entidades envolvidas referenciam obrigatoriamente apenas uma unidade da outra. **Exemplo:** Em um Banco de dados de curr√≠culos, cada usu√°rio cadastrado pode cadastrar apenas um curr√≠culo e cada curr√≠culo s√≥ pode pertencer a um √∫nico usu√°rio cadastrado.
- **Relacionamento 1‚Ä¶n (um para muitos):** Uma das entidades envolvidas pode referenciar v√°rias unidades da outra, por√©m, do outro lado cada uma das v√°rias unidades referenciadas s√≥ pode estar ligada a uma unidade da outra entidade. **Exemplo:** Em um sistema de plano de sa√∫de, um usu√°rio pode ter v√°rios dependentes, mas cada dependente s√≥ pode estar ligado a um usu√°rio principal.
- **Relacionamento n‚Ä¶n (muitos para muitos):** Cada entidade, de ambos os lados, podem  referenciar m√∫ltiplas unidades da outra. **Exemplo:** Em um sistema de  biblioteca, um livro pode ser escrito por v√°rios autores, ao mesmo  tempo em que um autor pode escrever v√°rios livros. Assim, um autor pode referenciar m√∫ltiplos livros, e vice  versa.

Observe no DER abaixo, que a tabela **tb_categorias** est√° relacionda com a tabela **tb_produtos**, em um Relacionamento do tipo 1:N, onde uma Categoria pode ter N produtos e N Produtos podem ter apenas 1 Categoria.

<div align="center"><img src="https://i.imgur.com/tNNzcgG.png" title="source: imgur.com" width="75%"/></div>

Quando trabalhamos com Banco de dados, uma das opera√ß√µes mais realizadas, indiscutivelmente √© a consulta a dados. Nos exemplos anteriores, voc√™ deve ter notado que a tabela **tb_produtos** exibe apenas o c√≥digo da categoria associada, entretanto em uma busca, o usu√°rio n√£o √© obrigado a saber qual categoria o c√≥digo representa. Para criar uma consulta que mostre a rela√ß√£o entre as tabelas, vamos precisar de um tipo de consulta especial, chamado **JOIN**. 

Consultas do tipo **JOIN** podem ser utilizadas para diversas finalidades, como por exemplo, converter em informa√ß√£o os dados encontrados em duas ou mais tabelas. A cl√°usula **JOIN** √© usada para combinar dados provenientes de duas ou mais tabelas do banco de dados, baseado em um relacionamento entre as colunas das duas tabelas. Existem tr√™s categorias principais de **JOIN**:

<h4>INNER JOIN</h4>

<div align="center"><img src="https://i.imgur.com/xMAxZMf.png" title="source: imgur.com" width="70%"/></div>

Nas consultas do tipo **INNER JOIN**, o resultado trar√° somente as linhas que sejam comuns nas 2 tabelas, associadas atrav√©s das Chaves Prim√°ria e Estrangeira, ou seja, se a Chave Estrangeira estiver com um valor NULL (nulo), esse registro n√£o ser√° exibido. Veja o exemplo abaixo:

```sql
SELECT nome, preco, quantidade, tb_categorias.descricao
FROM tb_produtos INNER JOIN tb_categorias 
ON tb_produtos.categoriaid = tb_categorias.id;
```

O resultado da query ser√° exibido logo abaixo:

<div align="center"><img src="https://i.imgur.com/LYv5dhM.png" title="source: imgur.com" /></div><br />

Observe que a consulta nos trouxe apenas 18 produtos, porque 2 produtos (**sacola verde e sacola cinza**), n√£o possuem rela√ß√£o com nenhuma categoria da tabela tb_categorias. A categoria **outros** tamb√©m n√£o est√° aparecendo na consulta, porque n√£o existe nenhum produto associado a esta categoria.

<br />

<div align="left"><img src="https://i.imgur.com/38hZn7Z.png" title="source: imgur.com" width="25px"/> <a href="https://www.w3schools.com/sql/sql_join_inner.asp" target="_blank"><b>Documenta√ß√£o: <i>Inner Join - W3Schools</i></b></a></div>

<br />

<h4>LEFT JOIN</h4>

<div align="center"><img src="https://i.imgur.com/SHUpMvm.png" title="source: imgur.com" width="70%"/></div>

Nas consultas do tipo **LEFT JOIN** o resultado trar√° al√©m das linhas que s√£o comuns nas 2 tabelas, associadas atrav√©s das Chaves Prim√°ria e Estrangeira, tamb√©m trar√° os dados n√£o associados da tabela do lado esquerdo da rela√ß√£o, ou seja, independente da Chave Estrangeira estar ou n√£o com um valor NULL (nulo), todos os registros da tabela do lado esquerdo da rela√ß√£o ser√£o exibidos. Veja o exemplo abaixo:

```sql
SELECT nome, preco, quantidade, tb_categorias.descricao
FROM tb_produtos LEFT JOIN tb_categorias 
ON tb_produtos.categoriaid = tb_categorias.id;
```

O resultado da query ser√° exibido logo abaixo:

<div align="center"><img src="https://i.imgur.com/lfBKxlv.png" title="source: imgur.com" /></div><br />

Observe que a consulta nos trouxe os 20 produtos, independente de ter ou n√£o rela√ß√£o com alguma categoria da tabela tb_categorias. A categoria **outros** n√£o est√° aparecendo na consulta, porque esta consulta foca na tabela do lado esquerdo (tb_produtos).

<br />

<br />

<div align="left"><img src="https://i.imgur.com/38hZn7Z.png" title="source: imgur.com" width="25px"/> <a href="https://www.w3schools.com/sql/sql_join_left.asp" target="_blank"><b>Documenta√ß√£o: <i>Left Join - W3Schools</i></b></a></div>

<br />

<h4>RIGHT JOIN</h4>

<div align="center"><img src="https://i.imgur.com/jXMJ0zE.png" title="source: imgur.com" width="70%"/></div>

Nas consultas do tipo **RIGHT JOIN** o resultado trar√° al√©m das linhas que s√£o comuns nas 2 tabelas, associadas atrav√©s das Chaves Prim√°ria e Estrangeira, tamb√©m trar√° os dados n√£o associados da tabela do lado direito da rela√ß√£o, ou seja, independente da Chave Estrangeira estar ou n√£o com um valor NULL (nulo), todos os registros da tabela do lado direito da rela√ß√£o ser√£o exibidos. Veja o exemplo abaixo:

```sql
SELECT nome, preco, quantidade, tb_categorias.descricao
FROM tb_produtos RIGHT JOIN tb_categorias 
ON tb_produtos.categoriaid = tb_categorias.id;
```

<br />

<div align="center"><img src="https://i.imgur.com/uAgkrlV.png" title="source: imgur.com" /></div>

Observe que a consulta nos trouxe apenas 18 produtos, porque 2 produtos (**sacola verde e sacola cinza**), n√£o possuem rela√ß√£o com nenhuma categoria da tabela tb_categorias. Entretanto, desta vez a categoria **outros** est√° aparecendo na consulta, independente de existir ou n√£o algum produto associado a esta categoria, porque esta consulta foca na tabela do lado direito (tb_categorias).

<br />

<div align="left"><img src="https://i.imgur.com/38hZn7Z.png" title="source: imgur.com" width="25px"/> <a href="https://www.w3schools.com/sql/sql_join_right.asp" target="_blank"><b>Documenta√ß√£o: <i>Right Join - W3Schools</i></b></a><br /></div>

<br />

Existem outros tipos de **JOIN**, entretanto, os 3 explicados acima s√£o os mais utilizados.

> **Quem √© a tabela da Direita e quem √© a tabela da Esquerda?**
>
> - **Esquerda ü°¢ Tabela que possui a Chave Estrangeira**
> - **Direita ü°¢ Tabela que n√£o possui a Chave Estrangeira**

A Tabela que n√£o possui a Chave Estrangeira (**tb_categorias**), √© a Tabela que manda na rela√ß√£o, pois caso uma categoria seja exclu√≠da, a exist√™ncia dos produtos desta categoria deixam de fazer sentido. **Exemplo:** Se a Quitanda decidiu n√£o vender mais frutas, n√£o faz sentido apagar a categoria frutas e manter todos os produtos da categoria frutas no Banco de dados.

<br />


<h2><img src="https://i.imgur.com/ZL3AFqF.png" title="source: imgur.com" width="30px"/>Selecionando dados e Agrupando</h2>



As vezes precisamos pesquisar dados e agrupar estas informa√ß√µes por algum crit√©rio, como por exemplo encontra a m√©dia de pre√ßo dos produtos, agrupados por categoria, ou seja, a m√©dia do pre√ßo por categoria. Para criarmos esta consulta, utilizaremos a clausula **GROUP BY**, onde indicaremos por qual atributo queremos agrupar os dados.

<h4>SELECT com GROUP BY</h4>

```sql
SELECT tb_categorias.descricao, AVG(preco) AS Pre√ßo_M√©dio
FROM tb_produtos INNER JOIN tb_categorias 
ON tb_categorias.Id = tb_produtos.categoriaId
GROUP BY tb_categorias.descricao;
```

O resultado da query ser√° exibido logo abaixo:

<div align="center"><img src="https://i.imgur.com/Yy3kH6s.png" title="source: imgur.com" /></div>

Observe que a consulta retornou o Pre√ßo M√©dio dos produtos por categoria, ou seja, agrupou todos os produtos de uma categoria, calculou a m√©dia e repetiu os processo com todas as outras categorias.

<br />

<div align="left"><img src="https://i.imgur.com/38hZn7Z.png" title="source: imgur.com" width="25px"/> <a href="https://www.w3schools.com/sql/sql_groupby.asp" target="_blank"><b>Documenta√ß√£o: <i>Group By - W3Schools</i></b></a></div>

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
