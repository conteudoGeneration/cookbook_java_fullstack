<h1>Teste de Software com JUnit 5 - Teste da Classe Controller</h1>

<br />

Vamos avan√ßar na cria√ß√£o dos testes estruturando tr√™s classes fundamentais:

- A **classe utilit√°ria `TestBuilder`**, que centraliza a cria√ß√£o de objetos de teste com dados simulados (mocks), facilitando a **reutiliza√ß√£o** e garantindo maior **organiza√ß√£o** no c√≥digo de testes;
- A **classe utilit√°ria `JwtHelper`**, respons√°vel por gerar e manipular tokens JWT durante os testes;
- E a **classe de testes `UsuarioControllerTest`**, onde validaremos, de forma automatizada, o comportamento dos endpoints do recurso **Usuario** na camada de **controller**.

Com essa estrutura, os testes ficam mais limpos, objetivos e f√°ceis de manter, al√©m de promoverem uma melhor separa√ß√£o de responsabilidades e maior efici√™ncia no desenvolvimento.

<br />

<h2>üë£Passo 01 - Criar a Classe Utilit√°ria TestBuilder</h2>



A classe **TestBuilder** √© um utilit√°rio dedicado a facilitar a cria√ß√£o de inst√¢ncias para testes, especialmente das classes *Model* relacionadas ao recurso **Usu√°rio**.

Ela fornece m√©todos est√°ticos que constroem objetos j√° configurados com os dados necess√°rios, simplificando a escrita e manuten√ß√£o dos testes.

No exemplo abaixo, a classe possui dois m√©todos:

- `criarUsuario(Long id, String nome, String usuario, String senha)` ‚Äî cria e retorna um objeto `Usuario` com os atributos preenchidos, al√©m de definir uma foto padr√£o.
- `criarUsuarioLogin(String usuario, String senha)` ‚Äî cria e retorna um objeto `UsuarioLogin` configurado com o email e senha para simular dados de login.

Essa abordagem modular permite reutilizar facilmente objetos de teste e facilita a adi√ß√£o de novos m√©todos para outras classes *Model* conforme a necessidade de testar novos recursos.

Crie a classe **TestBuilder** no pacote **util**, localizado na Source Folder de testes (**src/test/java**):

1. No lado esquerdo superior, na Guia **Package Explorer**, clique com o bot√£o direito do mouse sobre a Package **com.generation.blogpessoal.util**, na Source Folder **src/test/java** e clique na op√ß√£o  **New ü°™ Class**.

2. Na janela **New Java Class**, no item **Name**, informe o nome da Classe Utilit√°ria **TestBuilder**, como mostra a figura abaixo:

<div align="center"><img src="https://i.imgur.com/1XqwEit.png" title="source: imgur.com" width="65%"/></div>

3. Clique no bot√£o **Finish** para concluir.
4. Na sequ√™ncia, adicione o c√≥digo abaixo:

```java
package com.generation.blogpessoal.util;

import com.generation.blogpessoal.model.Usuario;
import com.generation.blogpessoal.model.UsuarioLogin;

public class TestBuilder {
	public static Usuario criarUsuario(Long id, String nome, String usuario, String senha) {
		Usuario novoUsuario = new Usuario();
		novoUsuario.setId(id);
		novoUsuario.setNome(nome);
		novoUsuario.setUsuario(usuario);
		novoUsuario.setSenha(senha);
		novoUsuario.setFoto("-");
		return novoUsuario;
	}

	public static UsuarioLogin criarUsuarioLogin(String usuario, String senha) {
		UsuarioLogin usuarioLogin = new UsuarioLogin();
		usuarioLogin.setUsuario(usuario);
		usuarioLogin.setSenha(senha);
		return usuarioLogin;
	}
}
```

Vamos analisar o c√≥digo:

<div align="center"><img src="https://i.imgur.com/a6KDauO.png" title="source: imgur.com" /></div>

**Linhas 7 a 15:** Criamos o M√©todo **criarUsuario**, que ser√° respons√°vel por criar objetos da Classe Usuario. Observe que na pr√°tica, est√° sendo criado um objeto padr√£o da Classe Usuario, ou seja, vazio, e atrav√©s dos m√©todos set, os dados est√£o sendo preenchidos com os par√¢metros do m√©todo.

**Linhas 17 a 21:** Criamos o M√©todo **criarUsuarioLogin**, que ser√° respons√°vel por criar objetos da Classe UsuarioLogin. Observe que na pr√°tica, est√° sendo criado um objeto padr√£o da Classe UsuarioLogin, ou seja, vazio, e atrav√©s dos m√©todos set, os dados est√£o sendo preenchidos com os par√¢metros do m√©todo.

<br />

üíæ **Salve as altera√ß√µes antes de prosseguir ( File ü°™ Save All )!**

<br />

<h2>üë£Passo 02 - Criar a Classe Utilit√°ria JwtHelper</h2>



A classe **JwtHelper** √© um utilit√°rio criado para facilitar a manipula√ß√£o de tokens JWT em testes de integra√ß√£o, especialmente quando se utiliza o `TestRestTemplate` do Spring Boot.

Ela oferece m√©todos est√°ticos que simplificam tanto a autentica√ß√£o quanto a cria√ß√£o de requisi√ß√µes HTTP com o token JWT apropriado, tornando os testes mais leg√≠veis, consistentes e f√°ceis de manter.

No exemplo abaixo, a classe apresenta tr√™s m√©todos principais:

- `obterToken(TestRestTemplate testRestTemplate, String usuario, String senha)` ‚Äî simula o login enviando uma requisi√ß√£o POST ao endpoint `/usuarios/logar` com as credenciais fornecidas e retorna o token JWT presente na resposta. Caso o login seja inv√°lido, lan√ßa uma exce√ß√£o adequada.
- `criarRequisicaoComToken(T body, String token)` ‚Äî cria uma inst√¢ncia de `HttpEntity<T>` que encapsula o corpo da requisi√ß√£o e adiciona o token JWT no cabe√ßalho `Authorization` no formato Bearer, para ser usada em chamadas autenticadas que exigem envio de dados (POST, PUT, entre outras).
- `criarRequisicaoComToken(String token)` ‚Äî varia√ß√£o do m√©todo anterior para requisi√ß√µes sem corpo (GET, DELETE, entre outras), retornando um `HttpEntity<Void>` com o token JWT no cabe√ßalho.

Essa abordagem modular promove o reaproveitamento da l√≥gica de autentica√ß√£o e o envio de requisi√ß√µes autorizadas nos testes, al√©m de possibilitar futuras extens√µes para outras opera√ß√µes relacionadas a JWT.

<br />

### Classes e m√©todos do Spring Framework utilizados para testes



Para criar e manipular as requisi√ß√µes e respostas HTTP nos testes, utilizamos classes e m√©todos do **Spring Framework**, que facilitam a execu√ß√£o dos testes focados no comportamento dos endpoints da aplica√ß√£o:

| Classe / M√©todo / Conceito      | Descri√ß√£o                                                    |
| ------------------------------- | ------------------------------------------------------------ |
| **TestRestTemplate**            | Cliente HTTP para testes de integra√ß√£o em Spring Boot, facilita o envio de requisi√ß√µes REST para os endpoints da aplica√ß√£o. |
| **HttpEntity <T>**              | Representa a entidade HTTP com corpo (`body`) e cabe√ßalhos (`headers`), usada para compor requisi√ß√µes com dados. |
| **ResponseEntity <T>**          | Extens√£o de `HttpEntity` que inclui o status HTTP da resposta, encapsulando corpo, cabe√ßalhos e status. |
| **HttpHeaders**                 | Classe que gerencia os cabe√ßalhos HTTP, usada para adicionar campos como `Authorization` com tokens Bearer. |
| **HttpMethod**                  | Enumera√ß√£o que representa os m√©todos HTTP (`GET`, `POST`, `PUT`, `DELETE`, entre outros.) utilizados em requisi√ß√µes. |
| **TestRestTemplate.exchange()** | M√©todo que executa requisi√ß√µes HTTP flex√≠veis, recebendo URL, m√©todo, `HttpEntity` com corpo e cabe√ßalhos, e tipo de retorno esperado. |
| **Bearer Token**                | Padr√£o de autentica√ß√£o que inclui o token JWT no cabe√ßalho `Authorization` com o prefixo `Bearer`, para autoriza√ß√£o de acesso. |

<br />

Crie a classe **JwtHelper** no pacote **util**, localizado na Source Folder de testes (**src/test/java**):

1. No lado esquerdo superior, na Guia **Package Explorer**, clique com o bot√£o direito do mouse sobre a Package **com.generation.blogpessoal.util**, na Source Folder **src/test/java** e clique na op√ß√£o  **New ü°™ Class**.

2. Na janela **New Java Class**, no item **Name**, informe o nome da Classe Utilit√°ria **JwtHelper**, como mostra a figura abaixo:

<div align="center"><img src="https://i.imgur.com/caU6b53.png" title="source: imgur.com" width="70%"/></div>

3. Clique no bot√£o **Finish** para concluir.
4. Na sequ√™ncia, adicione o c√≥digo abaixo:

```java
package com.generation.blogpessoal.util;

import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;

import com.generation.blogpessoal.model.UsuarioLogin;

public class JwtHelper {
    
    private JwtHelper() {}
    
    public static String obterToken(TestRestTemplate testRestTemplate, String email, String senha) {
        UsuarioLogin login = TestBuilder.criarUsuarioLogin(email, senha);
        HttpEntity<UsuarioLogin> request = new HttpEntity<>(login);
        
        ResponseEntity<UsuarioLogin> response = testRestTemplate
            .exchange("/usuarios/logar", HttpMethod.POST, request, UsuarioLogin.class);
        
        UsuarioLogin body = response.getBody();
        if (body != null && body.getToken() != null) {
            return body.getToken();
        }
        
        throw new RuntimeException("Falha no login: " + email);
    }
    
    public static <T> HttpEntity<T> criarRequisicaoComToken(T body, String token) {
        HttpHeaders headers = new HttpHeaders();
        String tokenLimpo = token.startsWith("Bearer ") ? token.substring(7) : token;
        headers.setBearerAuth(tokenLimpo);
        return new HttpEntity<>(body, headers);
    }
    
    public static HttpEntity<Void> criarRequisicaoComToken(String token) {
        return criarRequisicaoComToken(null, token);
    }
}
```

Vamos analisar o c√≥digo:

<div align="center"><img src="https://i.imgur.com/nsKjcJD.png" title="source: imgur.com" /></div>

**Linha 01:**  Define o pacote onde a classe `JwtHelper` est√° localizada.

**Linhas 03 a 10:** Importa as classes necess√°rias para fazer requisi√ß√µes HTTP de teste e manipular objetos relacionados ao login do usu√°rio.

**Linha 11:** Declara a classe p√∫blica chamada `JwtHelper`, que cont√©m m√©todos auxiliares para trabalhar com JWT nos testes.

**Linha 13:** Construtor privado que impede a cria√ß√£o de inst√¢ncias dessa classe, pois ela √© apenas um utilit√°rio com m√©todos est√°ticos.

<div align="center"><img src="https://i.imgur.com/GgDFdvF.png" title="source: imgur.com" /></div>

**Linha 15:** In√≠cio do m√©todo p√∫blico e est√°tico `obterToken`, que recebe um objeto `TestRestTemplate`, um usuario (e-mail) e uma senha, e retorna uma `String` contendo o token JWT.

**Linha 16:** Cria um objeto `UsuarioLogin` com o usuario e senha informados, usando um m√©todo auxiliar `criarUsuarioLogin`.

**Linha 17:** Cria uma entidade HTTP (`HttpEntity`) contendo o objeto `UsuarioLogin`, para ser enviado na requisi√ß√£o.

**Linhas 19 a 20:** Executa uma requisi√ß√£o HTTP do tipo POST para o endpoint `/usuarios/logar`, enviando a entidade criada e esperando receber um objeto `UsuarioLogin` na resposta.

**Linha 22:** Recupera o corpo da resposta, atrav√©s do m√©todo `getBody`, que deve conter os dados do usu√°rio, incluindo o token JWT.

**Linhas 23 a 25:** Verifica se o corpo da resposta n√£o √© nulo e cont√©m um token, atrav√©s do m√©todo `getToken`; caso positivo, retorna o token.

**Linha 27:** Caso o corpo seja nulo ou n√£o contenha token, lan√ßa uma exce√ß√£o informando que o login falhou para o usuario fornecido.

<div align="center"><img src="https://i.imgur.com/ExQHK5a.png" title="source: imgur.com" /></div>

**Linha 30:** In√≠cio do m√©todo gen√©rico p√∫blico e est√°tico `criarRequisicaoComToken`, que recebe um corpo gen√©rico e um token, e retorna uma entidade HTTP com o token no cabe√ßalho. Este m√©todo √© ideal para criar requisi√ß√µes do tipo POST e PUT.

**Linha 31:** Cria um objeto `HttpHeaders` para configurar os cabe√ßalhos da requisi√ß√£o.

**Linha 32:** Remove o prefixo `"Bearer "` do token, caso ele exista, para garantir o formato correto no cabe√ßalho e armazena na vari√°vel `tokenLimpo`.

**Linha 33:** Define o cabe√ßalho `Authorization` com o token no formato Bearer (`tokenLimpo`), atrav√©s do m√©todo `setBearerAuth`.

**Linha 34:** Retorna uma nova entidade HTTP que inclui o corpo e os cabe√ßalhos configurados.

**Linha 37:** In√≠cio do m√©todo p√∫blico e est√°tico `criarRequisicaoComToken` que recebe apenas o token e retorna uma entidade HTTP sem corpo. Este m√©todo √© ideal para criar requisi√ß√µes do tipo GET e DELETE.

**Linha 35:** Chama o m√©todo anterior passando `null` como corpo, reutilizando a l√≥gica para criar a entidade HTTP com o token no cabe√ßalho. 

<br />

üíæ **Salve as altera√ß√µes antes de prosseguir ( File ü°™ Save All )!**

<br />

<h2>üë£Passo 03 - Criar a Classe UsuarioControllerTest</h2>



A classe **UsuarioControllerTest** ser√° utilizada para realizar os testes da classe controladora **UsuarioController**.
 Crie a classe **UsuarioControllerTest** no pacote **controller**, localizado na *Source Folder* de testes (**src/test/java**).

1. No canto superior esquerdo, na guia **Package Explorer**, clique com o bot√£o direito sobre o pacote **com.generation.blogpessoal.controller**, dentro da *Source Folder* **src/test/java**, e selecione a op√ß√£o **New ‚Üí Class**.
2. Na janela **New Java Class**, no campo **Name**, informe o nome da classe que ser√° testada (**UsuarioController**), seguido da palavra **Test**, indicando que se trata de uma classe de testes. O nome final ser√° **UsuarioControllerTest**, conforme ilustrado na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/r0ugUXm.png" title="source: imgur.com" width="65%"/></div>

3. Clique no bot√£o **Finish** para concluir.

Nos testes da camada **Controller**, iremos realizar requisi√ß√µes **HTTP (HTTP Requests)** e, em seguida, validar se as **respostas (HTTP Response)** retornadas est√£o de acordo com o esperado.

Vamos analisar o c√≥digo da Classe **UsuarioControllerTest**:

<div align="center"><img src="https://i.imgur.com/h6XksZD.png" title="source: imgur.com" /></div>

**Linha 1:** Atrav√©s do comando **package**, estamos informando o nome do pacote (camada), onde a Classe foi criada. Esta informa√ß√£o √© inserida automaticamente pelo STS ao criar a Classe.

**Linhas 3 a 27:** Atrav√©s do comando **import**, estamos indicando todos os pacotes que cont√©m as Classes que est√£o sendo utilizadas na Classe **UsuarioControllerTest**.

<div align="center"><img src="https://imgur.com/rlfRwuF.png" title="source: imgur.com" /></div>

**Linha 29:** A anota√ß√£o **@SpringBootTest** indica que a classe **UsuarioControllerTest** √© uma classe de teste que carrega todo o contexto do Spring Boot para realizar testes de integra√ß√£o.

A propriedade **webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT** configura o servidor embutido para iniciar em uma porta aleat√≥ria, evitando conflitos com outras aplica√ß√µes que possam estar usando a porta padr√£o (geralmente 8080). Essa configura√ß√£o √© fundamental para executar testes isolados em endpoints REST.

**Linha 30:** A anota√ß√£o **@TestInstance(TestInstance.Lifecycle.PER_CLASS)** define que ser√° criada uma √∫nica inst√¢ncia da classe de teste para todos os m√©todos. Isso permite o uso de m√©todos anotados com **@BeforeAll** sem a necessidade de torn√°-los est√°ticos.

**Linha 31:** A anota√ß√£o **@TestMethodOrder(MethodOrderer.DisplayName.class)** indica que a ordem de execu√ß√£o dos testes seguir√° a ordem alfab√©tica dos nomes, facilitando o controle e organiza√ß√£o dos testes.

**Linhas 34 a 41:** Utiliza-se a anota√ß√£o **@Autowired** para injetar depend√™ncias no teste:

- `TestRestTemplate` para enviar requisi√ß√µes HTTP √† aplica√ß√£o durante os testes.
- `UsuarioService` para realizar opera√ß√µes de persist√™ncia e l√≥gica de neg√≥cio, garantindo que as senhas sejam armazenadas criptografadas.
- `UsuarioRepository` para acesso direto ao banco de dados de testes, permitindo a√ß√µes como limpeza da base antes dos testes.

**Linhas 43 a 45:** S√£o declaradas tr√™s constantes est√°ticas e finais:

- `BASE_URL` representa a URI base do recurso usu√°rio nas requisi√ß√µes REST.
- `ADMIN` armazena o e-mail do usu√°rio administrador root usado na autentica√ß√£o dos testes.
- `SENHA` cont√©m a senha do usu√°rio root para autentica√ß√£o.

**Linhas 47 a 51:** O m√©todo **start()**, anotado com **@BeforeAll**, √© executado uma √∫nica vez antes de todos os testes da classe e tem como objetivo preparar o ambiente:

- Chama `deleteAll()` no `usuarioRepository` para limpar a tabela de usu√°rios do banco de dados de testes, garantindo um ambiente limpo.
- Cria um usu√°rio root com dados fixos, utilizando o m√©todo `criarUsuario()` da classe utilit√°ria `TestBuilder`, e o persiste via `usuarioService.cadastrarUsuario()`. Isso assegura que testes que dependem de autentica√ß√£o possam ser realizados corretamente.

<br />

<div align="left"><img src="https://i.imgur.com/AaUP7GB.png" title="source: imgur.com" width="4%"/> <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations" target="_blank"><b>Documenta√ß√£o: @TestInstance</b></a></div>

<div align="left"><img src="https://i.imgur.com/AaUP7GB.png" title="source: imgur.com" width="4%"/> <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations" target="_blank"><b>Documenta√ß√£o: @TestMethodOrder</b></a></div>

<div align="left"><img src="https://i.imgur.com/AaUP7GB.png" title="source: imgur.com" width="4%"/> <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle" target="_blank"><b>Documenta√ß√£o: Lifecycle</b></a></div>

<div align="left"><img src="https://i.imgur.com/mw7d1xn.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing" target="_blank"><b>Documenta√ß√£o: @SpringBootTest</b></a></div>

<div align="left"><img src="https://i.imgur.com/wDz2IzB.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/web/client/TestRestTemplate.html" target="_blank"><b>Documenta√ß√£o: <i>Classe TestRestTemplate</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wDz2IzB.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html#deleteAll--" target="_blank"><b>Documenta√ß√£o: <i>deleteAll()</i></b></a></div>

<br />

<h3>2.1. Metodologia de Testes Given-When-Then</h3>



A abordagem **Given-When-Then**, derivada da pr√°tica de BDD (Behavior-Driven Development), √© utilizada neste projeto para estruturar os testes de forma mais sem√¢ntica. Ela ajuda a descrever o comportamento esperado de forma leg√≠vel:

- **Given** (Dado que): prepara o cen√°rio de teste;
- **When** (Quando): executa a a√ß√£o principal;
- **Then** (Ent√£o): verifica o resultado esperado.

A ado√ß√£o dessa metodologia traz diversos benef√≠cios, entre eles:

- **Melhor organiza√ß√£o dos testes**, tornando o fluxo mais claro e compreens√≠vel.
- **Facilidade na identifica√ß√£o de falhas**, pois explicita de forma objetiva **o que foi feito**, **em qual contexto** e **qual era o resultado esperado**.

<br />

<h3>2.2. M√©todo 01 - Deve criar um Usu√°rio</h3>



<div align="center"><img src="https://i.imgur.com/hJmW1GO.png" title="source: imgur.com" /></div>

Vamos analisar o c√≥digo:

**Linha 53:** O m√©todo **deveCadastrarUsuario()** foi anotado com **@Test**, indicando que ser√° executado automaticamente como um teste unit√°rio ou de integra√ß√£o.

**Linha 54:** A anota√ß√£o **@DisplayName** define um nome descritivo para o teste, que ser√° exibido nos relat√≥rios, facilitando a compreens√£o do prop√≥sito do teste.

**Linha 55:** O m√©todo **deveCadastrarUsuario()** √© declarado com tipo de retorno **void**, pois sua fun√ß√£o √© realizar verifica√ß√µes (asser√ß√µes), sem retornar valores.

#### üîπ **Given (Cen√°rio: cria√ß√£o do objeto usu√°rio)**

**Linha 58:** √â criado um objeto da classe **Usuario** chamado `usuario` usando o m√©todo `criarUsuario()` da classe utilit√°ria **TestBuilder**. O par√¢metro `null` indica que o ID ser√° gerado automaticamente pelo banco ao persistir o objeto.

#### üîπ **When (A√ß√£o: envio da requisi√ß√£o POST)**

**Linha 61:** Um objeto `HttpEntity<Usuario>` chamado `requisicao` √© criado para encapsular o objeto `usuario`, simulando o corpo da requisi√ß√£o HTTP que ser√° enviado.

**Linhas 62 a 63:** A requisi√ß√£o HTTP POST √© enviada ao endpoint `/usuarios/cadastrar` por meio do m√©todo `exchange()` do `TestRestTemplate`. A resposta √© armazenada no objeto `resposta` do tipo `ResponseEntity<Usuario>`. Os par√¢metros da requisi√ß√£o s√£o:

- A URL do endpoint (`BASE_URL + "/cadastrar"`), que representa o caminho do recurso para cadastro.
- O m√©todo HTTP usado (`HttpMethod.POST`).
- O corpo da requisi√ß√£o encapsulado (`requisicao`).
- A classe esperada no retorno (`Usuario.class`).

#### üîπ **Then (Verifica√ß√£o: valida√ß√£o da resposta)**

**Linha 66:** O m√©todo `assertEquals()` verifica se o status HTTP retornado na resposta √© **201 CREATED**, indicando que o cadastro foi bem-sucedido.

**Linha 67:** O m√©todo `assertNotNull()` confirma que o corpo da resposta n√£o √© nulo, ou seja, que o servidor retornou o objeto `Usuario` criado.

<br />

<div align="left"><img src="https://i.imgur.com/AaUP7GB.png" title="source: imgur.com" width="4%"/> <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations" target="_blank"><b>Documenta√ß√£o: @Test</b></a></div>

<div align="left"><img src="https://i.imgur.com/AaUP7GB.png" title="source: imgur.com" width="4%"/> <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-display-names" target="_blank"><b>Documenta√ß√£o: @DisplayName</b></a></div>

<div align="left"><img src="https://i.imgur.com/AaUP7GB.png" title="source: imgur.com" width="4%"/> <a href="https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/Assertions.html" target="_blank"><b>Documenta√ß√£o: Assertions</b></a></div>

<div align="left"><img src="https://i.imgur.com/wDz2IzB.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpEntity.html" target="_blank"><b>Documenta√ß√£o: <i>Classe HttpEntity</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wDz2IzB.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/web/client/TestRestTemplate.html" target="_blank"><b>Documenta√ß√£o: <i>Classe TestRestTemplate</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wDz2IzB.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html" target="_blank"><b>Documenta√ß√£o: <i>Classe ResponseEntity</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wDz2IzB.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpMethod.html" target="_blank"><b>Documenta√ß√£o: <i>HttpMethod</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wDz2IzB.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpStatus.html" target="_blank"><b>Documenta√ß√£o: <i>HttpStatus</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wDz2IzB.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpEntity.html" target="_blank"><b>Documenta√ß√£o: <i>Classe HttpEntity</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wDz2IzB.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpEntity.html#getBody--" target="_blank"><b>Documenta√ß√£o: <i>Classe HttpEntity - M√©todo getBody()</i></b></a></div>

<br />

<h3>2.3. M√©todo 02 - N√£o deve permitir a duplica√ß√£o do Usu√°rio</h3>



<div align="center"><img src="https://i.imgur.com/k585Huh.png" title="source: imgur.com" /></div>

Vamos analisar o c√≥digo:

**Linha 70:** O m√©todo **naoDeveDuplicarUsuario()** foi anotado com **@Test**, indicando que ser√° executado automaticamente como um teste.

**Linha 71:** A anota√ß√£o **@DisplayName** define um nome descritivo para o teste, exibido durante a execu√ß√£o para facilitar a leitura dos relat√≥rios.

**Linha 72:** O m√©todo **naoDeveDuplicarUsuario()** √© declarado com tipo de retorno **void**, pois executa verifica√ß√µes (asser√ß√µes) sem retornar valores.

#### üîπ **Given (Cen√°rio: cria√ß√£o pr√©via do usu√°rio no banco)**

**Linha 75:** Um objeto da classe **Usuario**, chamado `usuario`, √© criado usando o m√©todo `criarUsuario()` da classe utilit√°ria **TestBuilder**. O ID √© definido como `null` para ser gerado pelo banco.

**Linha 76:** O m√©todo `cadastrarUsuario()` da classe `UsuarioService` √© chamado para persistir o usu√°rio no banco de dados antes do teste, simulando a exist√™ncia pr√©via do usu√°rio.

#### üîπ **When (A√ß√£o: envio da requisi√ß√£o POST para cadastro)**

**Linha 79:** √â criado um objeto `HttpEntity<Usuario>`, chamado `requisicao`, contendo o usu√°rio, simulando o corpo da requisi√ß√£o HTTP.

**Linhas 80 a 81:** A requisi√ß√£o POST √© enviada ao endpoint `/usuarios/cadastrar` via `exchange()` do `TestRestTemplate`. A resposta √© armazenada em `resposta` do tipo `ResponseEntity<Usuario>`. Os par√¢metros s√£o:

- URL do endpoint (`BASE_URL + "/cadastrar"`).
- M√©todo HTTP `POST`.
- Corpo da requisi√ß√£o encapsulado em `requisicao`.
- Tipo de retorno esperado: `Usuario.class`.

#### üîπ **Then (Verifica√ß√£o: valida√ß√£o da rejei√ß√£o da duplicidade)**

**Linha 84:** O m√©todo `assertEquals()` verifica se o status HTTP retornado √© **400 BAD_REQUEST**, indicando que a duplica√ß√£o foi detectada e bloqueada.

Este teste valida que a aplica√ß√£o n√£o permite cadastrar um usu√°rio com dados j√° existentes. A resposta HTTP 400 confirma que a regra de neg√≥cio foi corretamente aplicada e o teste ser√° considerado aprovado.

<br />

> [!IMPORTANT]
>
> Testar apenas os cen√°rios de sucesso n√£o √© suficiente para garantir a robustez de uma aplica√ß√£o. Os **testes de falha** s√£o fundamentais para validar como o sistema se comporta diante de situa√ß√µes inesperadas ou dados inv√°lidos, assegurando que ele **responda de maneira controlada, previs√≠vel e segura**. Essa abordagem √© essencial para aumentar a confiabilidade e a estabilidade da aplica√ß√£o em ambientes reais.

<br />

<h3>2.4. M√©todo 03 - Deve atualizar os dados de um Usu√°rio</h3>



<div align="center"><img src="https://i.imgur.com/nL4bIVn.png" title="source: imgur.com" /></div>

Vamos analisar o c√≥digo:

**Linha 87:** O m√©todo **deveAtualizarUmUsuario()** foi anotado com **@Test**, indicando que ser√° executado automaticamente como um teste.

**Linha 88:** A anota√ß√£o **@DisplayName** define um nome descritivo que ser√° exibido na execu√ß√£o do teste, facilitando a leitura dos relat√≥rios.

**Linha 89:** O m√©todo **deveAtualizarUmUsuario()** √© declarado com tipo de retorno **void**, pois realiza apenas verifica√ß√µes (asser√ß√µes) sem retornar valores.

#### üîπ **Given (Cen√°rio: usu√°rio previamente cadastrado)**

**Linha 92:** Um objeto da classe **Usuario**, chamado `usuario`, √© criado via m√©todo `criarUsuario()` da classe utilit√°ria **TestBuilder**, com o atributo `id` definido como `null` para ser gerado automaticamente pelo banco.

**Linha 93:** O m√©todo `cadastrarUsuario()` da classe `UsuarioService` √© chamado para persistir o usu√°rio no banco de testes. O resultado √© armazenado em um objeto `Optional<Usuario>`, chamado `cadastrado`, que permite acessar o ID gerado do usu√°rio criado.

**Linhas 95 a 96:** Um novo objeto `usuarioUpdate` √© criado para representar os dados atualizados do usu√°rio, utilizando o mesmo ID recuperado do Optional `cadastrado`. Esse objeto possui novos valores para nome e e-mail, simulando a atualiza√ß√£o.

#### üîπ **When (A√ß√£o: envio da requisi√ß√£o PUT para atualizar o usu√°rio)**

**Linha 99:** O token de autentica√ß√£o √© obtido pelo m√©todo `obterToken()` da classe `JwtHelper`, utilizando credenciais do usu√°rio administrador root.

**Linha 100:** Um objeto `HttpEntity<Usuario>`, chamado `requisicao`, √© criado com o corpo `usuarioUpdate` e o token no cabe√ßalho, simulando uma requisi√ß√£o autenticada.

**Linhas 101 a 102:** A requisi√ß√£o HTTP do tipo PUT √© enviada para o endpoint `/usuarios/atualizar` pelo m√©todo `exchange()` do `TestRestTemplate`. A resposta √© armazenada em `resposta` do tipo `ResponseEntity<Usuario>`. Os par√¢metros da requisi√ß√£o s√£o:

- URL do endpoint (`BASE_URL + "/atualizar"`).
- M√©todo HTTP: `PUT`.
- Corpo da requisi√ß√£o encapsulado (`requisicao`).
- Tipo de retorno esperado: `Usuario.class`.

#### üîπ **Then (Verifica√ß√£o: valida√ß√£o da resposta da atualiza√ß√£o)**

**Linha 105:** O m√©todo `assertEquals()` verifica se o status HTTP da resposta √© **200 OK**, indicando sucesso na atualiza√ß√£o.

**Linhas 106:** O m√©todo `assertNotNull()` confirma que o corpo da resposta n√£o √© nulo, ou seja, que o servidor retornou o objeto `Usuario` atualizado.

<br />

<h3>2.5. M√©todo 04 - Listar todos os Usu√°rios</h3>



<div align="center"><img src="https://i.imgur.com/rx8Nppt.png" title="source: imgur.com" /></div>

Vamos analisar o c√≥digo:

**Linha 109:** O m√©todo **deveListarTodosUsuarios()** foi anotado com **@Test**, indicando que ser√° executado automaticamente como um teste.

**Linha 110:** A anota√ß√£o **@DisplayName** define um nome descritivo que ser√° exibido durante a execu√ß√£o do teste, facilitando a compreens√£o nos relat√≥rios.

**Linha 111:** O m√©todo **deveListarTodosUsuarios()** foi declarado com tipo de retorno **void**, pois realiza apenas verifica√ß√µes (asser√ß√µes) sem retornar valores.

#### üîπ **Given (Cen√°rio: usu√°rios previamente cadastrados)**

**Linhas 114 a 117:** Dois objetos `Usuario` s√£o criados por meio do m√©todo `criarUsuario()` da classe utilit√°ria **TestBuilder** e, em seguida, persistidos no banco de dados com o m√©todo `cadastrarUsuario()` da classe **UsuarioService**. Isso simula um cen√°rio onde esses usu√°rios j√° existem no sistema antes da requisi√ß√£o.

#### üîπ **When (A√ß√£o: envio da requisi√ß√£o GET para listar usu√°rios)**

**Linha 120:** O token de autentica√ß√£o √© obtido pelo m√©todo `obterToken()` da classe `JwtHelper`, utilizando credenciais do usu√°rio administrador root.

**Linha 121:** o m√©todo `criarRequisicaoComToken()` da classe **JwtHelper** √© chamado para criar um objeto `HttpEntity<Void>` contendo o token JWT no cabe√ßalho, preparando a requisi√ß√£o autorizada.

**Linhas 122 a 123:** Uma requisi√ß√£o HTTP do tipo GET √© enviada ao endpoint `/usuarios/all` pelo m√©todo `exchange()` do `TestRestTemplate`. A resposta √© armazenada em `resposta`, do tipo `ResponseEntity<Usuario[]>`. Os par√¢metros da requisi√ß√£o s√£o:

- URL do endpoint (`BASE_URL + "/all"`).
- M√©todo HTTP: `GET`.
- Corpo da requisi√ß√£o: `null`, pois GET n√£o possui corpo.
- Tipo de retorno esperado: array de objetos `Usuario[]`.

#### üîπ **Then (Verifica√ß√£o: valida√ß√£o da resposta da listagem)**

**Linha 126:** Verifica-se com `assertEquals()` se o status HTTP retornado √© **200 OK**, confirmando que a opera√ß√£o foi bem-sucedida.

**Linha 127:** Verifica-se com `assertNotNull()` se o corpo da resposta n√£o est√° vazio, garantindo que a lista de usu√°rios foi retornada.

<br />

üíæ **Salve as altera√ß√µes antes de prosseguir ( File ü°™ Save All )!**

<br />

A vers√£o final do c√≥digo, voc√™ confere abaixo:

```java
package com.generation.blogpessoal.controller;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

import java.util.Optional;

import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.DisplayName;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import com.generation.blogpessoal.model.Usuario;
import com.generation.blogpessoal.repository.UsuarioRepository;
import com.generation.blogpessoal.service.UsuarioService;
import com.generation.blogpessoal.util.JwtHelper;
import com.generation.blogpessoal.util.TestBuilder;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@TestMethodOrder(MethodOrderer.DisplayName.class)
class UsuarioControllerTest {

	@Autowired
	private TestRestTemplate testRestTemplate;
	
	@Autowired
	private UsuarioService usuarioService;
	
	@Autowired
	private UsuarioRepository usuarioRepository;

	private static final String BASE_URL = "/usuarios";
	private static final String ADMIN = "root@root.com";
	private static final String SENHA = "rootroot";

	@BeforeAll
	void start() {
		usuarioRepository.deleteAll();
		usuarioService.cadastrarUsuario(TestBuilder.criarUsuario(null, "Root", ADMIN, SENHA));
	}

	@Test
	@DisplayName("‚úî 01 - Deve cadastrar um novo usu√°rio com sucesso")
	void deveCadastrarUsuario() {
		
		// Given
		Usuario usuario = TestBuilder.criarUsuario(null, "Paulo Antunes", "paulo_antunes@email.com.br", "12345678");
		
		// When
		HttpEntity<Usuario> requisicao = new HttpEntity<>(usuario);
		ResponseEntity<Usuario> resposta = testRestTemplate.exchange(
				BASE_URL + "/cadastrar", HttpMethod.POST, requisicao, Usuario.class);
		
		// Then
		assertEquals(HttpStatus.CREATED, resposta.getStatusCode());
		assertNotNull(resposta.getBody());
	}

	@Test
	@DisplayName("‚úî 02 - N√£o deve permitir a duplica√ß√£o do usu√°rio")
	void naoDeveDuplicarUsuario() {
		
		// Given
		Usuario usuario = TestBuilder.criarUsuario(null, "Maria da Silva", "maria_silva@email.com.br", "12345678");
		usuarioService.cadastrarUsuario(usuario);
		
		// When
		HttpEntity<Usuario> requisicao = new HttpEntity<>(usuario);
		ResponseEntity<Usuario> resposta = testRestTemplate.exchange(
				BASE_URL + "/cadastrar", HttpMethod.POST, requisicao, Usuario.class);
		
		// Then
		assertEquals(HttpStatus.BAD_REQUEST, resposta.getStatusCode());
	}

	@Test
	@DisplayName("‚úî 03 - Deve atualizar os dados de um usu√°rio com sucesso")
	void deveAtualizarUmUsuario() {
		
		// Given
		Usuario usuario = TestBuilder.criarUsuario(null, "Juliana Andrews", "ju_andrews@email.com.br", "12345678");
		Optional<Usuario> cadastrado = usuarioService.cadastrarUsuario(usuario);
		
		Usuario usuarioUpdate = TestBuilder.criarUsuario(cadastrado.get().getId(), "Juliana Ramos", 
				"ju_ramos@email.com.br", "12345678");
		
		// When
		String token = JwtHelper.obterToken(testRestTemplate, ADMIN, SENHA);
		HttpEntity<Usuario> requisicao = JwtHelper.criarRequisicaoComToken(usuarioUpdate, token);
		ResponseEntity<Usuario> resposta = testRestTemplate.exchange(
				BASE_URL + "/atualizar", HttpMethod.PUT, requisicao, Usuario.class);
		
		// Then
		assertEquals(HttpStatus.OK, resposta.getStatusCode());
		assertNotNull(resposta.getBody());
	}

	@Test
	@DisplayName("‚úî 04 - Deve listar todos os usu√°rios com sucesso")
	void deveListarTodosUsuarios() {
		
		// Given
		usuarioService.cadastrarUsuario(TestBuilder.criarUsuario(null, "Ana Marques", 
				"ana_marques@email.com.br", "12345678"));
		usuarioService.cadastrarUsuario(TestBuilder.criarUsuario(null, "Carlos Moura", 
				"carlos_moura@email.com.br", "12345678"));
		
		// When
		String token = JwtHelper.obterToken(testRestTemplate, ADMIN, SENHA);
		HttpEntity<Void> requisicao = JwtHelper.criarRequisicaoComToken(token);
		ResponseEntity<Usuario[]> resposta = testRestTemplate.exchange(
				BASE_URL + "/all", HttpMethod.GET, requisicao, Usuario[].class);
		
		// Then
		assertEquals(HttpStatus.OK, resposta.getStatusCode());
		assertNotNull(resposta.getBody());
	}

}

```

<br />

<h2>üë£ Passo 04 - Executando os Testes no STS




<h3>3.1. Executar todos os testes</h3>

1) No lado esquerdo superior, na Guia **Project**, na Package **src/test/java**, clique com o bot√£o direito do mouse sobre a Classe de teste que voc√™ deseja executar e clique na op√ß√£o **Run As ü°™ JUnit Test**.

<div align="center"><img src="https://i.imgur.com/pjm7kzG.png" title="source: imgur.com" /></div>


2) Para acompanhar os testes, ao lado da Guia **Project**, clique na Guia **JUnit** .

<div align="center"><img src="https://i.imgur.com/4GxjbSU.png" title="source: imgur.com" width="70%"/></div>

  3) Se todos os testes passarem, a Guia do JUnit ficar√° com uma faixa verde (janela 01). Caso algum teste n√£o passe, a Guia do JUnit ficar√° com uma faixa vermelha (janela 02). Neste caso, observe o item <b>Failure Trace</b> para identificar o (s) erro (s).

<div align="center">
<table width=100%>
	<tr>
		<td width=50%><div align="center"><img src="https://i.imgur.com/Lxt1cfC.png" title="source: imgur.com" /></div>
		<td width=50%><div align="center"><img src="https://i.imgur.com/5G767aj.png" title="source: imgur.com" /></div>
	</tr>
	<tr>
		<td><div align="center">Janela 01: <i> Testes aprovados.
		<td><div align="center">Janela 02: <i> Testes reprovados.
	</tr>
</table>
</div>
<br />
<br />

<h3>3.2. Executar apenas um M√©todo espec√≠fico</h3>

1. Posicione o cursor do mouse sobre o nome do teste. Observe que o nome ser√° selecionado, como mostra a figura abaixo:

   <div align="center"><img src="https://i.imgur.com/Oj11AqF.png" title="source: imgur.com" /></div>

2. Clique com o bot√£o direito do mouse sobre o nome do M√©todo que voc√™ deseja executar e clique na op√ß√£o **Run As ü°™ JUnit Test**.

   <div align="center"><img src="https://i.imgur.com/nbD1D4A.png" title="source: imgur.com" /></div>

3. Observe que ser√° executado apenas o M√©todo que voc√™ selecionou.

<div align="center"><img src="https://i.imgur.com/XQH0ZKI.png" title="source: imgur.com" /></div>

<br />

> [!NOTE]
>
> **DESAFIO!**
>
> Agora que voc√™ j√° conhece os principais testes b√°sicos para o recurso **Usu√°rio**, √© hora de colocar seu conhecimento em pr√°tica!
>
> Desafie-se a escrever os seguintes testes, consolidando o que aprendeu e aprofundando suas habilidades em testes automatizados com Spring Boot:
>
> - `‚úî 05 - Deve listar um usu√°rio espec√≠fico pelo id`
>    *Implemente um teste que verifica se o endpoint retorna corretamente os dados de um usu√°rio quando fornecido seu identificador.*
> - `‚úî 06 - Deve autenticar um usu√°rio com sucesso`
>    *Crie um teste que valide o processo de login, garantindo que um usu√°rio v√°lido consiga obter um token de autentica√ß√£o.*
>
> Esses desafios s√£o importantes para que voc√™ ganhe autonomia no desenvolvimento de testes mais completos, fortalecendo a qualidade e a confiabilidade da sua aplica√ß√£o.
>
> Experimente, teste e aprimore seu c√≥digo!

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="4%"/> <a href="https://github.com/rafaelq80/backend_blogpessoal_spring/tree/12_Testes" target="_blank"><b>C√≥digo fonte do projeto</b></a> 
</div>

<br />

<h2>‚úî Boas pr√°ticas</h2>



1. **Mantenha testes pequenos e objetivos:** testes concisos facilitam a identifica√ß√£o de problemas e tornam a manuten√ß√£o mais simples.
2. **Garanta que sejam r√°pidos:** testes lentos dificultam a execu√ß√£o frequente, por isso, mantenha-os √°geis para integrar ao fluxo cont√≠nuo de desenvolvimento.
3. **Sejam determin√≠sticos:** testes devem sempre produzir o mesmo resultado, evitando depend√™ncias externas inst√°veis que possam causar falhas intermitentes.
4. **Devem ser independentes entre si:** cada teste deve ser isolado, garantindo que falhas em um n√£o afetem outros testes.
5. **Use nomes descritivos:** facilite a leitura com nomes claros e padronizados, como *deve[Comportamento]Quando[Cen√°rio]*, para entender o prop√≥sito sem abrir o c√≥digo.
6. **Inclua poucas asser√ß√µes por teste:** foque em validar um comportamento por teste para identificar facilmente onde est√° o problema.
7. **Analise os resultados ap√≥s cada execu√ß√£o:** investigue rapidamente as falhas para manter a qualidade e a confiabilidade do c√≥digo.
8. **Mantenha os testes atualizados:** acompanhe as altera√ß√µes no c√≥digo para evitar testes obsoletos ou inv√°lidos.

<br /> <br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
