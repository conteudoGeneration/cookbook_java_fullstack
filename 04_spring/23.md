<h1>Teste de Software com JUnit 5 - Teste da Classe Controller</h1>

<br />

Vamos dar continuidade √† cria√ß√£o dos testes estruturando duas classes importantes:

- A **classe utilit√°ria `TestBuilder`**, respons√°vel por centralizar a cria√ß√£o de objetos de teste com dados simulados (mock), promovendo **reutiliza√ß√£o** e **organiza√ß√£o**;
- E a **classe de testes `UsuarioControllerTest`**, onde validaremos o comportamento dos endpoints do recurso **Usuario**, por meio de testes automatizados da camada de **controller**.

Essa abordagem permite manter os testes mais limpos, objetivos e f√°ceis de manter.

<br />

<h2>üë£Passo 01 - Criar a Classe Utilit√°ria TestBuilder</h2>



A classe **TestBuilder** ser√° respons√°vel por definir os m√©todos utilizados na cria√ß√£o de objetos de teste para as classes *Model*. Como o foco deste conte√∫do √© a realiza√ß√£o de testes no recurso **Usu√°rio**, iremos implementar apenas os m√©todos necess√°rios para essa finalidade. Caso voc√™ deseje escrever testes para outros recursos, basta adicionar os m√©todos correspondentes √†s demais classes *Model*.

Crie a classe **TestBuilder** no pacote **util**, localizado na *Source Folder* de testes (**src/test/java**):

1. No lado esquerdo superior, na Guia **Package Explorer**, clique com o bot√£o direito do mouse sobre a Package **com.generation.blogpessoal.util**, na Source Folder **src/test/java** e clique na op√ß√£o  **New ü°™ Class**.

2. Na janela **New Java Class**, no item **Name**, informe o nome da Classe Utilit√°ria **TestBuilder**, como mostra a figura abaixo:

<div align="center"><img src="https://i.imgur.com/1XqwEit.png" title="source: imgur.com" width="65%"/></div>

3. Clique no bot√£o **Finish** para concluir.
4. Na sequ√™ncia, adicione o c√≥digo abaixo:

```java
package com.generation.blogpessoal.util;

import com.generation.blogpessoal.model.Usuario;

public class TestBuilder {

    public static Usuario criarUsuario(Long id, String nome, String email, String senha) {
        Usuario usuario = new Usuario();
        usuario.setId(id);
        usuario.setNome(nome);
        usuario.setUsuario(email);
        usuario.setSenha(senha);
        usuario.setFoto("-");
        return usuario;
    }

    public static Usuario criarUsuarioRoot() {
        return criarUsuario(null, "Root", "root@root.com", "rootroot");
    }
}
```

Vamos analisar o c√≥digo:

<div align="center"><img src="https://i.imgur.com/dWhk2I8.png" title="source: imgur.com" /></div>

**Linhas 7 a 15:** Criamos o M√©todo **criarUsuario**, que ser√° respons√°vel por criar objetos da Classe Usuario. Observe que na pr√°tica, est√° sendo criado um objeto padr√£o da Classe Usuario, ou seja, vazio, e atrav√©s dos m√©todos set, os dados est√£o sendo preenchidos com os par√¢metros do m√©todo.

**Linhas 17 a 19:** Criamos o M√©todo **criarUsuarioRoot**, que atrav√©s do m√©todo **criarUsuario**, cria o usu√°rio root, que ser√° utilizado para testar os endpoints protegidos, que exigem a autentica√ß√£o do usu√°rio.

<br />

<h2>üë£Passo 02 - Criar a Classe UsuarioControllerTest</h2>



A classe **UsuarioControllerTest** ser√° utilizada para realizar os testes da classe controladora **UsuarioController**.
 Crie a classe **UsuarioControllerTest** no pacote **controller**, localizado na *Source Folder* de testes (**src/test/java**).

1. No canto superior esquerdo, na guia **Package Explorer**, clique com o bot√£o direito sobre o pacote **com.generation.blogpessoal.controller**, dentro da *Source Folder* **src/test/java**, e selecione a op√ß√£o **New ‚Üí Class**.
2. Na janela **New Java Class**, no campo **Name**, informe o nome da classe que ser√° testada (**UsuarioController**), seguido da palavra **Test**, indicando que se trata de uma classe de testes. O nome final ser√° **UsuarioControllerTest**, conforme ilustrado na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/r0ugUXm.png" title="source: imgur.com" width="65%"/></div>

3. Clique no bot√£o **Finish** para concluir.

Nos testes da camada **Controller**, iremos realizar requisi√ß√µes **HTTP (Http Request)** e, em seguida, validar se as **respostas (Http Response)** retornadas est√£o de acordo com o esperado.

Para simular essas requisi√ß√µes e respostas, utilizaremos algumas classes e m√©todos fornecidos pelo **Spring Framework**, que permitem a execu√ß√£o de testes de integra√ß√£o com foco no comportamento dos endpoints da aplica√ß√£o:

| Classe e M√©todos                     |                                                              |
| ------------------------------------ | ------------------------------------------------------------ |
| **TestRestTemplate**                 | √â uma classe utilit√°ria fornecida pelo Spring Boot para facilitar a realiza√ß√£o de testes de integra√ß√£o de APIs REST. Ela atua como um cliente HTTP, permitindo o envio de requisi√ß√µes HTTP (como `GET`, `POST`, `PUT` e `DELETE`) para os endpoints da aplica√ß√£o em teste. |
| **HttpEntity<T>**                    | √â uma classe que representa uma entidade HTTP gen√©rica que pode ser usada tanto para requisi√ß√µes quanto para respostas. Ela encapsula o corpo da requisi√ß√£o (body) e os cabe√ßalhos HTTP (headers), mas **n√£o inclui o status da resposta**. O generic `<T>` representa o tipo de dado enviado no corpo da requisi√ß√£o.<br />Na pr√°tica, `HttpEntity` √© utilizada para compor o corpo da requisi√ß√£o HTTP em testes que envolvem envio de dados, como nas opera√ß√µes `POST` ou `PUT`. |
| **ResponseEntity<T>**                | √â uma especializa√ß√£o da classe `HttpEntity` (Heran√ßa), que **adiciona um c√≥digo de status HTTP** (`HttpStatus`). O generic `<T>` representa o tipo de dado esperado na Resposta na requisi√ß√£o.<br />Essa classe √© frequentemente usada para representar **respostas completas** de requisi√ß√µes HTTP, contendo:<br/>- C√≥digo do HTTP Status<br />- Cabe√ßalhos HTTP<br />- Corpo da Resposta |
| **TestRestTemplate.exchange()**      | O m√©todo `exchange()` da Classe `TestRestTemplate` permite enviar requisi√ß√µes HTTP utilizando diferentes m√©todos (como `GET`, `POST`, `PUT`, `DELETE`, entre outros.), retornando um objeto do tipo `ResponseEntity<T>`, com o resultado da requisi√ß√£o. Esse m√©todo √© bastante flex√≠vel e permite realizar todas as opera√ß√µes b√°sicas de um CRUD, incluindo:<br />- Defini√ß√£o do ender√ßo do endpoint<br />- M√©todo HTTP<br />- Corpo da Requisi√ß√£o (via `HttpEntity`)<br />- Tipo esperado da Resposta (`ResponseEntity<T>`) |
| **TestRestTemplate.withBasicAuth()** | O m√©todo `withBasicAuth(String username, String password)` da Classe `TestRestTemplate` permite autenticar requisi√ß√µes HTTP utilizando o esquema de autentica√ß√£o HTTP Basic. Isso √© √∫til para testar endpoints protegidos por **Spring Security**, onde √© necess√°rio fornecer credenciais v√°lidas (usu√°rio e senha).<br />Essa abordagem √© especialmente √∫til em testes de integra√ß√£o com controle de acesso, permitindo validar o comportamento da aplica√ß√£o sob diferentes contextos de autentica√ß√£o. |

<br />


Vamos analisar o c√≥digo da Classe **UsuarioControllerTest**:

<div align="center"><img src="https://i.imgur.com/2qHllxS.png" title="source: imgur.com" /></div>

**Linha 1:** Atrav√©s do comando **package**, estamos informando o nome do pacote (camada), onde a Classe foi criada. Esta informa√ß√£o √© inserida automaticamente pelo STS ao criar a Classe.

**Linhas 3 a 24:** Atrav√©s do comando **import**, estamos indicando todos os pacotes que cont√©m as Classes que est√£o sendo utilizadas na Classe **UsuarioControllerTest**.

<div align="center"><img src="https://i.imgur.com/W63aqGC.png" title="source: imgur.com" /></div>

**Linha 26:** A anota√ß√£o **@SpringBootTest** indica que a classe **UsuarioControllerTest** √© uma classe de testes do tipo *Spring Boot Testing*.

A propriedade **webEnvironment** permite configurar o ambiente web no momento da execu√ß√£o dos testes. Quando utilizamos a op√ß√£o `webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT`, o Spring atribui automaticamente uma porta aleat√≥ria caso a porta padr√£o (geralmente a **8080**) esteja ocupada.

O uso dessa configura√ß√£o √© essencial para a realiza√ß√£o de **testes de integra√ß√£o com endpoints REST**, pois garante que o servidor embutido ser√° iniciado corretamente e que os testes poder√£o ser executados de forma isolada e independente da porta principal da aplica√ß√£o.

**Linha 27:** A anota√ß√£o **@TestInstance** define que o ciclo de vida da classe de teste ser√° **por classe**, ou seja, uma √∫nica inst√¢ncia da classe de teste ser√° criada para todos os m√©todos de teste. Isso permite, por exemplo, o uso de m√©todos `@BeforeAll` n√£o est√°ticos.

**Linhas 30 e 31** foi injetado (**@Autowired**), um objeto da classe **TestRestTemplate**, utilizado para **enviar requisi√ß√µes HTTP** para a aplica√ß√£o durante os testes.

**Linhas 33 e 34** foi injetado (**@Autowired**), um objeto da classe **UsuarioService**, respons√°vel por **persistir os objetos no banco de dados de testes**, garantindo que as senhas dos usu√°rios sejam **armazenadas de forma criptografada**.

**Linhas 36 e 37:** foi injetado (**@Autowired**), um objeto da interface **UsuarioRepository**, utilizado para **limpar o banco de dados de testes** antes ou depois da execu√ß√£o dos testes, garantindo um ambiente limpo e previs√≠vel.

**Linhas 39 a 41:** foram criadas tr√™s constantes respons√°veis por armazenar, respectivamente: o **e-mail do usu√°rio de autentica√ß√£o root**, a **senha do usu√°rio root** e a **URI do recurso Usuario**, que ser√° utilizada nas requisi√ß√µes HTTP durante os testes.

**Linhas 43 a 47:** foi implementado o m√©todo **start()**, anotado com **@BeforeAll**, que √© executado **antes de todos os testes** da classe. Esse m√©todo tem como objetivo preparar o ambiente de testes, realizando duas a√ß√µes principais:

- **Limpar a tabela `tb_usuarios`** do banco de dados de testes, utilizando o m√©todo **`deleteAll()`** da interface **UsuarioRepository**.
- **Criar o usu√°rio root**, por meio do m√©todo **`criarUsuarioRoot()`** da classe utilit√°ria **TestBuilder**, garantindo que os testes com endpoints protegidos por autentica√ß√£o possam ser executados corretamente.

<br />

<div align="left"><img src="https://i.imgur.com/mw7d1xn.png" title="source: imgur.com" width="30px"/> <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing" target="_blank"><b>Documenta√ß√£o: @SpringBootTest</b></a></div>

<div align="left"><img src="https://i.imgur.com/AaUP7GB.png" title="source: imgur.com" width="25px"/> <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations" target="_blank"><b>Documenta√ß√£o: @TestInstance</b></a></div>

<div align="left"><img src="https://i.imgur.com/AaUP7GB.png" title="source: imgur.com" width="25px"/> <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle" target="_blank"><b>Documenta√ß√£o: Lifecycle</b></a></div>

<div align="left"><img src="https://i.imgur.com/wDz2IzB.png" title="source: imgur.com" width="25px"/> <a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/web/client/TestRestTemplate.html" target="_blank"><b>Documenta√ß√£o: <i>Classe TestRestTemplate</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wDz2IzB.png" title="source: imgur.com" width="25px"/> <a href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html#deleteAll--" target="_blank"><b>Documenta√ß√£o: <i>deleteAll()</i></b></a></div>

<br />

<h3>2.1. Metodologia de Testes Given-When-Then</h3>



A abordagem **Given-When-Then**, derivada da pr√°tica de BDD (Behavior-Driven Development), √© utilizada neste projeto para estruturar os testes de forma mais sem√¢ntica. Ela ajuda a descrever o comportamento esperado de forma leg√≠vel:

- **Given** (Dado que): prepara o cen√°rio de teste;
- **When** (Quando): executa a a√ß√£o principal;
- **Then** (Ent√£o): verifica o resultado esperado.

A ado√ß√£o dessa metodologia traz diversos benef√≠cios, entre eles:

- **Melhor organiza√ß√£o dos testes**, tornando o fluxo mais claro e compreens√≠vel.
- **Facilidade na identifica√ß√£o de falhas**, pois explicita de forma objetiva **o que foi feito**, **em qual contexto** e **qual era o resultado esperado**.

<br />

<h3>2.2. M√©todo 01 - Deve criar um Usu√°rio</h3>



<div align="center"><img src="https://i.imgur.com/ZNDRcih.png" title="source: imgur.com" /></div>

Vamos analisar o c√≥digo:

**Linha 49:** o m√©todo **deveCadastrarUmUsuario()** foi anotado com **@Test**, indicando que ser√° executado como um teste automatizado.

**Linha 50:** a anota√ß√£o **@DisplayName** define um nome descritivo que ser√° exibido na execu√ß√£o do teste, no lugar do nome do m√©todo, facilitando a leitura dos relat√≥rios.

**Linha 51:** o m√©todo **deveCadastrarUmUsuario()** foi declarado com o tipo de retorno **void**, pois n√£o retorna valores, apenas realiza verifica√ß√µes (asser√ß√µes).

#### üîπ **Given (cen√°rio preparado com um novo usu√°rio)**

**Linha 54:** foi criado um objeto da classe **Usuario**, chamado `usuario`, por meio do m√©todo `criarUsuario()` da classe utilit√°ria **TestBuilder**. Este objeto representa os dados que ser√£o enviados na requisi√ß√£o HTTP (nome, e-mail, senha etc.). Note que o atributo id foi definido como `null`, porque o id ser√° definido pelo Banco de dados, ap√≥s o objetos ser persistido.

#### üîπ **When (a requisi√ß√£o POST √© enviada para a API)**

**Linha 57:** foi criado um objeto da classe **HttpEntity**, chamado `requisicao`, contendo o objeto `usuario`. Esta etapa simula o envio de dados no corpo da requisi√ß√£o HTTP (Request Body), tal como acontece ao fazer uma Requisi√ß√£o do tipo **POST** no Insomnia.

**Linhas 58 e 59:** a requisi√ß√£o HTTP √© enviada utilizando o m√©todo `exchange()` da classe **TestRestTemplate**, e a resposta (Response) √© armazenada no objeto `resposta`, do tipo **ResponseEntity**. Os quatro par√¢metros utilizados s√£o:

- **A URI**: o endere√ßo do endpoint (`/usuarios/cadastrar`), constru√≠do por meio da constante `BASE_URL_USUARIOS`, que representa o caminho base do recurso Usuario, ao qual foi concatenado com o complemento `/cadastrar`. Esse valor define o destino da requisi√ß√£o HTTP, indicando o endpoint respons√°vel pelo cadastro de novos usu√°rios.
- **O m√©todo HTTP**: `HttpMethod.POST`
- **O objeto HttpEntity**: `requisicao`, contendo o corpo da requisi√ß√£o
- **O tipo de retorno esperado**: `Usuario.class`, indicando que o corpo da resposta dever√° ser um objeto da classe Usuario

#### üîπ **Then (verifica se a resposta foi 201 CREATED e se os dados retornados s√£o os esperados)**

**Linha 62:** utilizamos o m√©todo de asser√ß√£o `assertEquals()` para verificar se o status HTTP retornado pela resposta √© igual ao status esperado **HttpStatus.CREATED (201)**. O status da resposta √© obtido com o m√©todo `getStatusCode()`.

**Linhas 63 e 64:** utilizamos `assertEquals()` novamente para verificar se os atributos `nome` e `usuario` do corpo da resposta s√£o iguais aos valores definidos no objeto `usuario` enviado na requisi√ß√£o. Para isso, acessamos o corpo da resposta com o m√©todo `getBody()` e, em seguida, usamos os m√©todos `getNome()` e `getUsuario()` da Classe Usuario, para acessar os atributos.

<br />

<div align="left"><img src="https://i.imgur.com/AaUP7GB.png" title="source: imgur.com" width="25px"/> <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations" target="_blank"><b>Documenta√ß√£o: @Test</b></a></div>

<div align="left"><img src="https://i.imgur.com/AaUP7GB.png" title="source: imgur.com" width="25px"/> <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-display-names" target="_blank"><b>Documenta√ß√£o: @DisplayName</b></a></div>

<div align="left"><img src="https://i.imgur.com/wDz2IzB.png" title="source: imgur.com" width="25px"/> <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpEntity.html" target="_blank"><b>Documenta√ß√£o: <i>Classe HttpEntity</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wDz2IzB.png" title="source: imgur.com" width="25px"/> <a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/web/client/TestRestTemplate.html" target="_blank"><b>Documenta√ß√£o: <i>Classe TestRestTemplate</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wDz2IzB.png" title="source: imgur.com" width="25px"/> <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html" target="_blank"><b>Documenta√ß√£o: <i>Classe ResponseEntity</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wDz2IzB.png" title="source: imgur.com" width="25px"/> <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpMethod.html" target="_blank"><b>Documenta√ß√£o: <i>HttpMethod</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wDz2IzB.png" title="source: imgur.com" width="25px"/> <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpStatus.html" target="_blank"><b>Documenta√ß√£o: <i>HttpStatus</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/AaUP7GB.png" title="source: imgur.com" width="25px"/> <a href="https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/Assertions.html" target="_blank"><b>Documenta√ß√£o: assertEquals</b></a></div>

<div align="left"><img src="https://i.imgur.com/wDz2IzB.png" title="source: imgur.com" width="25px"/> <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpEntity.html" target="_blank"><b>Documenta√ß√£o: <i>Classe HttpEntity</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wDz2IzB.png" title="source: imgur.com" width="25px"/> <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpEntity.html#getBody--" target="_blank"><b>Documenta√ß√£o: <i>Classe HttpEntity - M√©todo getBody()</i></b></a></div>

<br />

<h3>2.3. M√©todo 02 - N√£o deve permitir a duplica√ß√£o do Usu√°rio</h3>



<div align="center"><img src="https://i.imgur.com/ug8Idq2.png" title="source: imgur.com" /></div>

Vamos analisar o c√≥digo:

**Linha 67:** o m√©todo **naoDeveDuplicarUsuario()** foi anotado com **@Test**, indicando que ser√° executado como um teste automatizado.

**Linha 68:** a anota√ß√£o **@DisplayName** define um nome descritivo que ser√° exibido na execu√ß√£o do teste, no lugar do nome do m√©todo, facilitando a leitura dos relat√≥rios.

**Linha 69:** o m√©todo **naoDeveDuplicarUsuario()** foi declarado com o tipo de retorno **void**, pois n√£o retorna valores, apenas realiza verifica√ß√µes (asser√ß√µes).

#### üîπ **Given (cen√°rio preparado com um novo usu√°rio)**

**Linha 72:** foi criado um objeto da classe **Usuario**, chamado `usuario`, por meio do m√©todo `criarUsuario()` da classe utilit√°ria **TestBuilder**. Este objeto representa os dados que ser√£o enviados na requisi√ß√£o HTTP (nome, e-mail, senha etc.). Note que o atributo id foi definido como `null`, porque o id ser√° definido pelo Banco de dados, ap√≥s o objetos ser persistido.

**Linha 73:** Utilizamos o m√©todo `cadastrarUsuario()` da classe `UsuarioService` para **criar previamente um usu√°rio no banco de dados**, antes do envio da requisi√ß√£o. Essa abordagem tem como objetivo **simular a duplica√ß√£o de dados**, permitindo validar se a aplica√ß√£o trata corretamente a tentativa de cadastrar um usu√°rio j√° existente.

#### üîπ **When (a requisi√ß√£o POST √© enviada para a API)**

**Linha 76:** foi criado um objeto da classe **HttpEntity**, chamado `requisicao`, contendo o objeto `usuario`. Esta etapa simula o envio de dados no corpo da requisi√ß√£o HTTP (Request Body), tal como acontece ao fazer uma Requisi√ß√£o do tipo **POST** no Insomnia.

**Linhas 77 e 78:** a requisi√ß√£o HTTP √© enviada utilizando o m√©todo `exchange()` da classe **TestRestTemplate**, e a resposta (Response) √© armazenada no objeto `resposta`, do tipo **ResponseEntity**. Os quatro par√¢metros utilizados s√£o:

- **A URI**: o endere√ßo do endpoint (`/usuarios/cadastrar`), constru√≠do por meio da constante `BASE_URL_USUARIOS`, que representa o caminho base do recurso Usuario, ao qual foi concatenado com o complemento `/cadastrar`. Esse valor define o destino da requisi√ß√£o HTTP, indicando o endpoint respons√°vel pelo cadastro de novos usu√°rios.
- **O m√©todo HTTP**: `HttpMethod.POST`
- **O objeto HttpEntity**: `requisicao`, contendo o corpo da requisi√ß√£o
- **O tipo de retorno esperado**: `Usuario.class`, indicando que o corpo da resposta dever√° ser um objeto da classe Usuario

#### üîπ **Then (verifica se a resposta foi 400 BAD_REQUEST)**

**Linha 81:** utilizamos o m√©todo de asser√ß√£o `assertEquals()` para verificar se o status HTTP retornado pela resposta √© igual ao status esperado **HttpStatus.BAD_REQUEST (400)**. O status da resposta √© obtido com o m√©todo  `getStatusCode()`.

Como este teste tem por objetivo **verificar se a aplica√ß√£o impede a duplica√ß√£o de usu√°rios no banco de dados**, o foco **n√£o ser√° validar a cria√ß√£o com sucesso (HTTP Status 201 ‚Äì Created)**, mas sim **garantir que a requisi√ß√£o seja rejeitada** quando houver tentativa de cadastrar um usu√°rio j√° existente.

Neste caso, o teste espera receber o **HTTP Status 400 ‚Äì Bad Request**, indicando que a aplica√ß√£o **identificou a duplicidade e bloqueou a opera√ß√£o**, como deveria acontecer. Se a resposta for **400**, significa que a regra de neg√≥cio foi corretamente aplicada e o teste ser√° considerado **aprovado**.

<br />

| <img src="https://i.imgur.com/nSpXEZ0.png" title="source: imgur.com" width="250px"/> | <p align="justify"> Testar apenas os cen√°rios de sucesso n√£o √© suficiente para garantir a robustez de uma aplica√ß√£o. **Testes de falha** ajudam a validar o comportamento do sistema frente a situa√ß√µes inesperadas ou inv√°lidas, assegurando que ele **reaja de forma controlada, previs√≠vel e segura**, o que √© essencial para a confiabilidade da aplica√ß√£o em ambiente real. </p> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<h3>2.4. M√©todo 03 - Deve atualizar os dados de um Usu√°rio</h3>



<div align="center"><img src="https://i.imgur.com/49KIwbo.png" title="source: imgur.com" /></div>

Vamos analisar o c√≥digo:

**Linha 85:** o m√©todo **deveAtualizarUmUsuario()** foi anotado com **@Test**, indicando que ser√° executado como um teste automatizado.

**Linha 86:** a anota√ß√£o **@DisplayName** define um nome descritivo que ser√° exibido na execu√ß√£o do teste, no lugar do nome do m√©todo, facilitando a leitura dos relat√≥rios.

**Linha 87:** o m√©todo **deveAtualizarUmUsuario()** foi declarado com o tipo de retorno **void**, pois n√£o retorna valores, apenas realiza verifica√ß√µes (asser√ß√µes).

#### üîπ **Given (cen√°rio preparado com um novo usu√°rio)**

**Linha 90:** foi criado um objeto da classe **Usuario**, chamado `usuario`, por meio do m√©todo `criarUsuario()` da classe utilit√°ria **TestBuilder**. Este objeto representa os dados que ser√£o enviados na requisi√ß√£o HTTP (nome, e-mail, senha etc.). Note que o atributo id foi definido como `null`, porque o id ser√° definido pelo Banco de dados, ap√≥s o objetos ser persistido.

**Linha 90:** Utilizamos o m√©todo `cadastrarUsuario()` da classe `UsuarioService` para **criar previamente um usu√°rio no banco de dados**, simulando um cen√°rio real em que o usu√°rio j√° existe antes da opera√ß√£o de atualiza√ß√£o.

O resultado da persist√™ncia √© armazenado em um objeto do tipo `Optional<Usuario>`, chamado **usuarioCadastrado**, o qual nos permite **recuperar com seguran√ßa o `id` do usu√°rio criado**. Esse `id` ser√° essencial para construir o corpo da requisi√ß√£o de atualiza√ß√£o, garantindo que o teste altere os dados do usu√°rio correto no banco.

**Linha 93 a 94:** Foi criado um objeto da classe `Usuario`, chamado **usuarioUpdate**, por meio do m√©todo `criarUsuario()` da classe utilit√°ria **TestBuilder**. Esse objeto representa os **novos dados que ser√£o enviados na requisi√ß√£o HTTP** (nome, e-mail, senha etc.), com o objetivo de atualizar as informa√ß√µes do usu√°rio j√° existente no banco de dados.

Para garantir que a atualiza√ß√£o seja feita no registro correto, o atributo `id` do objeto `usuarioUpdate` foi preenchido com o valor recuperado do objeto `usuarioCadastrado`, utilizando os m√©todos `get()` (para acessar o valor contido no `Optional`) e `getId()` (da classe `Usuario`).

#### üîπ **When (a requisi√ß√£o PUT √© enviada para a API)**

**Linha 97:** foi criado um objeto da classe **HttpEntity**, chamado `requisicao`, contendo o objeto `usuarioUpdate`. Esta etapa simula o envio de dados no corpo da requisi√ß√£o HTTP (Request Body), tal como acontece ao fazer uma Requisi√ß√£o do tipo **PUT** no Insomnia.

**Linhas 99 a 101:** a requisi√ß√£o HTTP √© enviada utilizando o m√©todo `exchange()` da classe **TestRestTemplate**, e a resposta (Response) √© armazenada no objeto `resposta`, do tipo **ResponseEntity**. Os quatro par√¢metros utilizados s√£o:

- **A URI**: o endere√ßo do endpoint (`/usuarios/atualizar`), constru√≠do por meio da constante `BASE_URL_USUARIOS`, que representa o caminho base do recurso Usuario, ao qual foi concatenado com o complemento `/atualizar`. Esse valor define o destino da requisi√ß√£o HTTP, indicando o endpoint respons√°vel pela atualiza√ß√£o dos dados de um usu√°rio existente.
- **O m√©todo HTTP**: `HttpMethod.PUT`
- **O objeto HttpEntity**: `requisicao`, contendo o corpo da requisi√ß√£o
- **O tipo de retorno esperado**: `Usuario.class`, indicando que o corpo da resposta dever√° ser um objeto da classe Usuario

Observe que na **linha 99**, como o Blog Pessoal est√° utilizando **Spring Security** com autentica√ß√£o do tipo **HTTP Basic**, o objeto **`testRestTemplate`**, utilizado para enviar requisi√ß√µes aos endpoints protegidos (que exigem autentica√ß√£o), deve realizar o login com um usu√°rio e senha v√°lidos para que os testes sejam executados corretamente.

Para isso, utilizamos o m√©todo **`withBasicAuth(username, password)`** da classe **`TestRestTemplate`**, que permite configurar as credenciais de autentica√ß√£o. Nesse caso, ser√° utilizado o usu√°rio **`root`**, criado previamente no m√©todo **`start()`**, para autenticar-se na aplica√ß√£o. As credenciais utilizadas nos testes est√£o armazenadas nas constantes **`USUARIO_ROOT_EMAIL`** e **`USUARIO_ROOT_SENHA`**.

#### üîπ **Then (verifica se a resposta foi 200 CREATED e se os dados retornados s√£o os esperados)**

**Linha 104:** utilizamos o m√©todo de asser√ß√£o `assertEquals()` para verificar se o status HTTP retornado pela resposta √© igual ao status esperado **HttpStatus.OK (200)**. O status da resposta √© obtido com o m√©todo `getStatusCode()`.

**Linhas 105 e 106:** utilizamos `assertEquals()` novamente para verificar se os atributos `nome` e `usuario` do corpo da resposta s√£o iguais aos valores definidos no objeto `usuarioUpdate` enviado na requisi√ß√£o. Para isso, acessamos o corpo da resposta com o m√©todo `getBody()` e, em seguida, usamos os m√©todos `getNome()` e `getUsuario()` da Classe Usuario, para acessar os atributos.

<br />

<div align="left"><img src="https://i.imgur.com/wDz2IzB.png" title="source: imgur.com" width="25px"/> <a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/web/client/TestRestTemplate.html#withBasicAuth-java.lang.String-java.lang.String-" target="_blank"><b>Documenta√ß√£o: <i>Classe TestRestTemplate - M√©todo .withBasicAuth()</i></b></a></div>

<br />

<h3>2.5. M√©todo 04 - Listar todos os Usu√°rios</h3>



<div align="center"><img src="https://i.imgur.com/EW9s6kJ.png" title="source: imgur.com" /></div>

Vamos analisar o c√≥digo:

**Linha 108:** o m√©todo **deveListarTodosUsuarios()** foi anotado com **@Test**, indicando que ser√° executado como um teste automatizado.

**Linha 109:** a anota√ß√£o **@DisplayName** define um nome descritivo que ser√° exibido na execu√ß√£o do teste, no lugar do nome do m√©todo, facilitando a leitura dos relat√≥rios.

**Linha 110:** o m√©todo **deveListarTodosUsuarios()** foi declarado com o tipo de retorno **void**, pois n√£o retorna valores, apenas realiza verifica√ß√µes (asser√ß√µes).

#### üîπ **Given (cen√°rio preparado com um novo usu√°rio)**

**Linhas 113 e 114:** Foram inseridos dois usu√°rios no banco de dados utilizando, primeiramente, o m√©todo **`criarUsuario()`** da classe utilit√°ria **`TestBuilder`**, respons√°vel por instanciar objetos da classe **`Usuario`** com os dados necess√°rios (nome, e-mail, senha etc.). Em seguida, esses objetos foram persistidos no banco de dados por meio do m√©todo **`cadastrarUsuario()`** da classe **`UsuarioService`**.

Essa abordagem tem como objetivo **criar previamente os usu√°rios no banco de dados**, antes do envio da requisi√ß√£o HTTP, simulando um cen√°rio real em que os usu√°rios j√° existem no sistema.

#### üîπ **When (a requisi√ß√£o GET √© enviada para a API)**

**Linhas 117 a 119:** a requisi√ß√£o HTTP √© enviada utilizando o m√©todo `exchange()` da classe **TestRestTemplate**, e a resposta (Response) √© armazenada no objeto `resposta`, do tipo **ResponseEntity**. Os quatro par√¢metros utilizados s√£o:

- **A URI**: o endere√ßo do endpoint (`/usuarios/all`), constru√≠do por meio da constante `BASE_URL_USUARIOS`, que representa o caminho base do recurso Usuario, ao qual foi concatenado com o complemento `/all`. Esse valor define o destino da requisi√ß√£o HTTP, indicando o endpoint respons√°vel por listar os dados de todos os usu√°rios.
- **O m√©todo HTTP**: `HttpMethod.GET`
- **O objeto HttpEntity**: `null`, porque requisi√ß√µes do tipo GET n√£o possuem corpo da requisi√ß√£o
- **O tipo de retorno esperado**: `Usuario[].class`, indicando que o corpo da resposta dever√° receber uma cole√ß√£o de objetos da classe Usuario

<br />

| <img src="https://i.imgur.com/nSpXEZ0.png" title="source: imgur.com" width="100px"/> | <p align="justify">Requisi√ß√µes HTTP dos tipos **GET** e **DELETE** n√£o possuem corpo (body) na requisi√ß√£o, conforme a especifica√ß√£o do protocolo HTTP. Essas opera√ß√µes s√£o baseadas apenas na URL </p> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

Observe que na **linha 118**, como o Blog Pessoal est√° utilizando **Spring Security** com autentica√ß√£o do tipo **HTTP Basic**, o objeto **`testRestTemplate`**, utilizado para enviar requisi√ß√µes aos endpoints protegidos (que exigem autentica√ß√£o), deve realizar o login com um usu√°rio e senha v√°lidos para que os testes sejam executados corretamente.

Para isso, utilizamos o m√©todo **`withBasicAuth(username, password)`** da classe **`TestRestTemplate`**, que permite configurar as credenciais de autentica√ß√£o. Nesse caso, ser√° utilizado o usu√°rio **`root`**, criado previamente no m√©todo **`start()`**, para autenticar-se na aplica√ß√£o. As credenciais utilizadas nos testes est√£o armazenadas nas constantes **`USUARIO_ROOT_EMAIL`** e **`USUARIO_ROOT_SENHA`**.

#### üîπ **Then (verifica se a resposta foi 200 OK e se os dados retornados s√£o os esperados)**

**Linha 122:** Utilizamos o m√©todo de asser√ß√£o **`assertEquals()`** para verificar se o status HTTP retornado pela resposta √© igual ao valor esperado, no caso, **`HttpStatus.OK (200)`**. O status da resposta √© obtido por meio do m√©todo **`getStatusCode()`**.

**Linha 123:** Utilizamos o m√©todo **`assertNotNull()`** para garantir que o corpo da resposta contenha a cole√ß√£o de usu√°rios, ou seja, que os dados esperados foram de fato retornados pela requisi√ß√£o.

Para concluir, n√£o esque√ßa de Salvar o c√≥digo (**File ü°™ Save All**).

<br />

Vers√£o final do c√≥digo:

```java
package com.generation.blogpessoal.controller;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

import java.util.Optional;

import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import com.generation.blogpessoal.model.Usuario;
import com.generation.blogpessoal.repository.UsuarioRepository;
import com.generation.blogpessoal.service.UsuarioService;
import com.generation.blogpessoal.util.TestBuilder;

@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class UsuarioControllerTest {

	@Autowired
	private TestRestTemplate testRestTemplate;

	@Autowired
	private UsuarioService usuarioService;

	@Autowired
	private UsuarioRepository usuarioRepository;
	
	private static final String USUARIO_ROOT_EMAIL = "root@root.com";
	private static final String USUARIO_ROOT_SENHA = "rootroot";
	private static final String BASE_URL_USUARIOS = "/usuarios";

	@BeforeAll
	void start(){
		usuarioRepository.deleteAll();
		usuarioService.cadastrarUsuario(TestBuilder.criarUsuarioRoot());
	}
	
	@Test
	@DisplayName("Deve cadastrar um novo usu√°rio com sucesso")
	public void deveCadastrarUsuario() {
		
		// Given
		Usuario usuario = TestBuilder.criarUsuario(null, "Paulo Antunes",
				"paulo_antunes@email.com.br", "13465278");

		// When
		HttpEntity<Usuario> requisicao = new HttpEntity<>(usuario);
		ResponseEntity<Usuario> resposta = testRestTemplate.exchange(
				BASE_URL_USUARIOS + "/cadastrar", HttpMethod.POST, requisicao, Usuario.class);

		// Then
		assertEquals(HttpStatus.CREATED, resposta.getStatusCode());
		assertEquals("Paulo Antunes", resposta.getBody().getNome());
		assertEquals("paulo_antunes@email.com.br", resposta.getBody().getUsuario());
	}
	
	@Test
	@DisplayName("N√£o deve permitir duplica√ß√£o do usu√°rio")
	public void naoDeveDuplicarUsuario() {
		
		//Given
		Usuario usuario = TestBuilder.criarUsuario(null, "Maria da Silva",
				"maria_silva@email.com.br", "13465278");
		usuarioService.cadastrarUsuario(usuario);

		//When
		HttpEntity<Usuario> requisicao = new HttpEntity<>(usuario);
		ResponseEntity<Usuario> resposta = testRestTemplate.exchange(
				BASE_URL_USUARIOS + "/cadastrar", HttpMethod.POST, requisicao, Usuario.class);

		//Then
		assertEquals(HttpStatus.BAD_REQUEST, resposta.getStatusCode());
	}

	@Test
	@DisplayName("Deve atualizar um usu√°rio existente")
	public void deveAtualizarUmUsuario() {
		
		//Given
		Usuario usuario = TestBuilder.criarUsuario(null, "Juliana Andrews", "juliana_andrews@email.com.br",
				"juliana123");
		Optional<Usuario> usuarioCadastrado = usuarioService.cadastrarUsuario(usuario);
		
		Usuario usuarioUpdate = TestBuilder.criarUsuario(usuarioCadastrado.get().getId(), "Juliana Ramos", 
				"juliana_ramos@email.com.br", "juliana123");

		//When
		HttpEntity<Usuario> requisicao = new HttpEntity<>(usuarioUpdate);

		ResponseEntity<Usuario> resposta = testRestTemplate
				.withBasicAuth(USUARIO_ROOT_EMAIL, USUARIO_ROOT_SENHA)
				.exchange(BASE_URL_USUARIOS + "/atualizar", HttpMethod.PUT, requisicao, Usuario.class);

		//Then
		assertEquals(HttpStatus.OK, resposta.getStatusCode());
		assertEquals("Juliana Ramos", resposta.getBody().getNome());
		assertEquals("juliana_ramos@email.com.br", resposta.getBody().getUsuario());
	}

	@Test
	@DisplayName("Deve listar todos os usu√°rios")
	public void deveListarTodosUsuarios() {
		
		//Given
		usuarioService.cadastrarUsuario(TestBuilder.criarUsuario(null, "Ana Clara",
				"ana@email.com", "senha123"));
		usuarioService.cadastrarUsuario(TestBuilder.criarUsuario(null, "Carlos Souza",
				"carlos@email.com", "senha123"));

		//When
		ResponseEntity<Usuario[]> resposta = testRestTemplate
				.withBasicAuth(USUARIO_ROOT_EMAIL, USUARIO_ROOT_SENHA)
				.exchange(BASE_URL_USUARIOS + "/all", HttpMethod.GET, null, Usuario[].class);

		//Then
		assertEquals(HttpStatus.OK, resposta.getStatusCode());
		assertNotNull(resposta.getBody());
	}
	
}
```

<br />

<h2>üë£ Passo 03 - Executando os Testes no STS



<h3>3.1. Executar todos os testes</h3>

1) No lado esquerdo superior, na Guia **Project**, na Package **src/test/java**, clique com o bot√£o direito do mouse sobre a Classe de teste que voc√™ deseja executar e clique na op√ß√£o **Run As ü°™ JUnit Test**.

<div align="center"><img src="https://i.imgur.com/pjm7kzG.png" title="source: imgur.com" /></div>


2) Para acompanhar os testes, ao lado da Guia **Project**, clique na Guia **JUnit** .

<div align="center"><img src="https://i.imgur.com/4GxjbSU.png" title="source: imgur.com" width="70%"/></div>

  3) Se todos os testes passarem, a Guia do JUnit ficar√° com uma faixa verde (janela 01). Caso algum teste n√£o passe, a Guia do JUnit ficar√° com uma faixa vermelha (janela 02). Neste caso, observe o item <b>Failure Trace</b> para identificar o (s) erro (s).

<div align="center">
<table width=100%>
	<tr>
		<td width=50%><div align="center"><img src="https://i.imgur.com/Lxt1cfC.png" title="source: imgur.com" /></div>
		<td width=50%><div align="center"><img src="https://i.imgur.com/5G767aj.png" title="source: imgur.com" /></div>
	</tr>
	<tr>
		<td><div align="center">Janela 01: <i> Testes aprovados.
		<td><div align="center">Janela 02: <i> Testes reprovados.
	</tr>
</table>
</div>
<br />

<h3>3.2. Executar apenas um M√©todo espec√≠fico</h3>

1. Posicione o cursor do mouse sobre o nome do teste. Observe que o nome ser√° selecionado, como mostra a figura abaixo:

   <div align="center"><img src="https://i.imgur.com/Oj11AqF.png" title="source: imgur.com" /></div>

2. Clique com o bot√£o direito do mouse sobre o nome do M√©todo que voc√™ deseja executar e clique na op√ß√£o **Run As ü°™ JUnit Test**.

   <div align="center"><img src="https://i.imgur.com/nbD1D4A.png" title="source: imgur.com" /></div>

3. Observe que ser√° executado apenas o M√©todo que voc√™ selecionou.

<div align="center"><img src="https://i.imgur.com/XQH0ZKI.png" title="source: imgur.com" /></div>

| <img src="https://i.imgur.com/L338M2G.png" title="source: imgur.com" width="138px"/> | **DESAFIO:** Fa√ßa algumas altera√ß√µes nos dados dos objetos e/ou escreva outros testes para praticar. A melhor forma de aprender e compreender como funcionam os testes √© praticando!  |
| ------------------------------------------------------------ | :----------------------------------------------------------- |

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="25px"/> <a href="https://github.com/rafaelq80/backend_blogpessoal_v3/tree/16_Testes_UsuarioController" target="_blank"><b>C√≥digo fonte do projeto</b></a> 
</div>
<br />

<h2>‚úî Boas pr√°ticas</h2>

1. **Mantenha testes pequenos e objetivos.**
2. **Garanta que sejam r√°pidos:** testes lentos dificultam a execu√ß√£o frequente.
3. **Sejam determin√≠sticos:** devem sempre produzir o mesmo resultado.
4. **Devem ser independentes entre si.**
5. **Use nomes descritivos:** facilite a leitura sem precisar abrir o c√≥digo.
6. **Inclua poucas asser√ß√µes por teste:** cada teste deve validar apenas um comportamento.
7. **Analise os resultados ap√≥s cada execu√ß√£o.**

<br /> <br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
