<h1>Introdu√ß√£o a Spring Security</h1>

<div align="center"><img src="https://i.imgur.com/iyARgVe.png" title="source: imgur.com" /></div>

No mundo da tecnologia, em especial da Internet, nenhuma aplica√ß√£o em execu√ß√£o na Nuvem pode ficar sem algum tipo de Seguran√ßa habilitada, devido aos in√∫meros perigos existentes no mundo virtual como ataques Hackers, invas√µes de Servidores, roubos de dados, entre outros.

Analisando nossos projetos, podemos perceber que nossas API's, at√© este momento, n√£o possuem nenhuma seguran√ßa, ou seja, qualquer pessoa pode acessar todos os nossos endpoints e terem acesso √† todos os recursos livremente. Como a maioria das aplica√ß√µes atuais cont√©m informa√ß√µes vitais como: dados pessoais dos usu√°rios e dos clientes, dados banc√°rios, credenciais de acesso (usu√°rio e senha), precisamos garantir que a nossa API e estes dados estejam devidamente protegidos. No Ecossistema Spring, podemos contar com a Depend√™ncia **Spring Security**, para implementar a seguran√ßa da nossa API.

**Spring Security** √© um framework para Java, que prov√™ autentica√ß√£o, autoriza√ß√£o, filtros de servlet e diversas outras funcionalidades para aplica√ß√µes corporativas, com o objetivo de proteger a aplica√ß√£o contra acessos indevidos. O Projeto da Spring Security foi Iniciado em 2003, por Ben Alex. A Spring Security √© distribu√≠da sob a licen√ßa Apache License e √© parte integrante do Ecossistema Spring.

A Depend√™ncia **spring-boot-starter-security** √© respons√°vel por todas as depend√™ncias relacionadas √† seguran√ßa do Spring. Dentro desta depend√™ncia, existem outras 3 depend√™ncias:

- **spring-security-core:** Implementa os principais recursos do Spring Security;

- **spring-security-config:** Fornece o namespace (contexto) Spring Security;

- **spring-security-web:** fornece filtros e outros recursos necess√°rios para proteger aplicativos da web.

Vamos adicionar a **Depend√™ncia Spring Security** no Projeto Blog Pessoal, adicionando as linhas abaixo no arquivo **pom.xml**:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

Na imagem abaixo, vemos a Depend√™ncia inserida no arquivo **pom.xml**:

<div align="center"><img src="https://i.imgur.com/VQAw5S8.png" title="source: imgur.com" /></div>

Salve o arquivo e Execute a aplica√ß√£o.

Abra a sua aplica√ß√£o no Navegador da Internet atrav√©s do endere√ßo: **http://localhost:8080** e veja o que acontece.

<div align="center"><img src="https://i.imgur.com/k19Ci4j.png?2" title="source: imgur.com" /></div>

Como num passe de m√°gica...

- ‚Ä¶ Voc√™ tem uma p√°gina de login gerada automaticamente.
- ‚Ä¶ Voc√™ n√£o consegue mais executar Requisi√ß√µes HTTP (GET, POST, PUT e DELETE).
- ‚Ä¶ Todo o seu aplicativo est√° bloqueado e solicita que voc√™ insira um nome de usu√°rio e uma senha.

Tendo sobrevivido ao susto inicial, voc√™ deve ter pensado: Como tudo isso aconteceu?

Depois de inserir a Depend√™ncia **spring-boot-starter-security**, o Spring habilitar√° alguns padr√µes de configura√ß√£o de seguran√ßa autom√°tica, incluindo a seguran√ßa de todos os endpoints, bem como a defini√ß√£o da estrat√©gia de autentica√ß√£o no formato **httpBasic** (Autentica√ß√£o b√°sica atrav√©s de usu√°rio e senha). 

Al√©m disso, sem fazer nenhuma configura√ß√£o adicional, ele vai criar um nome de usu√°rio padr√£o (**user**) e uma senha, que foi gerada aleatoriamente e pode ser visualizada no console do Spring, como mostra a imagem abaixo. Esses dados podem ser utilizados para fazer login na aplica√ß√£o, atrav√©s da tela de login (veja a imagem anterior) gerada pela Spring Security.

<div align="center"><img src="https://i.imgur.com/dI2DdEm.png" title="source: imgur.com" /></div>

A partir do momento que a Spring Security foi habilitada, foi criado um endpoint de login, que ser√° utilizado para redirecionar as requisi√ß√µes n√£o autenticadas. O redirecionamento aponta para a p√°gina de login padr√£o. No entanto, em um servi√ßo REST, exibir uma p√°gina de login em todas as situa√ß√µes n√£o faz o menor sentido, pois os servi√ßos REST, na maioria das vezes, n√£o ser√£o chamados de forma direta. Servi√ßos REST s√£o chamados por aplicativos clientes personalizados, como um Front-end ou um App Mobile, em vez de solicita√ß√µes diretas do navegador da Internet. 

Nos servi√ßos REST √© altamente recomendado enviar a resposta HTTP Status **401 - Unauthorized**, quando a solicita√ß√£o vier sem autentica√ß√£o, em vez de redirecionar para a p√°gina de login gerada por padr√£o para obter a autentica√ß√£o. Esteja ciente de que, nesse caso, o Status **401 - Unauthorized** significa, n√£o autenticado.

Desta forma, para deixarmos de utilizar esta tela de login padr√£o, precisaremos customizar a implementa√ß√£o da Spring Secuity, mas antes precisamos entender alguns conceitos fundamentais utilizados pela Spring Security e pela maioria dos sistemas de seguran√ßa.

<br />

<h2>1. Seguran√ßa da Aplica√ß√£o - Conceitos</h2>

Antes de estudarmos a Spring Security, vamos compreender alguns conceitos importantes da Seguran√ßa da Informa√ß√£o:

<h3>1.1. Autentica√ß√£o</h3>

<div align="center"><img src="https://i.imgur.com/oljXzoD.png" title="source: imgur.com" /></div>

√â o primeiro processo da Seguran√ßa da Informa√ß√£o, popularmente conhecido como Login no sistema. √â o momento em que o usu√°rio informa o seu usu√°rio de login (e-mail) e a sua senha (criptografada), e o sistema far√° a checagem se estas informa√ß√µes est√£o corretas.

<br />

<h3>1.2. Autoriza√ß√£o</h3>

<div align="center"><img src="https://i.imgur.com/kazNpLz.png" title="source: imgur.com" /></div>

√â o segundo processo da Seguran√ßa da Informa√ß√£o, popularmente conhecido como Direitos de acesso (Roles) no sistema. √â o momento em que o sistema verificar√° o que o usu√°rio pode e n√£o pode fazer no sistema, ou seja, as suas permiss√µes dentro do sistema (Quais Recursos e Endpoints podem ser acessados?). Estas permiss√µes s√£o chamada de **Roles**.

<br />

<h3>1.3. Filtros de Servlet</h3>

<div align="center"><img src="https://i.imgur.com/Hn9NSd6.png" title="source: imgur.com" /></div>

Qualquer aplicativo da Spring WEB √© apenas um **Servlet** (√© uma Classe Java usada para criar aplica√ß√µes WEB), que redireciona todas as Requisi√ß√µes HTTP recebidas, para as suas respectivas Classes Controladoras (**@RestControllers**). 

> Um **Servlet** √© um componente **Java do lado do servidor**, utilizado para processar requisi√ß√µes HTTP e gerar respostas din√¢micas,  geralmente em aplica√ß√µes web. Ele funciona como uma ponte entre o  cliente (navegador ou ferramenta como o Insomnia) e o servidor de  aplica√ß√µes (como o Tomcat). Em outras palavras, um servlet √© como um **programa Java que roda dentro de um servidor** e **responde a requisi√ß√µes da web**.

Como nestas Requisi√ß√µes HTTP n√£o existe uma seguran√ßa e os processos de autentica√ß√£o e autoriza√ß√£o devem ser efetuadas antes das Requisi√ß√µes HTTP chegarem na Classe Controladora, a Spring Security oferece como solu√ß√£o para estes problemas os **Filtros de Servlet**, que na pr√°tica s√£o Objetos Java que interceptam toda e qualquer Requisi√ß√£o HTTP recebida antes de chegarem na Classe Controladora e efetuam algum tipo de processamento. Por isso que o seu Blog Pessoal est√° "trancado" ap√≥s a inser√ß√£o da Depend√™ncia Spring Security.

A figura acima, ilustra o filtro **UsernamePasswordAuthenticationFilter** checando se a Requisi√ß√£o possui os Atributos  usuario (e-mail) e a senha. Se os dados estiverem corretos, o **Filtro de Servlet** autentica o usu√°rio e libera o acesso ao sistema. Caso contr√°rio, ele retorna o Status **401 - Unauthorized**.

Ao adicionar a Depend√™ncia Spring Security, 15 Filtros de Servlet s√£o habilitados por padr√£o, onde cada um tem uma fun√ß√£o espec√≠fica. Ao customizar as configura√ß√µes da Spring Security voc√™ pode definir quais filtros ser√£o habilitados, quais filtros ser√£o desabilitados e ainda criar e habilitar filtros personalizados criados pela pessoa desenvolvedora. N√£o abordaremos este assunto em detalhes por ser muito extenso, por demandar muito tempo e dedica√ß√£o, mas de qualquer forma criaremos um **Filtro de Servlet** personalizado para validar as Requisi√ß√µes HTTP. 

<br />

<h3>1.4. Token</h3>

<div align="center"><img src="https://i.imgur.com/13LBzxE.png" title="source: imgur.com" /></div>

Parte integrante da Autentica√ß√£o, um **Token** √© um dado, que aparentemente n√£o tem significado ou uso por si s√≥, mas quando combinado com o sistema de seguran√ßa correto, torna-se parte vital da seguran√ßa de seu aplicativo. A autentica√ß√£o baseada em token garante que cada solicita√ß√£o a um servidor seja acompanhada por um token assinado,  que o servidor verifica a sua autenticidade e s√≥ ent√£o responde √† solicita√ß√£o. Um bom exemplo do uso do Token, s√£o os aplicativos de Internet Banking, que em todas as transa√ß√µes financeiras gera um novo token para autorizar a opera√ß√£o.

A imagem acima, ilustra um **Token no formato Bearer**. Para cada usu√°rio autenticado no sistema, ser√° gerado um Token, com prazo de validade, que posteriormente ser√° enviado no Cabe√ßalho de todas Requisi√ß√µes HTTP. Requisi√ß√µes HTTP sem um Token v√°lido ser√£o rejeitadas pelos endpoints protegidos da aplica√ß√£o. A valida√ß√£o de um Token funciona como um funil (Filtro de Servlet), onde s√≥ passam as Requisi√ß√µes que possuem um Token v√°lido, mesmo com o usu√°rio estando autenticado.

<h4>1.4.1. Por que precisamos do Token?</h4>

Quando voc√™ envia uma Requisi√ß√£o HTTP para uma API, se o recurso precisar de autoriza√ß√£o para acessar, primeiro voc√™ precisa provar que possui a autoriza√ß√£o e faz isso enviando seu nome de usu√°rio e senha. Agora, imagine que voc√™ precise acessar os recursos desse servidor v√°rias vezes. Nessa situa√ß√£o, voc√™ precisaria enviar o seu nome de usu√°rio e senha em todas as tentativas de acessar o recurso.

Voc√™ n√£o precisaria fazer isso se a sua aplica√ß√£o guardasse o estado atual da autentica√ß√£o. Entretanto, vamos relembrar que uma API REST n√£o guarda o estado, ou seja, uma Requisi√ß√£o n√£o depende e/ou utiliza dados de uma Requisi√ß√£o anterior, logo √© necess√°rio encontrar outra maneira de autorizar os usu√°rios, em vez de solicitar o nome de usu√°rio e a senha em todas as solicita√ß√µes.

Como solu√ß√£o para este problema, surge a **Autoriza√ß√£o Baseada em Token**. Quando voc√™ entra em um sistema fornecendo seu nome de usu√°rio e senha, o sistema gera um Token para voc√™ com os dados de autoriza√ß√£o necess√°rios dentro dele. Esse Token √© enviado a voc√™ como resposta √† sua Requisi√ß√£o de autentica√ß√£o. Para qualquer Requisi√ß√£o de acesso a recursos do servidor, voc√™ pode enviar esse Token em vez de enviar o seu nome de usu√°rio e senha.

<br />

<h2>2. Conhecendo o HTTP Authentication</h2>

O **IETF (\*Internet Engineering Task Force\*)** √© a for√ßa-tarefa respons√°vel por identificar e propor solu√ß√µes para problemas relacionados ao uso da Internet, al√©m de estabelecer a padroniza√ß√£o das tecnologias e protocolos envolvidos. Entre essas padroniza√ß√µes, est√° a defini√ß√£o da estrutura de autentica√ß√£o HTTP, utilizada pelos servidores para solicitar a autentica√ß√£o dos clientes.

Em uma autentica√ß√£o baseada em token, o servidor responde a requisi√ß√£o do cliente com o **HTTP Status 401 (Unauthorized)**, informando que a requisi√ß√£o n√£o possui credenciais v√°lidas, quando o token n√£o √© enviado no cabe√ßalho da requisi√ß√£o ou quando ele n√£o √© validado. Junto a essa resposta, o servidor envia o cabe√ßalho **WWW-Authenticate**, contendo informa√ß√µes sobre o m√©todo de autentica√ß√£o exigido. O cliente, ao receber essa resposta, poder√° reenviar a requisi√ß√£o incluindo no cabe√ßalho, na chave **Authorization**, as credenciais necess√°rias conforme o m√©todo indicado, geralmente um token. No Diagrama de Sequ√™ncia abaixo pode se observar este relacionamento:

<div align="center"><img src="https://i.imgur.com/skGtKqr.png" title="source: imgur.com" /></div>

No caso da **Autentica√ß√£o Bearer** (como ilustrado na imagem acima), a troca de informa√ß√µes no ambiente de produ√ß√£o deve ocorrer obrigatoriamente por meio de uma conex√£o segura (**HTTPS/TLS**), garantindo a prote√ß√£o dos dados. Se o servidor receber credenciais v√°lidas, mas insuficientes para acessar um determinado recurso, ele retornar√° o c√≥digo **HTTP Status 403 (Forbidden)**, indicando que a autentica√ß√£o foi bem-sucedida, mas o usu√°rio n√£o possui permiss√£o para acessar aquele recurso espec√≠fico. Diferente do **HTTP Status 401 (Unauthorized)**, onde a autentica√ß√£o n√£o foi realizada, o c√≥digo **403** indica que o acesso est√° explicitamente negado.

A autentica√ß√£o √© enviada no **Cabe√ßalho da Requisi√ß√£o HTTP**, utilizando a chave **Authorization**, que carrega uma String com as credenciais de autentica√ß√£o. Essa String inicia com o tipo de autentica√ß√£o, seguido por um espa√ßo e pelas credenciais, que podem estar codificadas ou criptografadas, conforme o esquema utilizado. No exemplo anterior, foi adotado o **Esquema de Autentica√ß√£o Bearer**, que ser√° detalhado na sequ√™ncia.

> **Cabe√ßalho HTTP:** Os cabe√ßalhos HTTP permitem que cliente e servidor compartilhem informa√ß√µes adicionais nas requisi√ß√µes e respostas. Um cabe√ßalho de solicita√ß√£o √© composto por um nome (key), que n√£o diferencia letras mai√∫sculas e min√∫sculas (*case-insensitive*), seguido por dois pontos (`:`) e por um valor (value), sem quebras de linha.
>
> **WWW-Authenticate:** Indica o m√©todo de autentica√ß√£o necess√°rio para acessar o recurso protegido.
>
> **Authorization:** Cont√©m as credenciais de autentica√ß√£o (como o token), que identificam e autorizam o agente de usu√°rio (User-Agent) junto ao servidor.

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Status/401" target="_blank"><b>Documenta√ß√£o: HTTP Status Code 401 - Unauthorized</b></a></div>

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Status/403" target="_blank"><b>Documenta√ß√£o: HTTP Status Code 403 - Forbidden</b></a></div>

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/WWW-Authenticate" target="_blank"><b>Documenta√ß√£o: Cabe√ßalho HTTP WWW-Authenticate</b></a></div>

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/Authorization" target="_blank"><b>Documenta√ß√£o: Cabe√ßalho de Requisi√ß√£o HTTP Authorization</b></a></div>

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers" target="_blank"><b>Documenta√ß√£o: Cabe√ßalhos HTTP</b></a></div>

<br />

<h3>2.1. Esquema Bearer</h3>

A estrutura geral de autentica√ß√£o HTTP √© usado por v√°rios esquemas de autentica√ß√£o. Os esquemas podem divergir na for√ßa da seguran√ßa e na disponibilidade do software cliente ou servidor. Os esquemas mais comuns de autentica√ß√£o s√£o o **Basic** e o **Bearer**, mas existem outros esquemas oferecidos por servi√ßos de hospedagem, como AWS, Google ou Microsoft.

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="100px"/> | <div align="left">**ATEN√á√ÉO:** Para melhor compreens√£o no momento, vamos focar apenas no entendimento do formato Bearer, que √© considerado um dos esquemas mais populares. Vale mencionar que para aprender os demais √© necess√°rio tempo e muita dedica√ß√£o.</div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

No projeto Blog Pessoal utilizaremos o esquema **Bearer**, que segundo a sua documenta√ß√£o, consiste em um conjunto de caracteres codificados posicionados ap√≥s a palavra **"Bearer "** (o espa√ßo em branco ap√≥s a palavra Bearer √© obrigat√≥rio), formando um ***Authorization Token*** para ser passado ao sistema. No trecho de c√≥digo abaixo, podemos ver um exemplo simples de um **Token Bearer**:

<div align="center"><img src="https://i.imgur.com/13LBzxE.png" title="source: imgur.com" /></div>

<br />

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="100px"/> | ALERTA DE BSM: Mantenha a Aten√ß√£o aos Detalhes ao escrever o Token no formato Bearer, o mesmo √© representado pela palavra "*Bearer* " com um espa√ßo em branco na frente + um conjunto de caracteres codificados, que s√£o fornecidos ao se autenticar no sistema. |
| ------------------------------------------------------------ | :----------------------------------------------------------- |

<br />

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/Authorization" target="_blank"><b>Documenta√ß√£o: Cabe√ßalho de Requisi√ß√£o HTTP Authorization</b></a></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="25px"/> <a href="https://www.rfc-editor.org/rfc/rfc6750.html" target="_blank"><b>Documenta√ß√£o: Esquema de autentica√ß√£o Bearer</b></a></div>

<br />

<h2>3. O Token JWT</h2>

Existem diversas maneiras de gerar um **Token Bearer**, no Projeto Blog Pessoal, utilizaremos o padr√£o **JWT - JSON WEB Token**. O JWT √© um padr√£o de mercado, muito popular e amplamente utilizado, que define como transmitir e armazenar objetos JSON de forma compacta e segura entre diferentes aplica√ß√µes. Os dados nele contidos  podem ser validados a qualquer momento pois o token √© assinado digitalmente. Na imagem abaixo, vemos a estrutura de um Token JWT:

<div align="center"><img src="https://i.imgur.com/EEoVRt4.png" title="source: imgur.com" /></div>

Um Token JWT √© formado por tr√™s se√ß√µes: **Header, Payload e Signature.**

O **Header** (cabe√ßalho do token) √© um objeto JSON que define as informa√ß√µes sobre o tipo do token (typ), nesse caso JWT, e o algor√≠tmo de criptografia usado em sua  assinatura (alg), normalmente **HMAC SHA256**. No c√≥digo abaixo, vemos um exemplo de cabe√ßalho:

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

O **Payload** √© um objeto JSON que cont√©m as **claims** (informa√ß√µes) da entidade tratada, normalmente o usu√°rio autenticado.

Essas claims podem ser de 3 tipos:

| Tipo         | Descri√ß√£o                                                    |
| ------------ | ------------------------------------------------------------ |
| **Reserved** | S√£o os atributos n√£o obrigat√≥rios (mas recomendados), que s√£o usados na valida√ß√£o do token pelos protocolos de seguran√ßa das APIs. |
| **Public**   | S√£o os atributos que usamos em nossas aplica√ß√µes. Normalmente armazenamos as informa√ß√µes do usu√°rio autenticado na aplica√ß√£o. |
| **Private**  | S√£o os atributos definidos especialmente para compartilhar informa√ß√µes entre aplica√ß√µes, tais como nome do usu√°rio e os direitos de acesso (**Roles, como:** ADMIN, USER, entre outros). |

Na tabela abaixo, temos a lista com as principais Claims utilizadas no payload:

| Claim                | Descri√ß√£o                                                    |
| -------------------- | ------------------------------------------------------------ |
| **sub (subject)**    | Entidade √† quem o token pertence.                            |
| **iss (issuer)**     | Emissor do token.                                            |
| **exp (expiration)** | Timestamp de quando o token ir√° expirar. Observe que a data e hora est√£o em milissegundos. |
| **iat (issued at)**  | Timestamp de quando o token foi criado. Observe que a data e hora est√£o em milissegundos. |
| **aud (audience)**   | Destinat√°rio do token, representa a aplica√ß√£o que ir√° us√°-lo. |

<br />

No c√≥digo abaixo, vemos um exemplo de payload:

```json
{
  "sub": "admin@email.com.br",
  "iat": 1677556617,
  "exp": 1677560217
}
```

Observe que a Claim iat e a Claim exp s√£o inseridas pelo gerador do Token.

<br />

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="100px"/> | ALERTA DE BSM: Mantenha a Aten√ß√£o aos Detalhes ao criar o Token JWT. Por seguran√ßa recomenda-se n√£o armazenar informa√ß√µes confidenciais ou sens√≠veis no payload do token como a senha, por exemplo. |
| ------------------------------------------------------------ | :----------------------------------------------------------- |

<br />

A **SECRET** (chave secreta) √© um elemento fundamental no processo de gera√ß√£o da **Signature** (assinatura) de um Token JWT. Ela √© utilizada como parte do algoritmo de criptografia para garantir que o token seja leg√≠timo e que seu conte√∫do n√£o tenha sido alterado.

### üìå Como a SECRET √© utilizada na assinatura?

Durante a gera√ß√£o da assinatura, o JWT realiza os seguintes passos:

1. **Codifica o Header e o Payload** utilizando o algoritmo **base64UrlEncode**;

2. **Concatena** essas duas partes com um ponto (`.`), formando a seguinte String:

   ```
   base64UrlEncode(Header) + "." + base64UrlEncode(Payload)
   ```

3. Essa String concatenada √© ent√£o **criptografada** utilizando um algoritmo de assinatura, geralmente **HMAC SHA256**, **em conjunto com a SECRET**.

   > Em termos simples, o algoritmo HMAC aplica uma fun√ß√£o hash sobre o conte√∫do codificado (Header + Payload) **usando a SECRET como chave privada**.

4. O resultado dessa opera√ß√£o √© a **Signature** (assinatura), que √© a terceira parte do Token JWT.

Veja o modelo de gera√ß√£o da assinatura na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/VJfphbU.png" title="source: imgur.com" /></div>

Observe que as sess√µes s√£o concatenadas com um ponto (.), separando as sess√µes, seguindo a estrutura: **header.payload.secretKey**. Observe que a Codifica√ß√£o em Base 64 da SECRET est√° habilitada no Debugger.

> ### üîê Para que serve a SECRET?
>
> A **SECRET** funciona como uma ‚Äúchave privada‚Äù que apenas o servidor conhece. Ela √© usada para assinar o token e tamb√©m ser√° utilizada posteriormente para verificar se o token recebido √© v√°lido.
>
> Isso garante duas coisas importantes:
>
> - **Integridade:** Se qualquer parte do token (Header ou Payload) for alterada, a assinatura se tornar√° inv√°lida, pois o conte√∫do original n√£o bater√° com a assinatura gerada usando a SECRET.
> - **Autenticidade:** Apenas quem conhece a SECRET pode gerar uma assinatura v√°lida. Assim, √© poss√≠vel confiar que o token foi realmente gerado pelo servidor autorizado.
>
> ### ‚ö†Ô∏è Boas pr√°ticas:
>
> - A **SECRET** deve ser forte, longa e aleat√≥ria (por exemplo, uma sequ√™ncia de 256 bits).
> - Nunca deve ser exposta ou compartilhada ‚Äî **ela deve permanecer segura no servidor**.
> - √â recomend√°vel utilizar um **gerador de chaves seguras** para criar a SECRET.
> - Em ambientes de produ√ß√£o, a SECRET deve ser armazenada de forma segura, por exemplo, em vari√°veis de ambiente ou cofres de segredos (ex: AWS Secrets Manager, HashiCorp Vault).

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="100px"/> | <div align="left">**ATEN√á√ÉO:** N√£o se preocupe em aprender como cada um destes algoritmos de codifica√ß√£o e criptografia funcionam internamente. O mais importante agora √© saber que eles existem e como us√°-los.</div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

Na imagem abaixo vemos o Token JWT da primeira imagem deste t√≥pico decodificado:

<div align="center"><img src="https://i.imgur.com/QJwmhLQ.png" title="source: imgur.com" /></div>

Para decodificar o Token JWT, foi utilizada a **Ferramenta Debugger do JWT**. Com ela √© poss√≠vel **decodificar o cabe√ßalho e o payload**, como mostra a figura abaixo:

<div align="center"><img src="https://i.imgur.com/CrxE97t.png" title="source: imgur.com" /></div>

Para decodificar o Token JWT, insira a parte **encriptada do Token** (tudo menos a palavra Bearer) no campo **Encoded**, marque o item **secret base64 encoded** e conferir o resultado no campo **Decoded**. A  Assinatura n√£o √© t√£o simples de decodificar, porqu√™ al√©m de usar o Algoritmo **HMAC SHA256**, tamb√©m seria necess√°rio criar um algoritmo espec√≠fico para checagem de Chave P√∫blica e Chave Privada, al√©m de conhecer a Secret Key previamente.

Para implementar o Token JWT no Spring, precisamos adicionar as 3 Depend√™ncias abaixo no arquivo **pom.xml**:

```xml
<!-- Depend√™ncias para Gera√ß√£o e Valida√ß√£o do Token JWT -->
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt-api</artifactId>
	<version>0.11.5</version>
</dependency>
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt-impl</artifactId>
	<version>0.11.5</version>
</dependency>
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt-jackson</artifactId>
	<version>0.11.5</version>
</dependency>
```

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="100px"/> | <div align="left">**ATEN√á√ÉO:** No momento em que este conte√∫do foi escrito, a vers√£o atual da Depend√™ncia JWT era 0.11.5. Ao acessar este conte√∫do a vers√£o mais atual da Depend√™ncia pode ser outra.</div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<div align="left"><img src="https://i.imgur.com/WeNdbPo.png" title="source: imgur.com" width="35px"/> <a href="https://jwt.io/introduction" target="_blank"><b>Documenta√ß√£o: JWT - JSON WEB Token</b></a></div>

<div align="left"><img src="https://i.imgur.com/WeNdbPo.png" title="source: imgur.com" width="35px"/> <a href="https://jwt.io/#debugger-io" target="_blank"><b>Ferramenta: JWT Debugger</b></a></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="25px"/> <a href="https://pt.wikipedia.org/wiki/Base64" target="_blank"><b>Artigo: Modelo Base 64</b></a> - Como funciona o modelo de Codifica√ß√£o Base 64.</div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="25px"/> <a href="https://pt.wikipedia.org/wiki/HMAC" target="_blank"><b>Artigo: Modelo HMAC SHA256</b></a> - Como funciona o modelo de Codifica√ß√£o HMAC SHA256.</div>

<br />

O Token gerado ser√° enviado no Header (cabe√ßalho) de todas as Requisi√ß√µes com endpoints protegidos. Sem o token n√£o for enviado, todos os endpoints protegidos por autentica√ß√£o retornar√£o como resposta o status acesso negado (**UNAUTHORIZED ü°™ 401**).

<br />

<h2>4. Spring Security</h2>

Veja na imagem abaixo, um resumo sobre como a Spring Security funciona:

<div align="center"><img src="https://i.imgur.com/VjrRsjY.png" title="source: imgur.com" /></div>

Observando o Diagrama acima, podemos associar esses componentes com o processo de autentica√ß√£o do Spring Security: receber requisi√ß√£o HTTP, filtrar, autenticar, armazenar os dados de autentica√ß√£o, gerar o token, obter detalhes do usu√°rio, autorizar e tratar exce√ß√µes.

- A Classe **SecurityFilterChain** √© o ponto central da configura√ß√£o de seguran√ßa da aplica√ß√£o. Ela define as regras para os recursos protegidos e n√£o protegidos, configura o CORS (*Cross-Origin Resource Sharing*), o CSRF (*Cross-Site Request Forgery*), o gerenciamento da sess√£o de autentica√ß√£o, e o tipo de autentica√ß√£o adotado. Essa classe pode ser personalizada para adaptar o comportamento da seguran√ßa conforme as necessidades da aplica√ß√£o.
- A Classe **SecurityContextHolder** fornece acesso ao **SecurityContext** atual, permitindo recuperar e definir o estado de autentica√ß√£o do usu√°rio na aplica√ß√£o.
- O **SecurityContext** armazena os dados de autentica√ß√£o do usu√°rio (como o objeto `Authentication`) durante a requisi√ß√£o, at√© que o token expire ou a sess√£o seja encerrada.
- A **Autentica√ß√£o** representa o usu√°rio autenticado no sistema, incluindo suas **credenciais** e **autoridades** (permiss√µes de acesso), conhecidas como **Granted Authorities**.
- A Interface **GrantedAuthority** representa uma permiss√£o concedida ao usu√°rio, como por exemplo `ROLE_ADMIN` ou `ROLE_USER`. Essas permiss√µes s√£o armazenadas em uma cole√ß√£o dentro do objeto de autentica√ß√£o. 
- Em nossa implementa√ß√£o da Spring Security, n√£o aplicaremos controle por **Roles** para simplificar, mas √© necess√°rio implementar os objetos dessa interface para garantir a compatibilidade com a estrutura do Spring Security.
- A Interface **UserDetails** define as informa√ß√µes essenciais do usu√°rio autenticado, como o usu√°rio (geralmente o e-mail), senha e permiss√µes, al√©m de propriedades adicionais como conta expirada, conta bloqueada, entre outras. Essa interface √© usada internamente para criar objetos de autentica√ß√£o com base nos dados do banco.
- A Interface **UserDetailsService** √© respons√°vel por localizar o usu√°rio no banco de dados, a partir do e-mail (ou outro identificador), e construir um objeto **UserDetails** que represente esse usu√°rio. O provedor de autentica√ß√£o utiliza essa interface como base para validar as credenciais.
- Em nossa aplica√ß√£o, a Interface **UserDetailsService** ser√° integrada ao banco de dados por meio do **Spring Data JPA**, utilizando um reposit√≥rio como a Interface **UsuarioRepository**, que buscar√° o usu√°rio e retornar√° um objeto da interface **UserDetails** para ser utilizado pelo Spring Security no processo de autentica√ß√£o.
- A Classe **JwtAuthFilter** estende a Classe **OncePerRequestFilter**. Essa classe atua como um filtro personalizado, que intercepta todas as requisi√ß√µes HTTP, extrai o Token JWT do cabe√ßalho da requisi√ß√£o, valida esse token e, se for v√°lido, registra a autentica√ß√£o no **SecurityContext**.
- A Classe **OncePerRequestFilter** √© utilizada para garantir que o filtro de autentica√ß√£o seja executado apenas uma vez por requisi√ß√£o. Nela, implementamos o m√©todo **doFilterInternal()**, respons√°vel por validar o Token JWT (com aux√≠lio da Classe **JwtService**), buscar os detalhes do usu√°rio (via **UserDetailsService**), e criar uma inst√¢ncia de autentica√ß√£o que ser√° registrada no **SecurityContext**.
- A Classe **JwtService** √© respons√°vel por gerar, assinar e validar o Token JWT, a partir dos dados presentes no objeto **UserDetails**. Essa classe ser√° utilizada tanto na camada de seguran√ßa, quanto no **UsuarioService**, para gerar o token durante o processo de autentica√ß√£o.
- A Classe **UsernamePasswordAuthenticationFilter** captura as credenciais enviadas durante o login (usu√°rio e senha), encapsula essas informa√ß√µes em uma inst√¢ncia de **Authentication**, e delega a autentica√ß√£o ao **AuthenticationManager**.
- O **AuthenticationManager** √© o respons√°vel por coordenar o processo de autentica√ß√£o. Em nossa implementa√ß√£o, ele utilizar√° o **DaoAuthenticationProvider**, que, por sua vez, se integra com a interface **UserDetailsService** e o **PasswordEncoder** para validar o usu√°rio e a senha.
- A Classe **PasswordEncoder** √© respons√°vel pela criptografia da senha do usu√°rio, utilizando um algoritmo de hash seguro, como o **BCrypt**. Ela ser√° utilizada tanto no processo de autentica√ß√£o quanto no cadastro de novos usu√°rios, garantindo que as senhas sejam armazenadas de forma segura.
- A autentica√ß√£o do usu√°rio √© registrada no **SecurityContext** atrav√©s da chamada `SecurityContextHolder.getContext().setAuthentication(...)`, garantindo que o estado da requisi√ß√£o esteja associado ao usu√°rio autenticado.
- A Interface **AuthenticationEntryPoint** √© utilizada para capturar exce√ß√µes de autentica√ß√£o, como tentativas de acesso sem credenciais v√°lidas, e personalizar a resposta retornada ao cliente.
- A Classe **UsuarioController** ser√° respons√°vel por disponibilizar os endpoints relacionados ao CRUD de usu√°rios, al√©m do endpoint de login/autentica√ß√£o.
- A Classe **UsuarioService** concentrar√° as regras de neg√≥cio relacionadas ao usu√°rio, como impedir cadastros duplicados e gerar o Token JWT no momento da autentica√ß√£o.

> **CSRF** (*Cross-Site Request Forgery*, ou *Falsifica√ß√£o de Requisi√ß√£o entre Sites*) √© um tipo de ataque onde um site malicioso faz com que o navegador de um usu√°rio autenticado envie requisi√ß√µes indesejadas para outro site no qual ele j√° est√° autenticado.
>
> Em outras palavras, o atacante "forja" uma requisi√ß√£o v√°lida usando as credenciais da v√≠tima, aproveitando-se do fato de que o navegador envia automaticamente cookies de sess√£o. Esse tipo de ataque √© especialmente perigoso em sistemas que mant√™m sess√µes ativas por meio de cookies, como aplica√ß√µes web tradicionais (baseadas em formul√°rios).

O esquema de autentica√ß√£o descrito acima √© o **HTTP Basic**, um dos mais comuns em APIs REST. Nesse formato, o cliente envia o e-mail (usu√°rio) e a senha por meio de um endpoint p√∫blico, e o Spring Security verifica se as credenciais correspondem a um usu√°rio v√°lido no banco de dados. Uma vez validado, o sistema pode gerar um Token JWT para autentica√ß√£o nas pr√≥ximas requisi√ß√µes.

O principal objetivo do **AuthenticationProvider** √© validar as credenciais fornecidas e retornar um objeto autenticado (`Authentication`) contendo as informa√ß√µes do usu√°rio, incluindo suas autoridades (**GrantedAuthority**).

Para isso, o **AuthenticationProvider** utiliza a Interface **UserDetailsService**, que realiza a busca do usu√°rio no banco de dados e retorna um objeto da Interface **UserDetails**, contendo os dados necess√°rios para a autentica√ß√£o. Essa estrutura √© essencial para controlar o acesso aos recursos da aplica√ß√£o.

A Classe **JwtService** ser√° a respons√°vel por gerar o Token JWT no processo de login e inclu√≠-lo no corpo da resposta HTTP. Nas requisi√ß√µes seguintes, o cliente dever√° enviar esse token no cabe√ßalho da requisi√ß√£o, onde ele ser√° validado pelas Classes **JwtAuthFilter** e **JwtService**. Caso o token seja inv√°lido ou ausente, o acesso ser√° negado. Se o token n√£o for enviado, mas a requisi√ß√£o contiver credenciais v√°lidas no corpo, o sistema poder√° processar a autentica√ß√£o normalmente, conforme a configura√ß√£o definida.

Nos pr√≥ximos t√≥picos veremos todos estes elementos em detalhes.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
