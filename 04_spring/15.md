<h1>Introdu√ß√£o a Spring Security</h1>



<div align="center"><img src="https://i.imgur.com/iyARgVe.png" title="source: imgur.com" /></div>

No cen√°rio atual da tecnologia, especialmente na Internet, nenhuma aplica√ß√£o executada na nuvem pode ficar sem algum tipo de seguran√ßa habilitada. A aus√™ncia de prote√ß√£o exp√µe sistemas a riscos como ataques cibern√©ticos, invas√µes de servidores e roubo de dados.

Ao analisarmos a nossa API do projeto Blog Pessoal, at√© este momento, percebemos que n√£o h√° qualquer tipo de restri√ß√£o: todos os endpoints est√£o abertos e acess√≠veis, permitindo que qualquer pessoa interaja livremente com os recursos. Considerando que a maioria das aplica√ß√µes modernas manipula informa√ß√µes sens√≠veis ‚Äî como dados pessoais, credenciais de acesso e informa√ß√µes financeiras ‚Äî √© fundamental implementar mecanismos para proteger tanto a API quanto os dados que ela processa.

No ecossistema Spring, contamos com o **Spring Security**, um framework robusto que fornece autentica√ß√£o, autoriza√ß√£o, filtros de servlet e diversos recursos adicionais para proteger aplica√ß√µes Java corporativas contra acessos n√£o autorizados. Criado em 2003 por Ben Alex, √© distribu√≠do sob a licen√ßa Apache e faz parte integrante do ecossistema Spring.

A depend√™ncia **spring-boot-starter-security** re√∫ne todos os m√≥dulos necess√°rios para habilitar a seguran√ßa no projeto. Dentro dela, destacam-se tr√™s depend√™ncias principais:

- **spring-security-core** ‚Äì Implementa os recursos centrais de seguran√ßa.
- **spring-security-config** ‚Äì Fornece o contexto e a configura√ß√£o do Spring Security.
- **spring-security-web** ‚Äì Disponibiliza filtros e recursos para prote√ß√£o de aplica√ß√µes web.

Vamos adicionar a **Depend√™ncia Spring Security** no Projeto Blog Pessoal, adicionando as linhas abaixo no arquivo **pom.xml**:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

Na imagem abaixo, vemos a Depend√™ncia inserida no arquivo **pom.xml**:

<div align="center"><img src="https://i.imgur.com/VQAw5S8.png" title="source: imgur.com" /></div>

<br />

üíæ **Salve as altera√ß√µes antes de prosseguir ( File ü°™ Save All )!**

<br />

Execute o projeto e abra a sua aplica√ß√£o no Navegador da Internet atrav√©s do endere√ßo: **http://localhost:8080**, como vemos na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/k19Ci4j.png?2" title="source: imgur.com" /></div>

Como num passe de m√°gica...

- ‚Ä¶ Voc√™ tem uma p√°gina de login gerada automaticamente.
- ‚Ä¶ Voc√™ n√£o consegue mais executar Requisi√ß√µes HTTP (GET, POST, PUT e DELETE).
- ‚Ä¶ Todo o seu aplicativo est√° bloqueado e solicita que voc√™ insira um nome de usu√°rio e uma senha.

Tendo sobrevivido ao susto inicial, voc√™ deve ter pensado: Como tudo isso aconteceu?

Depois de inserir a Depend√™ncia **spring-boot-starter-security**, o Spring habilitar√° alguns padr√µes de configura√ß√£o de seguran√ßa autom√°tica, incluindo a seguran√ßa de todos os endpoints, bem como a defini√ß√£o da estrat√©gia de autentica√ß√£o no formato **httpBasic** (Autentica√ß√£o b√°sica atrav√©s de usu√°rio e senha). 

Al√©m disso, sem fazer nenhuma configura√ß√£o adicional, ele vai criar um nome de usu√°rio padr√£o (**user**) e uma senha, que foi gerada aleatoriamente e pode ser visualizada no console do Spring, como mostra a imagem abaixo. Esses dados podem ser utilizados para fazer login na aplica√ß√£o, atrav√©s da tela de login (veja a imagem anterior) gerada pela Spring Security.

<div align="center"><img src="https://i.imgur.com/dI2DdEm.png" title="source: imgur.com" /></div>

A partir do momento que a Spring Security foi habilitada, foi criado um endpoint de login, que ser√° utilizado para redirecionar as requisi√ß√µes n√£o autenticadas. O redirecionamento aponta para a p√°gina de login padr√£o. No entanto, em um servi√ßo REST, exibir uma p√°gina de login em todas as situa√ß√µes n√£o faz o menor sentido, pois os servi√ßos REST, na maioria das vezes, n√£o ser√£o chamados de forma direta. Servi√ßos REST s√£o chamados por aplicativos clientes personalizados, como um Front-end ou um App Mobile, em vez de solicita√ß√µes diretas do navegador da Internet. 

Nos servi√ßos REST √© altamente recomendado enviar a resposta HTTP Status **401 - Unauthorized**, quando a solicita√ß√£o vier sem autentica√ß√£o, em vez de redirecionar para a p√°gina de login gerada por padr√£o para obter a autentica√ß√£o. Esteja ciente de que, nesse caso, o Status **401 - Unauthorized** significa, n√£o autenticado.

Desta forma, para deixarmos de utilizar esta tela de login padr√£o e futuramente utilizarmos a tela de login do frontend (que ser√° constru√≠do no Bloco 03), ser√° necess√°rio customizar a implementa√ß√£o da Spring Security, mas antes precisamos entender alguns conceitos fundamentais utilizados pela Spring Security e pela maioria dos sistemas de seguran√ßa.

<br />

<h2>1. Seguran√ßa da Aplica√ß√£o - Conceitos</h2>



Antes de estudarmos a Spring Security, vamos compreender alguns conceitos importantes da Seguran√ßa da Informa√ß√£o:

<br />

<h3>1.1. Autentica√ß√£o</h3>



<div align="center"><img src="https://i.imgur.com/oljXzoD.png" title="source: imgur.com" /></div>

Processo de verifica√ß√£o de identidade do usu√°rio (login). Ocorre quando o usu√°rio informa suas credenciais (usu√°rio/e-mail e senha) e o sistema valida se s√£o corretas.

<br />

<h3>1.2. Autoriza√ß√£o</h3>



<div align="center"><img src="https://i.imgur.com/kazNpLz.png" title="source: imgur.com" /></div>

Processo subsequente, que define quais recursos e opera√ß√µes o usu√°rio autenticado est√° autorizado a executar. No Spring Security, essas permiss√µes s√£o representadas por *roles*.

<br />

<h3>1.3. Filtros de Servlet</h3>



<div align="center"><img src="https://i.imgur.com/Hn9NSd6.png" title="source: imgur.com" /></div>

Qualquer aplicativo da Spring WEB √© apenas um **Servlet** (√© uma Classe Java usada para criar aplica√ß√µes WEB), que redireciona todas as Requisi√ß√µes HTTP recebidas, para as suas respectivas Classes Controladoras (**@RestControllers**). 

> Um **Servlet** √© um componente **Java do lado do servidor**, utilizado para processar requisi√ß√µes HTTP e gerar respostas din√¢micas,  geralmente em aplica√ß√µes web. Ele funciona como uma ponte entre o  cliente (navegador ou ferramenta como o Insomnia) e o servidor de  aplica√ß√µes (como o Tomcat). Em outras palavras, um servlet √© como um **programa Java que roda dentro de um servidor** e **responde a requisi√ß√µes da web**.

Como nestas Requisi√ß√µes HTTP n√£o existe uma seguran√ßa e os processos de autentica√ß√£o e autoriza√ß√£o devem ser efetuadas antes das Requisi√ß√µes HTTP chegarem na Classe Controladora, a Spring Security oferece como solu√ß√£o para estes problemas os **Filtros de Servlet**, que na pr√°tica s√£o Objetos Java que interceptam toda e qualquer Requisi√ß√£o HTTP recebida antes de chegarem na Classe Controladora e efetuam algum tipo de processamento. Por isso que o seu Blog Pessoal est√° "trancado" ap√≥s a inser√ß√£o da Depend√™ncia Spring Security.

A figura acima, ilustra o filtro **UsernamePasswordAuthenticationFilter** checando se a Requisi√ß√£o possui os Atributos  usuario (e-mail) e a senha. Se os dados estiverem corretos, o **Filtro de Servlet** autentica o usu√°rio e libera o acesso ao sistema. Caso contr√°rio, ele retorna o Status **401 - Unauthorized**.

Ao adicionar a Depend√™ncia Spring Security, 15 Filtros de Servlet s√£o habilitados por padr√£o, onde cada um tem uma fun√ß√£o espec√≠fica. Ao customizar as configura√ß√µes da Spring Security voc√™ pode definir quais filtros ser√£o habilitados, quais filtros ser√£o desabilitados e ainda criar e habilitar filtros personalizados criados pela pessoa desenvolvedora. N√£o abordaremos este assunto em detalhes por ser muito extenso, por demandar muito tempo e dedica√ß√£o, mas de qualquer forma criaremos um **Filtro de Servlet** personalizado para validar as Requisi√ß√µes HTTP. 

<br />

<h3>1.4. Token</h3>



<div align="center"><img src="https://i.imgur.com/13LBzxE.png" title="source: imgur.com" /></div>

Parte integrante da Autentica√ß√£o, um **Token** √© um dado, que aparentemente n√£o tem significado ou uso por si s√≥, mas quando combinado com o sistema de seguran√ßa correto, torna-se parte vital da seguran√ßa de seu aplicativo. A autentica√ß√£o baseada em token garante que cada solicita√ß√£o a um servidor seja acompanhada por um token assinado,  que o servidor verifica a sua autenticidade e s√≥ ent√£o responde √† solicita√ß√£o. Um bom exemplo do uso do Token, s√£o os aplicativos de Internet Banking, que em todas as transa√ß√µes financeiras gera um novo token para autorizar a opera√ß√£o.

A imagem acima, ilustra um **Token no formato Bearer**. Para cada usu√°rio autenticado no sistema, ser√° gerado um Token, com prazo de validade, que posteriormente ser√° enviado no Cabe√ßalho de todas Requisi√ß√µes HTTP. Requisi√ß√µes HTTP sem um Token v√°lido ser√£o rejeitadas pelos endpoints protegidos da aplica√ß√£o. A valida√ß√£o de um Token funciona como um funil (Filtro de Servlet), onde s√≥ passam as Requisi√ß√µes que possuem um Token v√°lido, mesmo com o usu√°rio estando autenticado.

<br />

<h4>1.4.1. Por que precisamos do Token?</h4>



Quando voc√™ envia uma Requisi√ß√£o HTTP para uma API, se o recurso precisar de autoriza√ß√£o para acessar, primeiro voc√™ precisa provar que possui a autoriza√ß√£o e faz isso enviando seu nome de usu√°rio e senha. Agora, imagine que voc√™ precise acessar os recursos desse servidor v√°rias vezes. Nessa situa√ß√£o, voc√™ precisaria enviar o seu nome de usu√°rio e senha em todas as tentativas de acessar o recurso.

Voc√™ n√£o precisaria fazer isso se a sua aplica√ß√£o guardasse o estado atual da autentica√ß√£o. Entretanto, vamos relembrar que uma API REST n√£o guarda o estado, ou seja, uma Requisi√ß√£o n√£o depende e/ou utiliza dados de uma Requisi√ß√£o anterior, logo √© necess√°rio encontrar outra maneira de autorizar os usu√°rios, em vez de solicitar o nome de usu√°rio e a senha em todas as solicita√ß√µes.

Como solu√ß√£o para este problema, surge a **Autoriza√ß√£o Baseada em Token**. Quando voc√™ entra em um sistema fornecendo seu nome de usu√°rio e senha, o sistema gera um Token para voc√™ com os dados de autoriza√ß√£o necess√°rios dentro dele. Esse Token √© enviado a voc√™ como resposta √† sua Requisi√ß√£o de autentica√ß√£o. Para qualquer Requisi√ß√£o de acesso a recursos do servidor, voc√™ pode enviar esse Token em vez de enviar o seu nome de usu√°rio e senha.

<br />

<h2>2. Conhecendo o HTTP Authentication</h2>



O **IETF (*Internet Engineering Task Force*)** √© a for√ßa-tarefa respons√°vel por identificar e propor solu√ß√µes para problemas relacionados ao uso da Internet, al√©m de estabelecer a padroniza√ß√£o das tecnologias e protocolos envolvidos. Entre essas padroniza√ß√µes, est√° a defini√ß√£o da estrutura de autentica√ß√£o HTTP, utilizada pelos servidores para solicitar a autentica√ß√£o dos clientes.

Em uma autentica√ß√£o baseada em token, o servidor responde a requisi√ß√£o do cliente com o **HTTP Status 401 (Unauthorized)**, informando que a requisi√ß√£o n√£o possui credenciais v√°lidas, quando o token n√£o √© enviado no cabe√ßalho da requisi√ß√£o ou quando ele n√£o √© validado. Junto a essa resposta, o servidor envia o cabe√ßalho **WWW-Authenticate**, contendo informa√ß√µes sobre o m√©todo de autentica√ß√£o exigido. O cliente, ao receber essa resposta, poder√° reenviar a requisi√ß√£o incluindo no cabe√ßalho, na chave **Authorization**, as credenciais necess√°rias conforme o m√©todo indicado, geralmente um token. No Diagrama de Sequ√™ncia abaixo pode se observar este relacionamento:

<div align="center"><img src="https://i.imgur.com/skGtKqr.png" title="source: imgur.com" /></div>

No caso da **Autentica√ß√£o Bearer** (como ilustrado na imagem acima), a troca de informa√ß√µes no ambiente de produ√ß√£o deve ocorrer obrigatoriamente por meio de uma conex√£o segura (**HTTPS/TLS**), garantindo a prote√ß√£o dos dados. Se o servidor receber credenciais v√°lidas, mas insuficientes para acessar um determinado recurso, ele retornar√° o c√≥digo **HTTP Status 403 (Forbidden)**, indicando que a autentica√ß√£o foi bem-sucedida, mas o usu√°rio n√£o possui permiss√£o para acessar aquele recurso espec√≠fico. Diferente do **HTTP Status 401 (Unauthorized)**, onde a autentica√ß√£o n√£o foi realizada, o c√≥digo **403** indica que o acesso est√° explicitamente negado.

A autentica√ß√£o √© enviada no **Cabe√ßalho da Requisi√ß√£o HTTP**, utilizando a chave **Authorization**, que carrega uma String com as credenciais de autentica√ß√£o. Essa String inicia com o tipo de autentica√ß√£o, seguido por um espa√ßo e pelas credenciais, que podem estar codificadas ou criptografadas, conforme o esquema utilizado. No exemplo anterior, foi adotado o **Esquema de Autentica√ß√£o Bearer**, que ser√° detalhado na sequ√™ncia.

> **Cabe√ßalho HTTP:** Os cabe√ßalhos HTTP permitem que cliente e servidor compartilhem informa√ß√µes adicionais nas requisi√ß√µes e respostas. Um cabe√ßalho de solicita√ß√£o √© composto por um nome (key), que n√£o diferencia letras mai√∫sculas e min√∫sculas (*case-insensitive*), seguido por dois pontos (`:`) e por um valor (value), sem quebras de linha.
>
> **WWW-Authenticate:** Indica o m√©todo de autentica√ß√£o necess√°rio para acessar o recurso protegido.
>
> **Authorization:** Cont√©m as credenciais de autentica√ß√£o (como o token), que identificam e autorizam o agente de usu√°rio (User-Agent) junto ao servidor.

<br />

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="4%"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Status/401" target="_blank"><b>Documenta√ß√£o: HTTP Status Code 401 - Unauthorized</b></a></div>

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="4%"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Status/403" target="_blank"><b>Documenta√ß√£o: HTTP Status Code 403 - Forbidden</b></a></div>

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="4%"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/WWW-Authenticate" target="_blank"><b>Documenta√ß√£o: Cabe√ßalho HTTP WWW-Authenticate</b></a></div>

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="4%"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/Authorization" target="_blank"><b>Documenta√ß√£o: Cabe√ßalho de Requisi√ß√£o HTTP Authorization</b></a></div>

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="4%"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers" target="_blank"><b>Documenta√ß√£o: Cabe√ßalhos HTTP</b></a></div>

<br />

<h3>2.1. Esquema Bearer</h3>



A estrutura geral de autentica√ß√£o HTTP √© usado por v√°rios esquemas de autentica√ß√£o. Os esquemas podem divergir na for√ßa da seguran√ßa e na disponibilidade do software cliente ou servidor. Os esquemas mais comuns de autentica√ß√£o s√£o o **Basic** e o **Bearer**, mas existem outros esquemas oferecidos por servi√ßos de hospedagem, como AWS, Google ou Microsoft.

<br />

> [!WARNING]
>
> Para melhor compreens√£o no momento, vamos focar apenas no entendimento do formato Bearer, que √© considerado um dos esquemas mais populares. Vale mencionar que para aprender os demais formatos √© necess√°rio tempo e muita dedica√ß√£o.

<br />

No projeto Blog Pessoal utilizaremos o esquema **Bearer (Portador)**, que segundo a sua documenta√ß√£o, consiste em um conjunto de caracteres codificados posicionados ap√≥s a palavra **"Bearer "** (o espa√ßo em branco ap√≥s a palavra Bearer √© obrigat√≥rio), formando um ***Authorization Token*** para ser passado ao sistema. No trecho de c√≥digo abaixo, podemos ver um exemplo simples de um **Token Bearer**:

<div align="center"><img src="https://i.imgur.com/13LBzxE.png" title="source: imgur.com" /></div>

<br />

> [!NOTE]
>
> **Alerta de BSM**
>
> *Mantenha a aten√ß√£o aos detalhes*
>
> Ao construir o Token no formato **Bearer**, **lembre-se que ele deve conter a palavra `Bearer` seguida de um espa√ßo em branco**, antes do conjunto de caracteres codificados do token.
>
> O formato correto √©: `"Bearer " + <token_codificado>`
>
> **Caso o espa√ßo em branco ap√≥s a palavra `Bearer` seja omitido, o token pode ser interpretado incorretamente** pelos sistemas que validam a autentica√ß√£o, causando falhas no processo.
>
> Sempre garanta que a constru√ß√£o do token siga exatamente esse padr√£o para evitar erros na autentica√ß√£o.

<br />

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="4%"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/Authorization" target="_blank"><b>Documenta√ß√£o: Cabe√ßalho de Requisi√ß√£o HTTP Authorization</b></a></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="4%"/> <a href="https://www.rfc-editor.org/rfc/rfc6750.html" target="_blank"><b>Documenta√ß√£o: Esquema de autentica√ß√£o Bearer</b></a></div>

<br />

<h2>3. O Token JWT</h2>



Existem diversas maneiras de gerar um **Token Bearer**, no Projeto Blog Pessoal, utilizaremos o padr√£o **JWT - JSON WEB Token**. O JWT √© um padr√£o de mercado, muito popular e amplamente utilizado, que define como transmitir e armazenar objetos JSON de forma compacta e segura entre diferentes aplica√ß√µes. Os dados nele contidos  podem ser validados a qualquer momento pois o token √© assinado digitalmente. Na imagem abaixo, vemos a estrutura de um Token JWT:

<div align="center"><img src="https://i.imgur.com/EEoVRt4.png" title="source: imgur.com" /></div>

Um Token JWT √© formado por tr√™s se√ß√µes: **Header, Payload e Signature.**

O **Header** (cabe√ßalho do token) √© um objeto JSON que define as informa√ß√µes sobre o tipo do token (typ), nesse caso JWT, e o algor√≠tmo de criptografia usado em sua  assinatura (alg), normalmente **HMAC SHA256**. No c√≥digo abaixo, vemos um exemplo de cabe√ßalho:

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

O **Payload** √© um objeto JSON que cont√©m as **claims** (informa√ß√µes) da entidade tratada, normalmente o usu√°rio autenticado.

Essas claims podem ser de 3 tipos:

| Tipo         | Descri√ß√£o                                                    |
| ------------ | ------------------------------------------------------------ |
| **Reserved** | S√£o os atributos n√£o obrigat√≥rios (mas recomendados), que s√£o usados na valida√ß√£o do token pelos protocolos de seguran√ßa das APIs. |
| **Public**   | S√£o os atributos que usamos em nossas aplica√ß√µes. Normalmente armazenamos as informa√ß√µes do usu√°rio autenticado na aplica√ß√£o. |
| **Private**  | S√£o os atributos definidos especialmente para compartilhar informa√ß√µes entre aplica√ß√µes, tais como nome do usu√°rio e os direitos de acesso (**Roles, como:** ADMIN, USER, entre outros). |

Na tabela abaixo, temos a lista com as principais Claims utilizadas no payload:

| Claim                | Descri√ß√£o                                                    |
| -------------------- | ------------------------------------------------------------ |
| **sub (subject)**    | Entidade √† quem o token pertence.                            |
| **iss (issuer)**     | Emissor do token.                                            |
| **exp (expiration)** | Timestamp de quando o token ir√° expirar. Observe que a data e hora est√£o em milissegundos. |
| **iat (issued at)**  | Timestamp de quando o token foi criado. Observe que a data e hora est√£o em milissegundos. |
| **aud (audience)**   | Destinat√°rio do token, representa a aplica√ß√£o que ir√° us√°-lo. |

<br />

No c√≥digo abaixo, vemos um exemplo de payload:

```json
{
  "sub": "admin@email.com.br",
  "iat": 1677556617,
  "exp": 1677560217
}
```

Observe que a Claim iat e a Claim exp s√£o inseridas pelo gerador do Token.

<br />

> [!NOTE]
>
> **Alerta de BSM**
>
> *Mantenha a aten√ß√£o aos detalhes*
>
> Por quest√µes de seguran√ßa, **n√£o armazene informa√ß√µes confidenciais ou sens√≠veis no payload do token JWT**, como senhas, dados pessoais cr√≠ticos ou informa√ß√µes financeiras.
>
> O payload do token √© facilmente decodific√°vel, mesmo sem a chave secreta, o que pode expor dados sens√≠veis caso armazenados indevidamente.
>
> Armazene no token apenas as informa√ß√µes estritamente necess√°rias para a autentica√ß√£o e autoriza√ß√£o, como o identificador do usu√°rio e suas permiss√µes (roles).

<br />

A **SECRET** (chave secreta) √© um elemento fundamental no processo de gera√ß√£o da **Signature** (assinatura) de um Token JWT. Ela √© utilizada como parte do algoritmo de criptografia para garantir que o token seja leg√≠timo e que seu conte√∫do n√£o tenha sido alterado.

<br />

### üìå Como a SECRET √© utilizada na assinatura?



Durante a gera√ß√£o da assinatura, o JWT realiza os seguintes passos:

1. **Codifica o Header e o Payload** utilizando o algoritmo **base64UrlEncode**;

2. **Concatena** essas duas partes com um ponto (`.`), formando a seguinte String:

   ```
   base64UrlEncode(Header) + "." + base64UrlEncode(Payload)
   ```

3. Essa String concatenada √© ent√£o **criptografada** utilizando um algoritmo de assinatura, geralmente **HMAC SHA256**, **em conjunto com a SECRET**.

   > Em termos simples, o algoritmo HMAC aplica uma fun√ß√£o hash sobre o conte√∫do codificado (Header + Payload) **usando a SECRET como chave privada**.
   >
   > **Fun√ß√£o hash** √© um processo que transforma qualquer dado (como uma senha) em uma sequ√™ncia fixa de n√∫meros e letras, de forma √∫nica e dif√≠cil de reverter, usada para proteger informa√ß√µes confidenciais.

4. O resultado dessa opera√ß√£o √© a **Signature** (assinatura), que √© a terceira parte do Token JWT.

Veja o modelo de gera√ß√£o da assinatura na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/VJfphbU.png" title="source: imgur.com" /></div>

Observe que as sess√µes s√£o concatenadas com um ponto (.), separando as sess√µes, seguindo a estrutura: **header.payload.secretKey**. Observe que a Codifica√ß√£o em Base 64 da SECRET est√° habilitada no Debugger.

> ### üîê Para que serve a SECRET?
>
> A **SECRET** funciona como uma ‚Äúchave privada‚Äù que apenas o servidor conhece. Ela √© usada para assinar o token e tamb√©m ser√° utilizada posteriormente para verificar se o token recebido √© v√°lido.
>
> Isso garante duas coisas importantes:
>
> - **Integridade:** Se qualquer parte do token (Header ou Payload) for alterada, a assinatura se tornar√° inv√°lida, pois o conte√∫do original n√£o bater√° com a assinatura gerada usando a SECRET.
> - **Autenticidade:** Apenas quem conhece a SECRET pode gerar uma assinatura v√°lida. Assim, √© poss√≠vel confiar que o token foi realmente gerado pelo servidor autorizado.
>
> ### ‚ö†Ô∏è Boas pr√°ticas:
>
> - A **SECRET** deve ser forte, longa e aleat√≥ria (por exemplo, uma sequ√™ncia de 256 bits).
> - Nunca deve ser exposta ou compartilhada ‚Äî **ela deve permanecer segura no servidor**.
> - √â recomend√°vel utilizar um **gerador de chaves seguras** para criar a SECRET.
> - Em ambientes de produ√ß√£o, a SECRET deve ser armazenada de forma segura, por exemplo, em vari√°veis de ambiente ou cofres de segredos (exemplos: AWS Secrets Manager, HashiCorp Vault, entre outros).

<br />

> [!WARNING]
>
> N√£o se preocupe em entender o funcionamento interno de cada algoritmo de codifica√ß√£o e criptografia neste momento. O mais importante agora √© conhecer sua exist√™ncia e aprender como utiliz√°-los corretamente.

<br />

Na imagem abaixo vemos o Token JWT da primeira imagem deste t√≥pico decodificado:

<div align="center"><img src="https://i.imgur.com/QJwmhLQ.png" title="source: imgur.com" /></div>

Para decodificar o Token JWT, foi utilizada a **Ferramenta Debugger do JWT**. Com ela √© poss√≠vel **decodificar o cabe√ßalho e o payload**, como mostra a figura abaixo:

<div align="center"><img src="https://i.imgur.com/CrxE97t.png" title="source: imgur.com" /></div>

Para decodificar o Token JWT, insira a parte **encriptada do Token** (tudo menos a palavra Bearer) no campo **Encoded**, marque o item **secret base64 encoded** e conferir o resultado no campo **Decoded**. A  Assinatura n√£o √© t√£o simples de decodificar, porqu√™ al√©m de usar o Algoritmo **HMAC SHA256**, tamb√©m seria necess√°rio criar um algoritmo espec√≠fico para checagem de Chave P√∫blica e Chave Privada, al√©m de conhecer a Secret Key previamente.

Para implementar o Token JWT no Spring, precisamos adicionar as 3 Depend√™ncias abaixo no arquivo **pom.xml**:

```xml
<!-- Depend√™ncias para Gera√ß√£o e Valida√ß√£o do Token JWT -->
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt-api</artifactId>
	<version>0.12.6</version>
</dependency>
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt-impl</artifactId>
	<version>0.12.6</version>
</dependency>
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt-jackson</artifactId>
	<version>0.12.6</version>
</dependency>
```

<br />

> [!WARNING]
>
> No momento em que este conte√∫do foi escrito, a vers√£o mais recente da depend√™ncia **JJWT** era a **0.12.6**. No entanto, ao acessar este material no futuro, √© poss√≠vel que uma nova vers√£o j√° tenha sido lan√ßada.

<br />

<div align="left"><img src="https://i.imgur.com/WeNdbPo.png" title="source: imgur.com" width="4%"/> <a href="https://jwt.io/introduction" target="_blank"><b>Documenta√ß√£o: JWT - JSON WEB Token</b></a></div>

<div align="left"><img src="https://i.imgur.com/WeNdbPo.png" title="source: imgur.com" width="4%"/> <a href="https://jwt.io/#debugger-io" target="_blank"><b>Ferramenta: JWT Debugger</b></a></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="4%"/> <a href="https://pt.wikipedia.org/wiki/Base64" target="_blank"><b>Artigo: Modelo Base 64 - Como funciona o modelo de Codifica√ß√£o Base 64.</b></a></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="4%"/> <a href="https://pt.wikipedia.org/wiki/HMAC" target="_blank"><b>Artigo: Modelo HMAC SHA256 - Como funciona o modelo de Codifica√ß√£o HMAC SHA256.</b></a></div>

<br />

O Token gerado ser√° enviado no Header (cabe√ßalho) de todas as Requisi√ß√µes com endpoints protegidos. Sem o token n√£o for enviado, todos os endpoints protegidos por autentica√ß√£o retornar√£o como resposta o status acesso negado (**UNAUTHORIZED ü°™ 401**).

<br />

<h2>4. Spring Security</h2>



Ao desenvolver aplica√ß√µes web seguras, um dos desafios mais importantes √© garantir que apenas usu√°rios autorizados possam acessar recursos protegidos. Para isso, utilizamos dois processos fundamentais:

- **Autentica√ß√£o** ‚Äì Confirmar a identidade do usu√°rio.
- **Autoriza√ß√£o** ‚Äì Definir quais a√ß√µes esse usu√°rio pode executar.

Uma abordagem bastante utilizada e eficiente √© a combina√ß√£o de **JWT** (*JSON Web Token*) com o **Spring Security**.

O JWT √© um token digital assinado que cont√©m informa√ß√µes sobre o usu√°rio (como o nome de login) e uma data de expira√ß√£o. Ele √© enviado pelo servidor ao cliente ap√≥s um login bem-sucedido e deve ser inclu√≠do pelo cliente em todas as requisi√ß√µes para endpoints protegidos.

De forma geral, o funcionamento √© dividido em dois momentos, que veremos a seguir.

<br />

<h3>4.1. Fluxo de Autentica√ß√£o no Spring Security</h3>



No Diagrama abaixo, vemos o Fluxo de Autentica√ß√£o do Spring Security:

<div align="center"><img src="https://i.imgur.com/QFlMYfP.png" title="source: imgur.com" /></div>

1. **Usu√°rio envia credenciais**
   - O cliente faz uma requisi√ß√£o `POST` para `/usuarios/logar`, informando usu√°rio e senha.

2. **Verifica√ß√£o inicial de token**

   - O Filtro `JwtAuthFilter` intercepta a requisi√ß√£o e verifica se h√° um token JWT no cabe√ßalho `Authorization`.

   - Como √© um login inicial, **n√£o h√° token**, e o filtro permite que a requisi√ß√£o siga adiante.

3. **Autentica√ß√£o por usu√°rio e senha**

   - O Filtro `UsernamePasswordAuthenticationFilter` l√™ as credenciais do corpo da requisi√ß√£o.

   - Ele aciona o `UserDetailsService` para buscar o usu√°rio no banco de dados.

4. **Busca de usu√°rio**

   - A classe `UserDetailsService` localiza o usu√°rio e retorna um objeto do tipo  `UserDetails` com suas informa√ß√µes, que representa um usu√°rio autenticado.

   - Esse componente **n√£o envia resposta ao cliente** ‚Äî apenas fornece dados para valida√ß√£o da senha.

5. **Valida√ß√£o das credenciais**

   - O Spring Security compara a senha informada com a armazenada, usando o `PasswordEncoder`.

   - Senha inv√°lida ‚Üí **resposta autom√°tica `401 Unauthorized`** pelo Spring Security.

6. **Gera√ß√£o do token JWT**
   - Senha v√°lida ‚Üí a classe de servi√ßo `UsuarioService`, atrav√©s do m√©todo `autenticar`, chama a classe `JwtService` para gerar o token JWT.

7. **Resposta ao cliente**

   - A classe `UsuarioController` retorna os dados do usu√°rio autenticado e o token JWT com status `200 OK`.

   - O token dever√° ser usado nas pr√≥ximas requisi√ß√µes protegidas.

<br />

<h3>Fluxo de Valida√ß√£o com JWT no Spring Security</h3>



No Diagrama abaixo, vemos o Fluxo de Valida√ß√£o do Token JWT do Spring Security, para uma Requisi√ß√£o enviada para o Recurso Postagem:

<div align="center"><img src="https://i.imgur.com/gFnouXe.png" title="source: imgur.com" /></div>

1. **Requisi√ß√£o com token**

   - O cliente envia a requisi√ß√£o para um endpoint protegido (`/postagens`), incluindo o token no cabe√ßalho:

   ```
   Authorization: Bearer <token>
   ```

2. **Intercepta√ß√£o e valida√ß√£o do token**

   - O Filtro `JwtAuthFilter` extrai o token e aciona a classe `JwtService` para validar assinatura e expira√ß√£o.

3. **Token inv√°lido ou expirado**
   - Resposta imediata do Spring Security: **`401 Unauthorized`**.
4. **Token v√°lido**
   - A classe `JwtService` extrai o nome de usu√°rio do token.
   - A classe `UserDetailsService` busca as informa√ß√µes completas do usu√°rio no banco.
5. **Registro da autentica√ß√£o**
   - O Spring Security registra a autentica√ß√£o no `SecurityContextHolder`, permitindo o acesso ao endpoint protegido.
6. **Resposta do recurso**
   - A classe `PostagemController` processa a requisi√ß√£o e retorna a resposta (`200 OK` ou outro status pertinente).

O mesmo processo se aplica a qualquer recurso protegido, n√£o apenas ao recurso `Postagem`.

<br />

## üîë**Pontos Chave**

1. A classe `UserDetailsService` **n√£o envia resposta HTTP**. Sua fun√ß√£o √© **buscar e retornar um objeto da classe `UserDetails`** (Usu√°rio Autenticado), ou lan√ßar `UsernameNotFoundException`) para o processo de autentica√ß√£o.

2. O **Spring Security** trata automaticamente falhas de autentica√ß√£o e autoriza√ß√£o:

   - Sem autentica√ß√£o ‚Üí **HTTP 401** (`AuthenticationEntryPoint`).

   - Sem permiss√£o ‚Üí **HTTP 403** (`AccessDeniedHandler`).

3. A classes **Controller da aplica√ß√£o** s√£o respons√°veis por responder os casos de sucesso:

   - A classe `UsuarioController`, por exemplo, gera a resposta HTTP com os dados do usu√°rio e o token JWT.

   - As respectivas classes Controller de cada recurso (`PostagemController`, `TemaController`, entre outras.) respondem quando a requisi√ß√£o autenticada √© autorizada.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>

