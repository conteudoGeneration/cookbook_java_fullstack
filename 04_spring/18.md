<h1>Projeto 02 - Blog Pessoal - Spring Security - Ecossistema da Seguran√ßa - Parte 02</h1>



### O que veremos nesta se√ß√£o:

1. A classe `JwtService`
2. A classe `JwtAuthFilter`

Dando continuidade √† implementa√ß√£o do **Ecossistema da Seguran√ßa**, vamos avan√ßar com a cria√ß√£o das classes respons√°veis pelo **funcionamento do JWT** (JSON Web Token), que ser√£o essenciais para autentica√ß√£o e autoriza√ß√£o na aplica√ß√£o.

<br />

<h2>üë£ Passo 01 - Criar a Classe JwtService</h2>



A **classe `JwtService`** √© respons√°vel por **criar** e **validar** o token JWT. Esse token ser√° gerado durante o processo de autentica√ß√£o (login) do usu√°rio e posteriormente validado em todas as requisi√ß√µes HTTP enviadas para **endpoints protegidos**, os quais ser√£o definidos na classe `SecurityConfig`, que ser√° implementada mais adiante.

Esta classe deve ser anotada com a anota√ß√£o **`@Component`**, indicando que se trata de um **componente gerenciado pelo Spring**. Isso significa que a classe `JwtService` poder√° **injetar e instanciar qualquer depend√™ncia especificada em sua implementa√ß√£o** em outras classes da aplica√ß√£o, sempre que necess√°rio. Vale destacar que os m√©todos definidos nessa classe s√£o fundamentais para o funcionamento da **Spring Security**.

>**`@Component`:** √© uma anota√ß√£o gen√©rica para marcar qualquer classe como um componente gerenciado pelo Spring. O Spring tamb√©m oferece anota√ß√µes mais espec√≠ficas, como `@Controller`, `@Service` e `@Repository`. Todas elas s√£o **especializa√ß√µes da anota√ß√£o `@Component`**, e funcionam da mesma forma, pois internamente s√£o compostas por ela. Essas anota√ß√µes atuam como "apelidos" (`alias`), cada uma com um **uso indicado conforme sua responsabilidade na arquitetura** da aplica√ß√£o.
>
>O principal diferencial da anota√ß√£o `@Component` √© que ela **permite a detec√ß√£o autom√°tica pelo Spring**, dispensando a necessidade de instanciar objetos manualmente ou declarar usos espec√≠ficos como servi√ßo, controlador ou reposit√≥rio.

<br />

> [!WARNING]
>
> O uso da anota√ß√£o `@Component` n√£o se restringe √† Spring Security. Ela pode ser aplicada em qualquer recurso da aplica√ß√£o, sempre que for necess√°rio que uma classe seja gerenciada pelo Spring.

<br />

Vamos criar e implementar a Classe **JwtService**:

1. Clique com o bot√£o direito do mouse sobre o **pacote com.generation.blogpessoal.security**, na source folder Principal (**src/main/java**), e clique na op√ß√£o **New ü°™ Class**
2. Na janela **New Java Class**, no item **Name**, digite o nome da Classe (**JwtService**), e na sequ√™ncia clique no bot√£o **Finish** para concluir.

Vejamos abaixo a implementa√ß√£o da Classe **JwtService**:

<div align="center"><img src="https://imgur.com/XNLP7Dz.png" title="source: imgur.com" /></div>

**Linha 1:** Atrav√©s do comando **`package`**, estamos informando o nome do pacote (ou camada) em que a classe foi criada. Essa linha √© gerada automaticamente pelo **Spring Tool Suite (STS)** ao criar uma nova classe.

**Linhas 3 a 15:** Com o comando **`import`**, indicamos os pacotes que cont√™m as classes utilizadas na implementa√ß√£o da `JwtService`. Esses imports s√£o fundamentais para o funcionamento da aplica√ß√£o, pois conectam os recursos externos utilizados no c√≥digo.

**Linha 17:** A classe foi anotada com **`@Component`**, indicando que se trata de uma **Classe de Componente**. Isso significa que ser√° gerenciada pelo Spring, podendo **injetar e instanciar depend√™ncias** em outras classes sempre que necess√°rio. Essa abordagem favorece a **inje√ß√£o de depend√™ncia autom√°tica**, um dos pilares do Spring Framework.

**Linha 20:** Foi declarado o atributo **`secret`**, respons√°vel por armazenar a **chave de assinatura do token JWT** (tamb√©m chamada de *secret*). 

Esse atributo possui os seguintes modificadores:

- **`private`**: o atributo s√≥ pode ser acessado dentro da pr√≥pria classe.

O valor atribu√≠do a `secret` √© uma chave criptografada gerada aleatoriamente com o **algoritmo AES**.

<br />

> [!WARNING]
>
> A **chave secreta (`SECRET`) est√° diretamente no c√≥digo apenas por fins educacionais**. Em projetos reais, ela **deve ser armazenada de forma segura**, como em vari√°veis de ambiente ou servi√ßos de cofres de segredo, evitando exposi√ß√£o e riscos de seguran√ßa.

<br />

> üîê **O que √© AES?**
>
> O **Advanced Encryption Standard (AES)** √© uma especifica√ß√£o para criptografia de dados eletr√¥nicos, estabelecida em 2001 pelo **NIST** (National Institute of Standards and Technology) dos EUA. AES √© amplamente utilizado por ser **extremamente seguro**, gerando **chaves fortes e de dif√≠cil quebra**.

<br />

> #Ô∏è‚É£**Como gerar a chave criptografada?**
>
> Para gerar a chave, utilize o site <a href="https://generate-random.org/encryption-key-generator" target="_blank"><b>Key Generator</b></a>, que permite gerar chaves encriptadas aleat√≥rias no formato **SHA 256**, como mostra a imagem abaixo:
>
> <div align="center"><img src="https://imgur.com/I3ZgF9x.png" title="source: imgur.com" /></div>
>
> Clique no link **"Copy KEY"** destacado em amarelo na imagem acima, para copiar a chave hexadecimal gerada e cole no atributo `secret` dentro da classe `JwtService`.
>

<br />

>üìò **O que √© Hexadecimal?**
>
>Hexadecimal √© um sistema num√©rico de **base 16**, que utiliza os s√≠mbolos **0 a 9** e **A a F** para representar os valores.
>
>#### Exemplo:
>
>- O n√∫mero decimal **79**, no sistema bin√°rio, √© representado por: `01001111`
>- No sistema hexadecimal, esse valor √© representado como: **`4F`**
>
>| D√≠gito | Bin√°rio |
>| ------ | ------- |
>| 4      | 0100    |
>| F      | 1111    |

<br />

**Linha 21:** Foi declarado o atributo **`expiration`**, que define o **tempo de validade do token JWT**. Esse atributo utiliza a classe **`Duration`**, da biblioteca `java.time`, para representar uma **dura√ß√£o de tempo de forma clara e segura**. No exemplo acima, o token ter√° validade de **1 hora (60 minutos)** a partir do momento da sua gera√ß√£o.

Esse atributo possui os seguintes modificadores:

- **`private`**: o atributo s√≥ pode ser acessado dentro da pr√≥pria classe.

<br />

> [!WARNING]
>
> O tempo de expira√ß√£o do token foi definido como **60 minutos apenas para fins did√°ticos**. Em ambientes de produ√ß√£o, recomenda-se um tempo **entre 5 e 15 minutos**, dependendo da sensibilidade da aplica√ß√£o e do n√≠vel de seguran√ßa exigido.

<br />

**Linha 23:** Foi declarado o atributo **`signingKey`**, do tipo **SecretKey**, que armazenar√° a **chave de assinatura** utilizada para assinar e validar o token JWT. Essa chave ser√° gerada a partir do atributo `secret`, e ser√° usada pelos algoritmos de assinatura definidos no processo de cria√ß√£o e valida√ß√£o dos tokens.

Esse atributo possui os seguintes modificadores:

- **`private`**: restringe o acesso ao atributo √† pr√≥pria classe.

A classe **`SecretKey`** faz parte do pacote `javax.crypto`, e representa uma **chave secreta criptogr√°fica**, fundamental para garantir a **seguran√ßa e integridade** do token JWT.

<br />

<div align="center"><img src="https://imgur.com/O0H64EV.png" title="source: imgur.com" /></div>

O m√©todo `getSignKey` √© respons√°vel por **inicializar a chave de assinatura** (`signingKey`), utilizando o valor definido no atributo constante `secret`.

**Linha 26:** Verifica se o atributo **`signingKey`** ainda n√£o foi inicializado (**nulo**). Essa verifica√ß√£o evita que uma nova chave seja gerada toda vez que o m√©todo for chamado, garantindo **reuso e melhor desempenho**.

**Linha 27:** Converte a chave secreta (**`secret`**), que est√° codificada em **Base64**, para um **array de bytes**. Essa convers√£o √© necess√°ria porque os algoritmos criptogr√°ficos trabalham com dados bin√°rios, e n√£o com strings.

O m√©todo **`decode()`**, da classe **`Decoders.BASE64`** (presente no pacote `io.jsonwebtoken.io`), √© respons√°vel por realizar essa **decodifica√ß√£o Base64**, transformando a string em bytes.

**Linha 28:** Utiliza o array de bytes para criar uma inst√¢ncia de **chave criptogr√°fica HMAC-SHA**, por meio do m√©todo **`hmacShaKeyFor(...)`**, da classe **`Keys`** (pacote `io.jsonwebtoken.security`). Essa chave √© ent√£o atribu√≠da ao atributo `signingKey`, sendo usada para **assinar e validar tokens JWT**.

**Linha 30:** Retorna a chave gerada (ou reutilizada) no atributo `signingKey`, que ser√° utilizada pelos m√©todos respons√°veis pela cria√ß√£o e verifica√ß√£o da assinatura dos tokens JWT.

> ### Conceitos complementares
>
> Para compreender como um token JWT √© **gerado e validado**, √© importante conhecer dois conceitos fundamentais: **Base64** e o algoritmo **HS256**.
>
> <br />
>
> #### Base64
>
> **Base64** √© um m√©todo de **codifica√ß√£o que converte dados bin√°rios em texto**, amplamente utilizado para **transferir informa√ß√µes pela Internet**. Essa codifica√ß√£o √© necess√°ria quando √© preciso enviar dados bin√°rios (como imagens, arquivos ou chaves criptogr√°ficas) por **meios que aceitam apenas texto**, como:
>
> - Transmiss√£o de anexos por e-mail
> - Inclus√£o de imagens em arquivos HTML ou CSS
> - Codifica√ß√£o de chaves, como ocorre no JWT
>
> <br />
>
> #### HMAC-SHA256 (HS256)
>
> **HMAC-SHA256**, ou simplesmente **HS256**, √© um **algoritmo de assinatura sim√©trica** baseado na fun√ß√£o de hash **SHA-256**. Ele √© utilizado para gerar um **c√≥digo de autentica√ß√£o da mensagem (HMAC)**, garantindo a **integridade e a autenticidade** do conte√∫do de um token JWT.
>
> <br />
>
> **Funcionamento:**
>
> - O emissor do token combina o **cabe√ßalho (header)** e a **carga √∫til (payload)** e aplica a fun√ß√£o de hash utilizando uma **chave secreta compartilhada**.
> - O resultado desse processo √© a **assinatura digital do token**.
> - O destinat√°rio, ao receber o token, usa **a mesma chave secreta** para recalcular a assinatura e **verificar se o token √© v√°lido**.
>
> Como se trata de uma **assinatura sim√©trica**, a **mesma chave secreta** √© usada tanto para gerar quanto para validar o token. Por isso, √© fundamental que essa chave seja **bem protegida e nunca exposta publicamente**, especialmente em ambientes de produ√ß√£o.

<br />

‚úÖ **Resumo:** O m√©todo `getSigningKey` **gera ou recupera a chave secreta usada na assinatura e valida√ß√£o do token JWT**, convertendo o valor codificado em Base64 em uma **chave criptogr√°fica segura (HMAC-SHA)**, garantindo a integridade e autenticidade dos tokens.

<br />

<div align="center"><img src="https://imgur.com/YGF2IrW.png" title="source: imgur.com" /></div>

O M√©todo **`extractAllClaims(...)`** tem como objetivo **extrair todas as \*claims\*** (informa√ß√µes declaradas) do **payload** de um token JWT. As *claims* podem incluir dados como `sub` (usu√°rio), `exp` (expira√ß√£o), `iat` (data de cria√ß√£o), entre outros, definidos no momento da gera√ß√£o do token.

<br />

> [!TIP]
>
> üëâ Caso voc√™ tenha alguma d√∫vida sobre o Token JWT, header, payload, claim, entre outras, **consulte o conte√∫do <a href="15.md">Introdu√ß√£o a Spring Security</a>**.

<br />

**Linha 33:** Observe a assinatura do M√©todo **extractAllClaims(String token)**, que ele retornar√° um objeto da Interface  **Claims**. Note que o M√©todo possui um par√¢metro String, chamado **token**, que receber√° o Token JWT enviado no Cabe√ßalho da Requisi√ß√£o HTTP.

**Linha 34:** O m√©todo `Jwts.parser()` inicializa um **builder de parser**, respons√°vel por interpretar e validar o token JWT.

**Linha 35:** O m√©todo **`.verifyWith(getSigningKey())`** define a **chave secreta** utilizada para **verificar a assinatura do token JWT**. Nesse caso, o m√©todo **`getSigningKey()`** √© chamado para **obter (ou inicializar)** a chave criptogr√°fica a partir do valor definido no atributo **`secret`**, garantindo que a verifica√ß√£o da assinatura seja feita com a **mesma chave usada na gera√ß√£o do token**.

**Linha 36:** O m√©todo **`.build()`** constr√≥i o **parser JWT** com todas as configura√ß√µes definidas anteriormente, finalizando a sua prepara√ß√£o para o processo de valida√ß√£o do token.

> Um **parser** √© um **processador que analisa e interpreta dados**, transformando um texto ou c√≥digo em uma **estrutura compreens√≠vel pelo programa**.
>
> üëâ Em outras palavras: ele **l√™ e entende o conte√∫do** (como um token JWT, um JSON ou um arquivo) para que o sistema possa **usar essas informa√ß√µes de forma organizada**.

**Linha 37:** O m√©todo **`.parseSignedClaims(token)`** realiza o **parse (an√°lise e valida√ß√£o)** do token assinado, verificando sua **assinatura com base na chave fornecida**. Se o token estiver **malformado, expirado** ou tiver **assinatura inv√°lida**, uma **exce√ß√£o ser√° lan√ßada automaticamente**.

**Linha 38:** Ap√≥s a valida√ß√£o da assinatura, o m√©todo **`.getPayload()`** acessa e retorna o **payload do token**, representado por um objeto do tipo **`Claims`**. Esse objeto permite consultar diretamente as informa√ß√µes armazenadas no token, como:

- `claims.getSubject()` ‚Üí retorna o identificador do usu√°rio (`sub`)
- `claims.getExpiration()` ‚Üí retorna a data e hora de expira√ß√£o do token

<br />

‚úÖ **Resumo:** O m√©todo `extractAllClaims` **valida e decodifica o token JWT**, retornando suas informa√ß√µes internas (*claims*) em um objeto seguro (`Claims`), que pode ser utilizado em qualquer l√≥gica de autentica√ß√£o ou autoriza√ß√£o.

<br />

<div align="center"><img src="https://imgur.com/m15jh5Z.png" title="source: imgur.com" /></div>

O M√©todo **`extractUsername(...)`** tem como objetivo **extrair o nome de usu√°rio** (ou identificador principal) armazenado no token JWT.

**Linha 42:** O m√©todo `extractAllClaims(token)` **valida** e **decodifica** o token JWT, obtendo todas as *claims* (informa√ß√µes) contidas no seu **payload**.

O m√©todo `.getSubject()` recupera o valor da **claim padr√£o** chamada `sub` (*subject*), que foi utilizada para representar o **usu√°rio autenticado**. O retorno do m√©todo ser√° do tipo `String`.

<br />

> [!IMPORTANT]
>
> A claim `sub` √© definida no momento da cria√ß√£o do token, atrav√©s do m√©todo `generateToken`, e pode conter o **nome de usu√°rio**, **e-mail** ou qualquer outro identificador √∫nico que represente o usu√°rio na aplica√ß√£o.

<br />

<div align="center"><img src="https://imgur.com/khfl4P8.png" title="source: imgur.com" /></div>

O M√©todo **`extractExpiration(...)`** tem como objetivo **extrair a data e hora de expira√ß√£o** armazenadas no token JWT.

**Linha 46:** O m√©todo `extractAllClaims(token)` **valida** e **decodifica** o token JWT, obtendo todas as *claims* (informa√ß√µes) contidas no seu **payload**.

O m√©todo `.getExpiration()` recupera o valor da **claim padr√£o** chamada `exp` (*expiration*), que indica o **momento exato em que o token se tornar√° inv√°lido**. O retorno do m√©todo ser√° do tipo `Date`.

<br />

> [!IMPORTANT]
>
> A claim `exp` √© definida no momento da cria√ß√£o do token, geralmente no m√©todo `generateToken`, e deve refletir o tempo de expira√ß√£o configurado na aplica√ß√£o. Em produ√ß√£o, recomenda-se definir per√≠odos curtos, geralmente **entre 5 e 15 minutos**, para reduzir riscos de uso indevido.

<br />

<div align="center"><img src="https://imgur.com/CtLM9IJ.png" title="source: imgur.com" /></div>

O m√©todo **`validateToken`** tem como objetivo **garantir que um token JWT √© v√°lido para um usu√°rio espec√≠fico e ainda est√° dentro do prazo de validade**. Em ess√™ncia, ele realiza **duas verifica√ß√µes principais**:

- **Primeiro:** confirma se o identificador do token, conhecido como **`subject`** (campo `sub` dentro do token), **coincide com o nome de usu√°rio (`username`)** presente no objeto **`UserDetails`**, que representa o usu√°rio autenticado.
- **Segundo:** verifica se o token **ainda n√£o expirou**, comparando a data de expira√ß√£o (`exp`) contida no token com o **momento atual**.

Somente quando **ambas as condi√ß√µes s√£o verdadeiras**, o m√©todo retorna **`true`**, indicando que o token √© v√°lido; caso contr√°rio, retorna **`false`**.

**Linha 49:** Declara o m√©todo **`validateToken`**, que recebe dois par√¢metros:

- **`token`**: o JWT em formato de string que ser√° validado;
- **`userDetails`**: objeto que cont√©m as informa√ß√µes do usu√°rio autenticado, incluindo o nome de usu√°rio usado para compara√ß√£o.

**Linha 50:** Chama o m√©todo **`extractAllClaims`**, que recebe o token e **extrai todas as suas informa√ß√µes internas** (*claims*), como o nome do usu√°rio e a data de expira√ß√£o. O resultado √© armazenado na vari√°vel **`claims`**, utilizada nas verifica√ß√µes seguintes.

**Linha 51:** Utiliza o m√©todo **`getSubject()`** para obter o valor da claim **`sub`**, que representa o identificador do usu√°rio no token. Esse valor √© comparado com o **`username`** do objeto **`userDetails`**. Se forem iguais, a valida√ß√£o continua; se forem diferentes, o m√©todo retorna **`false`**, indicando que o token **n√£o pertence ao usu√°rio autenticado**.

**Linha 52:** Verifica se o token **ainda est√° dentro do prazo de validade**. Por meio do m√©todo **`getExpiration()`**, obt√©m-se a data de expira√ß√£o, que √© comparada com a data e hora atuais. Se o token estiver expirado (ou seja, a data de expira√ß√£o for anterior ao momento atual), o m√©todo retorna **`false`**.

Para que o token seja considerado **v√°lido**, as duas condi√ß√µes ‚Äî **correspond√™ncia do usu√°rio e validade temporal** ‚Äî **devem ser satisfeitas simultaneamente**.

> **Como o Token JWT √© enviado?**
>
> O **token JWT** √© enviado no **cabe√ßalho da requisi√ß√£o HTTP**, dentro da propriedade **`Authorization`**. Essa propriedade geralmente cont√©m o token no formato **Bearer**, que √© uma conven√ß√£o usada para indicar que o valor representa um **token de acesso**.
>
> Na imagem abaixo, √© poss√≠vel observar um exemplo de **cabe√ßalho de requisi√ß√£o HTTP** onde o token JWT √© enviado na propriedade **Authorization**, utilizando o esquema **Bearer**:
>
> <div align="center"><img src="https://i.imgur.com/rvvLw2X.png" title="source: imgur.com" /></div>
>

<br />

<div align="center"><img src="https://imgur.com/5JBKCFb.png" title="source: imgur.com" /></div>

O m√©todo **`generateToken`** tem como objetivo **criar um token JWT para um usu√°rio**, utilizando seu **nome de usu√°rio (`username`)**. Esse token cont√©m informa√ß√µes essenciais, como o **identificador do usu√°rio (sub)**, o **momento de cria√ß√£o (Iat)** e a **data de expira√ß√£o (exp)**, al√©m de ser **assinado digitalmente** para garantir **integridade e seguran√ßa**.

**Linha 55:** Declara o m√©todo **`generateToken`**, que retorna uma **string** ‚Äî o token JWT gerado. O m√©todo recebe como par√¢metro o **nome de usu√°rio (`username`)** para o qual o token ser√° criado.

**Linha 56:** Cria a vari√°vel **`now`**, inicializada com o momento atual por meio de **`Instant.now()`**. A classe **`Instant`**, da API **`java.time`**, representa um ponto exato no tempo (com precis√£o de nanossegundos) e √© amplamente utilizada para registrar momentos como **cria√ß√£o e expira√ß√£o de tokens**.

> A classe **`Instant`** √© imut√°vel e faz parte da API moderna de datas e horas do Java (introduzida no Java 8). Ela representa um instante global em **UTC (Tempo Universal Coordenado)**, sem considerar fusos hor√°rios. Por isso, √© ideal em contextos que exigem **precis√£o e padroniza√ß√£o temporal**, como autentica√ß√£o, tokens e registros de eventos.
>
> Al√©m disso, oferece m√©todos para **adi√ß√£o e subtra√ß√£o de dura√ß√µes** e **convers√£o para outros formatos**, como `Date`.

**Linha 57:** Inicia a constru√ß√£o do token JWT com o m√©todo **`Jwts.builder()`**, que permite configurar os **campos e propriedades** do token antes de gerar sua representa√ß√£o final em string.

**Linha 58:** Define o **`subject`** do token, que atua como **identificador principal**. Nesse caso, o valor definido √© o **nome de usu√°rio (`username`)** passado como par√¢metro. O campo `sub` (subject) √© comumente usado para **identificar o usu√°rio associado ao token**.

**Linha 59:** Define a **data de emiss√£o** do token (`issuedAt`), convertendo o **`Instant now`** para o tipo **`Date`**, conforme o formato esperado pela biblioteca. Esse campo registra **o momento exato em que o token foi criado**.

**Linha 60:** Define a **data de expira√ß√£o** do token (`expiration`), somando um intervalo de tempo pr√©-definido (`expiration`) ao instante atual. Esse valor determina **por quanto tempo o token ser√° considerado v√°lido**.

**Linha 61:** Aplica a **assinatura criptogr√°fica** ao token, utilizando a chave obtida pelo m√©todo **`getSigningKey()`**. Essa assinatura garante que **o conte√∫do do token n√£o possa ser alterado** ap√≥s sua gera√ß√£o.

**Linha 62:** Finaliza a constru√ß√£o do token e o **compacta** em uma string, por meio do m√©todo **`compact()`**. O resultado √© o **token JWT final**, pronto para ser **enviado ao cliente** e **utilizado em futuras autentica√ß√µes**.

O M√©todo **`generateToken`**, ao ser executado, retorna um Token JWT semelhante ao da imagem abaixo:

<div align="center"><img src="https://i.imgur.com/Y4X2KzV.png" title="source: imgur.com" /></div>

Esse token possui uma estrutura dividida em tr√™s partes principais, como mostrado na imagem a seguir:

<div align="center"><img src="https://i.imgur.com/EEoVRt4.png" title="source: imgur.com" /></div>

**Relembrando...**

- A primeira parte, chamada **Header**, cont√©m informa√ß√µes sobre o tipo do token (que √© JWT) e o algoritmo usado para assin√°-lo, garantindo a seguran√ßa. Essa parte ajuda o sistema a entender como interpretar e verificar o token.
- A segunda parte, o **Payload**, √© onde ficam os dados importantes, conhecidos como *claims*. √â nessa se√ß√£o que est√£o armazenadas informa√ß√µes como o nome do usu√°rio (subject), a data de emiss√£o e a data de expira√ß√£o do token. Esses dados s√£o usados para identificar o usu√°rio e controlar a validade do token.
- Por fim, a terceira parte √© a **Signature**, que √© uma assinatura digital gerada a partir do conte√∫do do header e do payload, usando uma chave secreta. Essa assinatura serve para garantir que o token n√£o foi alterado durante o transporte e que realmente foi emitido por uma fonte confi√°vel.

<br />

> [!TIP]
>
> üëâ Caso voc√™ tenha alguma d√∫vida sobre o Token JWT, header, payload, claim, entre outras, **consulte o conte√∫do <a href="15.md">Introdu√ß√£o a Spring Security</a>**.

<br />

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="4%"/> <a href="https://pt.wikipedia.org/wiki/Base64" target="_blank"><b>Codifica√ß√£o em Base 64</b></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="4%"/> <a href="https://www.base64url.com" target="_blank"><b>Ferramenta: Codificador Base 64</b></a></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="4%"/> <a href="https://pt.wikipedia.org/wiki/HMAC" target="_blank"><b>Algoritmo HMAC.</b></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="4%"/> <a href="https://pt.wikipedia.org/wiki/SHA-2" target="_blank"><b>Algoritmo SHA256.</b></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="4%"/> <a href="https://generate-random.org/encryption-key-generator" target="_blank"><b>Ferramenta: Key Generator</b></div>

<div align="left"><img src="https://i.imgur.com/WeNdbPo.png" title="source: imgur.com" width="4%"/> <a href="https://jwt.io/introduction" target="_blank"><b>Documenta√ß√£o: JWT - JSON WEB Token</b></a></div>

<div align="left"><img src="https://i.imgur.com/wMe2uG1.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html" target="_blank"><b>Documenta√ß√£o: <i>Classe Duration</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wMe2uG1.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/javase/8/docs/api/javax/crypto/SecretKey.html" target="_blank"><b>Documenta√ß√£o: <i>Interface SecretKey</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wMe2uG1.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html" target="_blank"><b>Documenta√ß√£o:</b><i> Classe Instant</i></a></div>

<div align="left"><img src="https://i.imgur.com/wMe2uG1.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Date.html" target="_blank"><b>Documenta√ß√£o:</b><i> Classe Date</i></a></div>

<div align="left"><img src="https://i.imgur.com/wMe2uG1.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html" target="_blank"><b>Documenta√ß√£o:</b><i> Classe String</i></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/javase/7/docs/api/java/security/Key.html" target="_blank"><b>Documenta√ß√£o: <i>Interface Key</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/doc/io.jsonwebtoken/jjwt-api/0.12.6/io/jsonwebtoken/security/Keys.html" target="_blank"><b>Documenta√ß√£o: <i>Classe Keys</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/static/io.jsonwebtoken/jjwt-api/0.12.6/io/jsonwebtoken/io/Decoders.html" target="_blank"><b>Documenta√ß√£o: <i>Classe Decoders</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/userdetails/UserDetails.html" target="_blank"><b>Documenta√ß√£o: <i>Interface UserDetails</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/static/io.jsonwebtoken/jjwt-api/0.12.6/io/jsonwebtoken/Claims.html" target="_blank"><b>Documenta√ß√£o: <i>Interface Claims</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/static/io.jsonwebtoken/jjwt-api/0.12.6/io/jsonwebtoken/Jwts.html" target="_blank"><b>Documenta√ß√£o: <i>Classe Jwts</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/static/io.jsonwebtoken/jjwt-api/0.12.6/io/jsonwebtoken/Jwt.html" target="_blank"><b>Documenta√ß√£o: <i>Interface Jwt</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/static/io.jsonwebtoken/jjwt-api/0.12.6/io/jsonwebtoken/JwtParserBuilder.html" target="_blank"><b>Documenta√ß√£o: <i>Interface JwtParserBuilder</i></b></a></div>

<br />

üíæ **Salve as altera√ß√µes antes de prosseguir ( File ü°™ Save All )!**

A seguir, veja a implementa√ß√£o completa da classe **`JwtService`**:

```java
package com.generation.blogpessoal.security;

import java.time.Duration;
import java.time.Instant;
import java.util.Date;

import javax.crypto.SecretKey;

import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;

@Component
public class JwtService {

    private String secret = "5367566B59703373367639792F423F4528482B4D6251655468576D5A71347437";
    private Duration expiration = Duration.ofMinutes(60);
    
    private SecretKey signingKey;
        
    private SecretKey getSigningKey() {
        if (signingKey == null) {
            byte[] keyBytes = Decoders.BASE64.decode(secret);
            signingKey = Keys.hmacShaKeyFor(keyBytes);
        }
        return signingKey;
    }
    
    private Claims extractAllClaims(String token) {
        return Jwts.parser()
            .verifyWith(getSigningKey())
            .build()
            .parseSignedClaims(token)
            .getPayload();
    }

    public String extractUsername(String token) {
        return extractAllClaims(token).getSubject();
    }

    public Date extractExpiration(String token) {
        return extractAllClaims(token).getExpiration();
    }

    public boolean validateToken(String token, UserDetails userDetails) {
        Claims claims = extractAllClaims(token);
        return claims.getSubject().equals(userDetails.getUsername()) && 
               claims.getExpiration().after(new Date());
    }

    public String generateToken(String username) {
        Instant now = Instant.now();
        return Jwts.builder()
            .subject(username)
            .issuedAt(Date.from(now))
            .expiration(Date.from(now.plus(expiration)))
            .signWith(getSigningKey())
            .compact();
    }
    
}
```

<br />

<h2>üë£ Passo 02 - Criar a Classe JwtAuthFilter</h2>



A **classe `JwtAuthFilter`** tem a responsabilidade de interceptar e pr√©-processar todas as requisi√ß√µes HTTP, buscando o token JWT que √© enviado no cabe√ßalho da requisi√ß√£o, na propriedade **Authorization**. Ap√≥s extrair o token, essa classe valida sua autenticidade, cria um objeto de autentica√ß√£o correspondente e insere o usu√°rio autenticado no **SecurityContext**. 

O `SecurityContext` √© o componente do Spring Security que mant√©m as informa√ß√µes de autentica√ß√£o do usu√°rio durante a execu√ß√£o da aplica√ß√£o, permitindo que as regras de seguran√ßa sejam aplicadas quando o usu√°rio faz requisi√ß√µes a diferentes endpoints.

No contexto do Spring Security, a **classe `JwtAuthFilter` funciona como um filtro de servlet personalizado (Custom Servlet Filter)**. Isso significa que ela √© inserida na cadeia de filtros do Spring para interceptar cada requisi√ß√£o HTTP, garantindo que o token JWT seja validado antes que a requisi√ß√£o seja processada pela aplica√ß√£o. Assim, qualquer requisi√ß√£o que n√£o contenha um token v√°lido pode ser bloqueada ou tratada adequadamente.

Para que o Spring gerencie essa classe automaticamente, ela deve ser anotada com **`@Component`**. Essa anota√ß√£o indica que o `JwtAuthFilter` √© um componente gerenciado pelo Spring, permitindo a inje√ß√£o e a instancia√ß√£o autom√°tica de suas depend√™ncias em outras classes, sempre que necess√°rio. Al√©m disso, os m√©todos definidos nessa classe s√£o fundamentais para o funcionamento correto da autentica√ß√£o e autoriza√ß√£o no Spring Security, garantindo a seguran√ßa da aplica√ß√£o.

Vamos criar e implementar a Classe **JwtAuthFilter**:

1. Clique com o bot√£o direito do mouse sobre o **pacote com.generation.blogpessoal.security**, na source folder principal (**src/main/java**), e clique na op√ß√£o **New ü°™ Class**
2. Na janela **New Java Class**, no item **Name**, digite o nome da Classe (**JwtAuthFilter**), e na sequ√™ncia clique no bot√£o **Finish** para concluir.

Vejamos abaixo a implementa√ß√£o da Classe **JwtAuthFilter**:

<div align="center"><img src="https://i.imgur.com/dEi2uRD.png" title="source: imgur.com" /></div>

**Linha 1:** A instru√ß√£o **package** define o nome do pacote (ou camada) onde a classe foi criada. Essa declara√ß√£o organiza o c√≥digo dentro da estrutura do projeto e √© adicionada automaticamente pelo STS (Spring Tool Suite) ao criar a classe.

**Linhas 3 a 22:** As declara√ß√µes **import** indicam todos os pacotes e classes externas que s√£o utilizadas dentro da classe **JwtAuthFilter**. Esses imports permitem que a classe acesse funcionalidades fornecidas por outras bibliotecas ou pelo pr√≥prio framework, facilitando o desenvolvimento e a manuten√ß√£o do c√≥digo.

<div align="center"><img src="https://i.imgur.com/OziVzmW.png" title="source: imgur.com" /></div>

**Linha 24:** A classe foi anotada com **`@Component`**, indicando que ela √© um componente gerenciado pelo Spring. Isso significa que o Spring cria e controla a inst√¢ncia dessa classe automaticamente, possibilitando a inje√ß√£o e a instancia√ß√£o de suas depend√™ncias em outras classes sempre que necess√°rio.

**Linha 25:** A classe **`JwtAuthFilter`** estende (herda) a classe **`OncePerRequestFilter`**.

> **Entendendo a classe `OncePerRequestFilter`**
>
> Filtros de servlet podem ser executados m√∫ltiplas vezes durante o processamento de uma requisi√ß√£o HTTP, especialmente quando a requisi√ß√£o √© encaminhada para outras aplica√ß√µes ou recursos. Por√©m, existem situa√ß√µes em que √© importante garantir que um filtro seja executado apenas uma vez por requisi√ß√£o.
>
> Para isso, o Spring oferece a classe abstrata `OncePerRequestFilter`, que assegura que o filtro personalizado, neste caso o `JwtAuthFilter`, seja executado somente uma vez para cada requisi√ß√£o HTTP, evitando execu√ß√µes repetidas desnecess√°rias.

**Linhas 27 a 31:** Foram feitas duas inje√ß√µes de depend√™ncia nesta classe: a primeira √© da classe **`JwtService`**, que disponibiliza m√©todos para valida√ß√£o do token JWT; a segunda √© da classe **`UserDetailsServiceImpl`**, que fornece acesso aos dados do usu√°rio autenticado. Essas depend√™ncias s√£o fundamentais para que o filtro possa validar o token e carregar as informa√ß√µes do usu√°rio corretamente.

<br />

<div align="center"><img src="https://i.imgur.com/XEDknr5.png" title="source: imgur.com" /></div>

O m√©todo **`doFilterInternal`** √© o cora√ß√£o do filtro de autentica√ß√£o JWT. Ele √© chamado para cada requisi√ß√£o HTTP e tem a fun√ß√£o de interceptar a requisi√ß√£o, extrair o token JWT, validar sua autenticidade e, se estiver tudo correto, permitir que o usu√°rio seja autenticado no sistema antes de continuar o processamento.

**Linha 33:** O m√©todo √© anotado com `@Override` porque est√° sobrescrevendo um m√©todo da superclasse, garantindo que a l√≥gica personalizada do filtro seja executada em cada requisi√ß√£o.

**Linha 34:** O m√©todo `doFilterInternal` √© uma implementa√ß√£o do m√©todo abstrato da classe `OncePerRequestFilter`. Ele recebe tr√™s par√¢metros importantes:

- `request`: representa a requisi√ß√£o HTTP que chegou ao servidor;
- `response`: representa a resposta que ser√° enviada ao cliente;
- `filterChain`: controla a cadeia de filtros, permitindo que a requisi√ß√£o continue seu processamento ap√≥s passar por este filtro.

<br />

> [!IMPORTANT]
>
> N√£o √© necess√°rio se preocupar com os tr√™s par√¢metros do m√©todo `doFilterInternal`, pois eles s√£o gerados e fornecidos automaticamente pelo Spring Security.

<br />

Os tr√™s par√¢metros foram anotados com `@NonNull`, indicando que **n√£o devem ser nulos**, ou seja, n√£o podem receber o valor `null`.

Na declara√ß√£o do m√©todo, tamb√©m foi especificado que ele pode lan√ßar as seguintes exce√ß√µes:

- **`ServletException`**: exce√ß√£o espec√≠fica do contexto de servlets em aplica√ß√µes web Java. Indica problemas no processamento da requisi√ß√£o, como erros internos ou falhas no ciclo de vida do servlet.
- **`IOException`**: exce√ß√£o gen√©rica relacionada a opera√ß√µes de entrada e sa√≠da. Geralmente sinaliza problemas ao ler ou escrever dados, como falhas na leitura de arquivos, erros de comunica√ß√£o em rede, entre outros.

**Linhas 38 a 52:** O corpo do m√©todo est√° dentro de um bloco `try-catch` para capturar exce√ß√µes espec√≠ficas relacionadas √† valida√ß√£o do token JWT e autentica√ß√£o do usu√°rio.

**Linha 39:** Chama o m√©todo `extractTokenFromRequest(request)` para extrair o token JWT que pode estar presente no cabe√ßalho da requisi√ß√£o.

**Linhas 41 a 44:** Verifica se o token √© `null` (n√£o existe) ou se j√° existe uma autentica√ß√£o configurada no contexto de seguran√ßa (`SecurityContextHolder`). 

Se qualquer uma dessas condi√ß√µes for verdadeira, o m√©todo simplesmente encaminha a requisi√ß√£o para o pr√≥ximo filtro da cadeia, usando `filterChain.doFilter(request, response)`, e retorna, sem tentar autenticar novamente via token.

Na nossa implementa√ß√£o, o pr√≥ximo filtro da cadeia √© o **`UsernamePasswordAuthenticationFilter`**, respons√°vel por autenticar utilizando credenciais (usu√°rio e senha). Nesse cen√°rio, o Spring Security verificar√° se as credenciais foram enviadas e tentar√° realizar a autentica√ß√£o.

Caso as credenciais n√£o estejam presentes ou n√£o sejam v√°lidas, o Spring Security retornar√° a resposta HTTP **`401 Unauthorized`**, indicando falha na autentica√ß√£o.

**Linha 46:** Caso o token esteja presente e n√£o exista autentica√ß√£o configurada, o m√©todo chama `processJwtAuthentication(request, token)` para validar o token e configurar a autentica√ß√£o do usu√°rio no contexto de seguran√ßa.

**Linha 47:** Ap√≥s tentar a autentica√ß√£o, o m√©todo chama `filterChain.doFilter(request, response)` para garantir que a requisi√ß√£o continue seu processamento normalmente.

**Linhas 49 a 52:** O bloco `catch` captura exce√ß√µes espec√≠ficas que podem ocorrer durante a valida√ß√£o do token JWT, como:

- Token expirado (`ExpiredJwtException`)
- Assinatura inv√°lida (`SignatureException`)
- Token malformado (`MalformedJwtException`)
- Erro de usu√°rio n√£o encontrado (`UsernameNotFoundException`). 

Se alguma dessas exce√ß√µes ocorrer, a resposta HTTP ter√° seu status definido como `401 Unauthorized`, indicando que a autentica√ß√£o falhou.

<br />

<div align="center"><img src="https://i.imgur.com/utvLq8j.png" title="source: imgur.com" /></div>

O m√©todo **`extractTokenFromRequest`** tem a tarefa simples, por√©m fundamental, de extrair o token JWT do cabe√ßalho HTTP da requisi√ß√£o. Ele verifica se o token est√° presente e no formato correto dentro da propriedade `Authorization`, retornando o token puro para ser usado nas etapas seguintes.

**Linha 55:** O m√©todo privado `extractTokenFromRequest` recebe como par√¢metro um objeto `HttpServletRequest`, que representa a requisi√ß√£o HTTP enviada pelo cliente. O m√©todo tem como objetivo extrair o token JWT presente no cabe√ßalho da requisi√ß√£o.

**Linha 57:** Dentro do m√©todo, a vari√°vel `authHeader` recebe o valor do cabe√ßalho **Authorization** da requisi√ß√£o, que cont√©m o token JWT precedido da palavra-chave "Bearer" seguido de um espa√ßo em branco.

> [!WARNING]
>
> **O espa√ßo em branco entre a palavra Bearer e o Token JWT √© obrigat√≥rio.** 

**Linha 59:** O m√©todo verifica se o cabe√ßalho `authHeader` n√£o √© nulo, se come√ßa com a palavra `"Bearer "` e se o seu comprimento √© maior que 7 caracteres (para garantir que o token realmente exista ap√≥s a palavra "Bearer ").

**Linha 60:** Se a verifica√ß√£o for verdadeira, o m√©todo retorna somente a parte do token, removendo a palavra `"Bearer "` e o espa√ßo que a acompanha. Isso √© feito usando o m√©todo `substring(7)`, que pega o texto a partir do √≠ndice 7, ou seja, depois da palavra "Bearer ".

> **Bearer**
>
> Para enviar um Token JWT no cabe√ßalho da requisi√ß√£o HTTP, deve-se utilizar a propriedade **Authorization** com o valor contendo a palavra **Bearer** (que significa "ao portador"), seguida de um espa√ßo em branco e, em seguida, o Token JWT.
>
> **Token JWT:**
>
> <div align="center"><img src="https://i.imgur.com/Y4X2KzV.png" title="source: imgur.com" /></div>
>
> **Token no cabe√ßalho Authorization com a palavra Bearer:**
>
> <div align="center"><img src="https://i.imgur.com/13LBzxE.png" title="source: imgur.com" /></div>
>
> Na valida√ß√£o do Token JWT, √© necess√°rio **remover a palavra "Bearer"** para extrair apenas o token puro e, assim, process√°-lo corretamente.

**Linha 63:** Caso o cabe√ßalho n√£o exista, n√£o comece com `"Bearer "` ou n√£o contenha token, o m√©todo retorna `null`, indicando que n√£o foi poss√≠vel extrair um token v√°lido da requisi√ß√£o.

<br />

<div align="center"><img src="https://i.imgur.com/IWi1VxW.png" title="source: imgur.com" /></div>

Ap√≥s extrair o token, o m√©todo **`processJwtAuthentication`** realiza a valida√ß√£o detalhada: extrai o nome do usu√°rio do token, busca os dados do usu√°rio no sistema, verifica se o token √© v√°lido para aquele usu√°rio e, por fim, configura a autentica√ß√£o no contexto de seguran√ßa, garantindo que o sistema reconhe√ßa o usu√°rio como autenticado durante a requisi√ß√£o.

**Linha 66:** O m√©todo `processJwtAuthentication` recebe dois par√¢metros: a requisi√ß√£o HTTP (`request`) e o token JWT (`token`). Seu prop√≥sito √© validar o token e, se v√°lido, configurar a autentica√ß√£o do usu√°rio no contexto de seguran√ßa.

**Linha 68:** Chama o m√©todo `jwtService.extractUsername(token)` para extrair o nome de usu√°rio presente no token JWT. Esse valor ser√° usado para buscar os detalhes do usu√°rio no sistema.

**Linha 70:** Verifica se o nome de usu√°rio extra√≠do n√£o √© nulo e n√£o est√° vazio (ap√≥s remover espa√ßos em branco do inicio e do fim da String, com o m√©todo `trim`). Isso garante que o token cont√©m um usu√°rio v√°lido para continuar o processo.

**Linha 71:** Caso o usu√°rio seja v√°lido, chama o m√©todo `userDetailsService.loadUserByUsername(username)`, que carrega as informa√ß√µes completas do usu√°rio, incluindo suas permiss√µes e credenciais.

**Linhas 73 a 85:** Verifica se o token √© v√°lido para o usu√°rio carregado, chamando o m√©todo  `jwtService.validateToken(token, userDetails)`. 

**Linhas 75 a 77:** Se o token for v√°lido, cria um objeto `UsernamePasswordAuthenticationToken`, que representa a autentica√ß√£o do usu√°rio no Spring Security, associando o usu√°rio, suas credenciais (aqui, `null` pois n√£o usamos a senha neste contexto) e suas permiss√µes (em nossa implementa√ß√£o, uma cole√ß√£o vazia, porque n√£o implmentamos roles).

**Linha 79:** Por meio do m√©todo **setDetails()** da classe **UsernamePasswordAuthenticationToken**, adicionamos a requisi√ß√£o HTTP ao objeto **authToken**.

Antes disso, √© necess√°rio converter o objeto **request** (da classe **HttpServletRequest**) em uma inst√¢ncia da classe **WebAuthenticationDetailsSource**. Essa classe, interna ao Spring Security, √© utilizada pelos filtros de servlet para processar requisi√ß√µes HTTP.

Como n√£o √© poss√≠vel enviar os dados da requisi√ß√£o HTTP diretamente ao filtro de servlet, o Spring Security usa a **WebAuthenticationDetailsSource** para converter a requisi√ß√£o em um formato adequado e compreens√≠vel para o filtro.

**Linha 81:** Insere a autentica√ß√£o criada no contexto de seguran√ßa atual, `SecurityContextHolder.getContext()`, permitindo que o Spring reconhe√ßa o usu√°rio como autenticado durante o processamento da requisi√ß√£o.

**Linha 84:** Caso o token n√£o seja v√°lido para o usu√°rio, o m√©todo lan√ßa uma exce√ß√£o `RuntimeException` com a mensagem ‚ÄúToken JWT inv√°lido ou expirado‚Äù, interrompendo o fluxo de autentica√ß√£o.

**Linha 88:** Se o nome de usu√°rio n√£o puder ser extra√≠do do token, o m√©todo lan√ßa uma exce√ß√£o `RuntimeException` informando que o usu√°rio n√£o p√¥de ser obtido a partir do token JWT.

<br />

<div align="left"><img src="https://i.imgur.com/wMe2uG1.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html" target="_blank"><b>Documenta√ß√£o: <i>Interface HttpServletRequest</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wMe2uG1.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html" target="_blank"><b>Documenta√ß√£o: <i>Interface HttpServletResponse</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wMe2uG1.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/javase/7/docs/api/java/io/IOException.html" target="_blank"><b>Documenta√ß√£o: <i>Classe IOException</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wMe2uG1.png" title="source: imgur.com" width="4%"/> <a href=https://docs.oracle.com/javaee/7/api/javax/servlet/ServletException.html" target="_blank"><b>Documenta√ß√£o: <i>Classe ServletException</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/filter/OncePerRequestFilter.html" target="_blank"><b>Documenta√ß√£o: <i>Classe OncePerRequestFilter</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/userdetails/UserDetailsService.html" target="_blank"><b>Documenta√ß√£o: <i>Interface UserDetailsService</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/context/SecurityContext.html" target="_blank"><b>Documenta√ß√£o: <i>Classe SecurityContext</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/context/SecurityContextHolder.html" target="_blank"><b>Documenta√ß√£o: <i>Classe SecurityContextHolder</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-security/site/docs/4.0.x/apidocs/org/springframework/security/authentication/UsernamePasswordAuthenticationToken.html" target="_blank"><b>Documenta√ß√£o: <i>Classe UsernamePasswordAuthenticationToken</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-security/site/docs/4.0.x/apidocs/org/springframework/security/web/authentication/WebAuthenticationDetailsSource.html" target="_blank"><b>Documenta√ß√£o: <i>Classe WebAuthenticationDetailsSource</i></b></a></div>


<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/javaee/7/api/javax/servlet/FilterChain.html" target="_blank"><b>Documenta√ß√£o: <i>Interface FilterChain</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/doc/io.jsonwebtoken/jjwt/latest/io/jsonwebtoken/ExpiredJwtException.html" target="_blank"><b>Documenta√ß√£o: <i>Classe ExpiredJwtException</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/static/io.jsonwebtoken/jjwt/0.2/io/jsonwebtoken/UnsupportedJwtException.html" target="_blank"><b>Documenta√ß√£o: <i>Classe UnsupportedJwtException</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/doc/io.jsonwebtoken/jjwt/0.2/io/jsonwebtoken/MalformedJwtException.html" target="_blank"><b>Documenta√ß√£o: <i>Classe MalformedJwtException</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/doc/io.jsonwebtoken/jjwt/0.2/io/jsonwebtoken/SignatureException.html" target="_blank"><b>Documenta√ß√£o: <i>Classe SignatureException</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/server/ResponseStatusException.html" target="_blank"><b>Documenta√ß√£o: <i>Classe ResponseStatusException</i></b></a></div>

<br />

üíæ **Salve as altera√ß√µes antes de prosseguir ( File ü°™ Save All )!**

A seguir, veja a implementa√ß√£o completa da classe **`JwtAuthFilter`**:

```java
package com.generation.blogpessoal.security;

import java.io.IOException;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.MalformedJwtException;
import io.jsonwebtoken.security.SignatureException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

@Component
public class JwtAuthFilter extends OncePerRequestFilter {

    @Autowired
    private JwtService jwtService;

    @Autowired
    private UserDetailsServiceImpl userDetailsService;

    @Override
    protected void doFilterInternal(@NonNull HttpServletRequest request, 
                                   @NonNull HttpServletResponse response, 
                                   @NonNull FilterChain filterChain) throws ServletException, IOException {
        
        try {
            String token = extractTokenFromRequest(request);
            
            if (token == null || SecurityContextHolder.getContext().getAuthentication() != null) {
                filterChain.doFilter(request, response);
                return;
            }
            
            processJwtAuthentication(request, token);
            filterChain.doFilter(request, response);
            
        } catch (ExpiredJwtException | SignatureException | MalformedJwtException
        		| UsernameNotFoundException e) {
        	response.setStatus(HttpStatus.UNAUTHORIZED.value());
        }
    }

    private String extractTokenFromRequest(HttpServletRequest request) {
        
    	String authHeader = request.getHeader("Authorization");
        
        if (authHeader != null && authHeader.startsWith("Bearer ") && authHeader.length() > 7) {
            return authHeader.substring(7);
        }
        
        return null;
    }
    
    private void processJwtAuthentication(HttpServletRequest request, String token) {
        
    	String username = jwtService.extractUsername(token);
        
        if (username != null && !username.trim().isEmpty()) {
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);
            
            if (jwtService.validateToken(token, userDetails)) {
            	
                UsernamePasswordAuthenticationToken authToken = 
                    new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                
                SecurityContextHolder.getContext().setAuthentication(authToken);
                
            } else {
                throw new RuntimeException("Token JWT inv√°lido ou expirado");
            }
            
        } else {
            throw new RuntimeException("Usu√°rio n√£o pode ser extra√≠do do token JWT");
        }
    }

}
```

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="4%"/> <a href="https://github.com/rafaelq80/backend_blogpessoal_spring/tree/11_Spring_Security" target="_blank"><b>C√≥digo fonte do projeto</b></a></div>

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
