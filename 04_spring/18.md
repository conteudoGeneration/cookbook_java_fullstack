<h1>Projeto 02 - Blog Pessoal - Spring Security - Ecossistema da Seguran√ßa - Parte 02</h1>



### O que veremos nesta se√ß√£o:

1. A classe `JwtService`
2. A classe `JwtAuthFilter`

Dando continuidade √† implementa√ß√£o do **Ecossistema da Seguran√ßa**, vamos avan√ßar com a cria√ß√£o das classes respons√°veis pelo **funcionamento do JWT** (JSON Web Token), que ser√£o essenciais para autentica√ß√£o e autoriza√ß√£o na aplica√ß√£o.

<br />

<h2>üë£ Passo 01 - Criar a Classe JwtService</h2>



A **classe `JwtService`** √© respons√°vel por **criar** e **validar** o token JWT. Esse token ser√° gerado durante o processo de autentica√ß√£o (login) do usu√°rio e posteriormente validado em todas as requisi√ß√µes HTTP enviadas para **endpoints protegidos**, os quais ser√£o definidos na classe `SecurityConfig`, que ser√° implementada mais adiante.

Esta classe deve ser anotada com a anota√ß√£o **`@Component`**, indicando que se trata de um **componente gerenciado pelo Spring**. Isso significa que a classe `JwtService` poder√° **injetar e instanciar qualquer depend√™ncia especificada em sua implementa√ß√£o** em outras classes da aplica√ß√£o, sempre que necess√°rio. Vale destacar que os m√©todos definidos nessa classe s√£o fundamentais para o funcionamento da **Spring Security**.

>**`@Component`:** √© uma anota√ß√£o gen√©rica para marcar qualquer classe como um componente gerenciado pelo Spring. O Spring tamb√©m oferece anota√ß√µes mais espec√≠ficas, como `@Controller`, `@Service` e `@Repository`. Todas elas s√£o **especializa√ß√µes da anota√ß√£o `@Component`**, e funcionam da mesma forma, pois internamente s√£o compostas por ela. Essas anota√ß√µes atuam como "apelidos" (`alias`), cada uma com um **uso indicado conforme sua responsabilidade na arquitetura** da aplica√ß√£o.
>
>O principal diferencial da anota√ß√£o `@Component` √© que ela **permite a detec√ß√£o autom√°tica pelo Spring**, dispensando a necessidade de instanciar objetos manualmente ou declarar usos espec√≠ficos como servi√ßo, controlador ou reposit√≥rio.

<br />

> [!WARNING]
>
> O uso da anota√ß√£o `@Component` n√£o se restringe √† Spring Security. Ela pode ser aplicada em qualquer recurso da aplica√ß√£o, sempre que for necess√°rio que uma classe seja gerenciada pelo Spring.

<br />

Vamos criar e implementar a Classe **JwtService**:

1. Clique com o bot√£o direito do mouse sobre o **pacote com.generation.blogpessoal.security**, na source folder Principal (**src/main/java**), e clique na op√ß√£o **New ü°™ Class**
2. Na janela **New Java Class**, no item **Name**, digite o nome da Classe (**JwtService**), e na sequ√™ncia clique no bot√£o **Finish** para concluir.

Vejamos abaixo a implementa√ß√£o da Classe **JwtService**:

<div align="center"><img src="https://i.imgur.com/X8uoafH.png" title="source: imgur.com" /></div>

**Linha 1:** Atrav√©s do comando **`package`**, estamos informando o nome do pacote (ou camada) em que a classe foi criada. Essa linha √© gerada automaticamente pelo **Spring Tool Suite (STS)** ao criar uma nova classe.

**Linhas 3 a 15:** Com o comando **`import`**, indicamos os pacotes que cont√™m as classes utilizadas na implementa√ß√£o da `JwtService`. Esses imports s√£o fundamentais para o funcionamento da aplica√ß√£o, pois conectam os recursos externos utilizados no c√≥digo.

**Linha 17:** A classe foi anotada com **`@Component`**, indicando que se trata de uma **Classe de Componente**. Isso significa que ser√° gerenciada pelo Spring, podendo **injetar e instanciar depend√™ncias** em outras classes sempre que necess√°rio. Essa abordagem favorece a **inje√ß√£o de depend√™ncia autom√°tica**, um dos pilares do Spring Framework.

**Linha 20:** Foi declarado o atributo **`SECRET`**, respons√°vel por armazenar a **chave de assinatura do token JWT** (tamb√©m chamada de *secret*). 

Esse atributo possui os modificadores:

- **`final`**: define que o valor ser√° constante, ou seja, **n√£o poder√° ser alterado ap√≥s a atribui√ß√£o inicial**.
- **`static`**: indica que a vari√°vel pertence √† **classe**, e n√£o a uma inst√¢ncia (objeto) dela. Isso significa que esse valor ser√° compartilhado por todas as inst√¢ncias da `JwtService`.

O valor atribu√≠do a constante `SECRET` √© uma chave criptografada gerada aleatoriamente com o **algoritmo AES**.

<br />

> [!WARNING]
>
> A **chave secreta (`SECRET`) est√° diretamente no c√≥digo apenas por fins educacionais**. Em projetos reais, ela **deve ser armazenada de forma segura**, como em vari√°veis de ambiente ou servi√ßos de cofres de segredo, evitando exposi√ß√£o e riscos de seguran√ßa.

<br />

> üîê **O que √© AES?**
>
>  O **Advanced Encryption Standard (AES)** √© uma especifica√ß√£o para criptografia de dados eletr√¥nicos, estabelecida em 2001 pelo **NIST** (National Institute of Standards and Technology) dos EUA. AES √© amplamente utilizado por ser **extremamente seguro**, gerando **chaves fortes e de dif√≠cil quebra**.

<br />

> #Ô∏è‚É£**Como gerar a chave criptografada?**
>
> Para gerar a chave, utilize o site <a href="https://generate-random.org/encryption-key-generator" target="_blank"><b>Key Generator</b></a>, que permite gerar chaves encriptadas aleat√≥rias no formato **SHA 256**, como mostra a imagem abaixo:
>
> <div align="center"><img src="https://i.imgur.com/alJdfIG.png" title="source: imgur.com" /></div>
>
> Clique em **"Click to copy"** para copiar a chave hexadecimal gerada e cole no atributo `SECRET` dentro da classe `JwtService`.
>

<br />

>üìò **O que √© Hexadecimal?**
>
>Hexadecimal √© um sistema num√©rico de **base 16**, que utiliza os s√≠mbolos **0 a 9** e **A a F** para representar os valores.
>
>#### Exemplo:
>
>- O n√∫mero decimal **79**, no sistema bin√°rio, √© representado por: `01001111`
>- No sistema hexadecimal, esse valor √© representado como: **`4F`**
>
>| D√≠gito | Bin√°rio |
>| ------ | ------- |
>| 4      | 0100    |
>| F      | 1111    |

<br />

**Linha 21:** Foi declarado o atributo constante **`EXPIRATION_DURATION`**, que define o **tempo de validade do token JWT**. Esse atributo utiliza a classe **`Duration`**, da biblioteca `java.time`, para representar uma dura√ß√£o de tempo de forma clara e segura. No exemplo acima, o token ter√° validade de **1 hora (60 minutos)** a partir do momento da sua gera√ß√£o.

Esse atributo possui os seguintes modificadores:

- **`private`**: o atributo s√≥ pode ser acessado dentro da pr√≥pria classe.
- **`static`**: pertence √† classe `JwtService` como um todo, e n√£o a uma inst√¢ncia espec√≠fica.
- **`final`**: o valor n√£o pode ser alterado ap√≥s ser definido (constante).

<br />

> [!WARNING]
>
> O tempo de expira√ß√£o do token foi definido como **60 minutos apenas para fins did√°ticos**. Em ambientes de produ√ß√£o, recomenda-se um tempo **entre 5 e 15 minutos**, dependendo da sensibilidade da aplica√ß√£o e do n√≠vel de seguran√ßa exigido.

<br />

**Linha 23:** Foi declarado o atributo **`signingKey`**, que armazenar√° a **chave de assinatura** utilizada para assinar e validar o token JWT. Essa chave ser√° gerada a partir do atributo `SECRET`, e ser√° usada pelos algoritmos de assinatura definidos no processo de cria√ß√£o e verifica√ß√£o dos tokens.

Esse atributo possui os seguintes modificadores:

- **`private`**: restringe o acesso ao atributo √† pr√≥pria classe.
- **`final`**: indica que esse valor ser√° atribu√≠do **apenas uma vez**, normalmente no **construtor** da classe.

A classe **`SecretKey`** faz parte do pacote `javax.crypto`, e representa uma **chave secreta criptogr√°fica**, fundamental para garantir a **seguran√ßa e integridade** do token JWT.

<br />

<div align="center"><img src="https://i.imgur.com/aB3h7KQ.png" title="source: imgur.com" /></div>

O construtor da classe `JwtService` √© respons√°vel por **inicializar a chave de assinatura** (`signingKey`), utilizando o valor definido no atributo constante `SECRET`.

**Linha 26:** Converte a chave `SECRET` (que est√° em formato **Base64**, uma codifica√ß√£o textual) em um **array de bytes**, que √© o formato esperado pelo algoritmo de assinatura.

O m√©todo `decode()` pertence √† classe **`Decoders.BASE64`**, da biblioteca **`io.jsonwebtoken.io`**, utilizada para manipula√ß√£o de dados codificados.

**Linha 27:** O array de bytes gerado anteriormente √© utilizado para criar uma inst√¢ncia da **chave criptogr√°fica HMAC-SHA**, que ser√° armazenada no atributo `signingKey`.

O m√©todo `hmacShaKeyFor(...)` √© fornecido pela classe **`Keys`**, da biblioteca **`io.jsonwebtoken.security`**, e permite criar uma chave segura a partir de bytes, garantindo compatibilidade com os algoritmos de assinatura utilizados nos tokens JWT (como **HS256**).

> ### Conceitos complementares
>
> Para compreender como o token JWT √© gerado e validado, √© importante entender dois conceitos fundamentais: **Base64** e o algoritmo **HS256**.
>
> <br />
>
> #### Base64
>
> **Base64** √© um m√©todo de **codifica√ß√£o de dados bin√°rios em texto**, muito utilizado para **transfer√™ncia de conte√∫do pela Internet**. Esse formato √© frequentemente utilizado para transmitir dados bin√°rios (como imagens, arquivos ou chaves criptogr√°ficas) por meios que lidam **apenas com texto**, como:
>
> - Transmiss√£o de anexos por e-mail
> - Inclus√£o de imagens em arquivos HTML ou CSS
> - Codifica√ß√£o de chaves, como no caso do JWT
>
> <br />
>
> #### HMAC SHA256 (HS256)
>
> **HMAC SHA256**, ou simplesmente **HS256**, √© um **algoritmo de assinatura sim√©trica** baseado na fun√ß√£o de hash **SHA-256**. Ele √© utilizado para gerar o c√≥digo de autentica√ß√£o da mensagem (HMAC) e garantir a **integridade e autenticidade** do conte√∫do do token JWT.
>
> <br />
>
> **Funcionamento:**
>
> - O emissor do token **anexa o cabe√ßalho e a carga** (payload) e **aplica a fun√ß√£o de hash** utilizando uma **chave secreta compartilhada**.
> - O resultado desse processo √© a **assinatura do token**.
> - O destinat√°rio, ao receber o token, utiliza **a mesma chave secreta** para reproduzir a assinatura e **verificar se o token √© v√°lido**.
>
> **Como √© uma assinatura sim√©trica**, a **mesma chave secreta** √© usada tanto para gerar quanto para validar o token. Por isso, √© fundamental que essa chave seja **bem protegida e n√£o exposta publicamente**, especialmente em ambientes de produ√ß√£o.

<br />

‚úÖ **Resumo:** O construtor transforma a chave `SECRET` codificada em Base64 em uma chave segura do tipo `SecretKey`, adequada para **assinar e validar tokens JWT** com algoritmos HMAC.

<br />

<div align="center"><img src="https://i.imgur.com/A8llALB.png" title="source: imgur.com" /></div>

O M√©todo **`extractAllClaims(...)`** tem como objetivo **extrair todas as \*claims\*** (informa√ß√µes declaradas) do **payload** de um token JWT. As *claims* podem incluir dados como `sub` (usu√°rio), `exp` (expira√ß√£o), `iat` (data de cria√ß√£o), entre outros, definidos no momento da gera√ß√£o do token.

<br />

> [!TIP]
>
> üëâ Caso voc√™ tenha alguma d√∫vida sobre o Token JWT, header, payload, claim, entre outras, **consulte o conte√∫do <a href="15.md">Introdu√ß√£o a Spring Security</a>**.

<br />

**Linha 30:** Observe a assinatura do M√©todo **extractAllClaims(String token)**, que ele retornar√° um objeto da Interface  **Claims**. Note que o M√©todo possui um par√¢metro String, chamado **token**, que receber√° o Token JWT enviado no Cabe√ßalho da Requisi√ß√£o HTTP.

**Linha 31:** O m√©todo `Jwts.parser()` inicializa um **builder de parser**, respons√°vel por interpretar e validar o token JWT.

**Linha 32:** O m√©todo `.verifyWith(signingKey)` define a **chave secreta** usada para **verificar a assinatura** do token. Neste caso, utiliza a vari√°vel `signingKey`, que foi inicializada no construtor da classe a partir do `SECRET`.

**Linha 33:** O m√©todo `.build()` constr√≥i o parser JWT com todas as configura√ß√µes definidas anteriormente.

**Linha 34:** O m√©todo `.parseSignedClaims(token)` realiza o **parse (an√°lise)** do token assinado, verificando sua assinatura com base na chave fornecida. Caso o token esteja malformado, expirado ou com assinatura inv√°lida, uma exce√ß√£o ser√° lan√ßada automaticamente.

**Linha 35:** O m√©todo  `.getPayload()` ap√≥s validar a assinatura, o m√©todo acessa e retorna o **payload do token**, representado como um objeto do tipo `Claims`. Este objeto permite consultar diretamente as informa√ß√µes armazenadas no token, como:

- `claims.getSubject()` que retorna o 'sub' (usu√°rio)
- `claims.getExpiration()` que retorna a data de expira√ß√£o

<br />

‚úÖ **Resumo:** O m√©todo `extractAllClaims` **valida e decodifica o token JWT**, retornando suas informa√ß√µes internas (*claims*) em um objeto seguro (`Claims`), que pode ser utilizado em qualquer l√≥gica de autentica√ß√£o ou autoriza√ß√£o.

<br />

<div align="center"><img src="https://i.imgur.com/Tz1MfX0.png" title="source: imgur.com" /></div>

O M√©todo **`extractUsername(...)`** tem como objetivo **extrair o nome de usu√°rio** (ou identificador principal) armazenado no token JWT.

**Linha 39:** O m√©todo `extractAllClaims(token)` **valida** e **decodifica** o token JWT, obtendo todas as *claims* (informa√ß√µes) contidas no seu **payload**.

O m√©todo `.getSubject()` recupera o valor da **claim padr√£o** chamada `sub` (*subject*), que foi utilizada para representar o **usu√°rio autenticado**. O retorno do m√©todo ser√° do tipo `String`.

<br />

> [!IMPORTANT]
>
> A claim `sub` √© definida no momento da cria√ß√£o do token, atrav√©s do m√©todo `generateToken`, e pode conter o **nome de usu√°rio**, **e-mail** ou qualquer outro identificador √∫nico que represente o usu√°rio na aplica√ß√£o.

<br />

<div align="center"><img src="https://i.imgur.com/M1CLMyR.png" title="source: imgur.com" /></div>

O M√©todo **`extractExpiration(...)`** tem como objetivo **extrair a data e hora de expira√ß√£o** armazenadas no token JWT.

**Linha 43:** O m√©todo `extractAllClaims(token)` **valida** e **decodifica** o token JWT, obtendo todas as *claims* (informa√ß√µes) contidas no seu **payload**.

O m√©todo `.getExpiration()` recupera o valor da **claim padr√£o** chamada `exp` (*expiration*), que indica o **momento exato em que o token se tornar√° inv√°lido**. O retorno do m√©todo ser√° do tipo `Date`.

<br />

> [!IMPORTANT]
>
> A claim `exp` √© definida no momento da cria√ß√£o do token, geralmente no m√©todo `generateToken`, e deve refletir o tempo de expira√ß√£o configurado na aplica√ß√£o. Em produ√ß√£o, recomenda-se definir per√≠odos curtos, geralmente **entre 5 e 15 minutos**, para reduzir riscos de uso indevido.

<br />

<div align="center"><img src="https://i.imgur.com/AxqL0AL.png" title="source: imgur.com" /></div>

O m√©todo `validateToken` tem como objetivo garantir que um token JWT √© v√°lido para um usu√°rio espec√≠fico e que ainda est√° dentro do prazo de validade. Basicamente, ele realiza duas verifica√ß√µes importantes: 

- Primeiro, confirma se o identificador do token, conhecido como `subject` (que corresponde ao campo `sub` dentro do token), coincide com o nome de usu√°rio (`username`) presente no objeto `UserDetails` fornecido, ou seja, o usu√°rio autenticado. 

- Segundo, verifica se o token ainda n√£o expirou, comparando a data de expira√ß√£o (`exp`) contida no token com o momento atual. 

Somente quando essas duas condi√ß√µes s√£o verdadeiras o m√©todo retorna `true`, indicando que o token √© v√°lido; caso contr√°rio, retorna `false`.

**Linha 46:** Declara o m√©todo chamado `validateToken`. Esse m√©todo recebe dois par√¢metros: 

- O primeiro √© `token`, que representa o JWT em formato de string que ser√° validado; 
- O segundo √© `userDetails`, um objeto que cont√©m as informa√ß√µes do usu√°rio autenticado esperado, incluindo o nome de usu√°rio, que ser√° usado para compara√ß√£o.

**Linha 47:** Chama a fun√ß√£o `extractAllClaims`, que recebe o token como entrada e extrai todas as informa√ß√µes contidas nele, chamadas de *claims*. Essas claims incluem dados como o nome do usu√°rio e a data de expira√ß√£o do token. O resultado dessa extra√ß√£o √© armazenado na vari√°vel `claims`, que ser√° usada para as verifica√ß√µes seguintes.

**Linha 48:** Utiliza o m√©todo `getSubject` para obter o valor da claim `sub`, que representa o identificador do usu√°rio dentro do token. Esse valor √© comparado com o nome de usu√°rio do objeto `userDetails` (usu√°rio autenticado). Se os dois forem iguais, a verifica√ß√£o continua; se forem diferentes, o m√©todo retorna `false`, indicando que o token n√£o pertence ao usu√°rio esperado.

**Linha 49:** Al√©m da valida√ß√£o do usu√°rio, o m√©todo verifica se o token ainda est√° v√°lido no tempo. Por meio do m√©todo `getExpiration`, ele obt√©m a data de expira√ß√£o do token e compara com a data e hora atuais (momento em que a verifica√ß√£o √© feita). Caso o token j√° tenha expirado (ou seja, a data e a hora de expira√ß√£o seja anterior ao momento atual), o m√©todo retorna `false`.

Para que o token seja considerado v√°lido, as duas condi√ß√µes ‚Äî a correspond√™ncia do usu√°rio e a validade temporal ‚Äî devem ser verdadeiras ao mesmo tempo.

> **Como o Token JWT √© enviado?**
>
> O token JWT √© enviado no cabe√ßalho da requisi√ß√£o HTTP, especificamente na propriedade chamada `Authorization`. Essa propriedade costuma conter o token no formato **Bearer**, que √© uma conven√ß√£o para indicar que o valor √© um token de acesso. 
>
> Na imagem abaixo, voc√™ pode ver um exemplo de cabe√ßalho de requisi√ß√£o HTTP onde o token JWT est√° presente na propriedade **Authorization** utilizando o esquema **Bearer**.
>
> <div align="center"><img src="https://i.imgur.com/rvvLw2X.png" title="source: imgur.com" /></div>
>

<br />

<div align="center"><img src="https://i.imgur.com/wTIiVxc.png" title="source: imgur.com" /></div>

O m√©todo `generateToken` tem o objetivo de criar um token JWT para um usu√°rio, usando seu nome de usu√°rio (`username`). Esse token cont√©m informa√ß√µes b√°sicas como o identificador do usu√°rio, o momento em que foi criado e a data de expira√ß√£o, al√©m de ser assinado para garantir sua integridade e seguran√ßa.

**Linha 52:** Declara o m√©todo chamado `generateToken` que retorna uma string. Essa string ser√° o token JWT gerado. O m√©todo recebe como par√¢metro o nome do usu√°rio (`username`) para o qual o token ser√° criado.

**Linha 53:** Cria a vari√°vel `now`, que √© inicializada com o momento atual, obtido via m√©todo `Instant.now()`. O `Instant` representa um ponto no tempo com precis√£o de nanossegundos, √∫til para definir datas e hor√°rios no token.

>A classe `Instant`, presente no pacote `java.time` do Java, representa um ponto espec√≠fico no tempo na linha do tempo global, com precis√£o de nanossegundos. Ela √© usada para marcar momentos exatos, como a cria√ß√£o ou expira√ß√£o de um token, sem considerar fusos hor√°rios, funcionando sempre no hor√°rio UTC (Tempo Universal Coordenado). Isso a torna ideal para opera√ß√µes que exigem precis√£o e padroniza√ß√£o temporal, como controle de validade em sistemas distribu√≠dos.
>
>Por ser imut√°vel e parte da API moderna de datas e horas do Java (introduzida no Java 8), o `Instant` oferece m√©todos simples para manipula√ß√£o e compara√ß√£o de instantes no tempo, como adicionar ou subtrair dura√ß√µes, ou converter para outros formatos, como `Date`. Assim, √© muito usada em contextos onde a precis√£o e a clareza na representa√ß√£o do tempo s√£o essenciais, especialmente em autentica√ß√£o, tokens e registros de eventos.

**Linha 54:** Come√ßa a constru√ß√£o do token JWT com o m√©todo `Jwts.builder()`. Esse builder permite configurar o token, definindo seus campos e propriedades antes de gerar a string final.

**Linha 55:** Define o `subject` do token, que √© o identificador principal do token. Nesse caso, o `subject` ser√° o nome de usu√°rio passado como par√¢metro. Esse campo geralmente √© usado para identificar o usu√°rio associado ao token.

**Linha 56:** Define a data de emiss√£o do token (`issuedAt`), convertendo o `Instant now` para o tipo `Date`, que √© esperado pela biblioteca. Isso indica o momento em que o token foi criado.

**Linha 57:** Define a data de expira√ß√£o do token (`expiration`), que √© calculada somando um intervalo pr√©-definido (`EXPIRATION_DURATION`) ao momento atual. Esse intervalo determina por quanto tempo o token ser√° v√°lido.

**Linha 58:** Aplica a assinatura no token usando a chave secreta armazenada em `signingKey`. Essa assinatura √© fundamental para garantir que o token n√£o seja alterado depois de criado.

**Linha 59:**
 Finaliza a constru√ß√£o do token, convertendo-o para uma string compacta que pode ser enviada e armazenada, com o m√©todo `compact()`. Essa string √© o token JWT final que ser√° retornado pelo m√©todo.

O M√©todo **`generateToken`**, ao ser executado, retorna um Token JWT semelhante ao da imagem abaixo:

<div align="center"><img src="https://i.imgur.com/Y4X2KzV.png" title="source: imgur.com" /></div>

Esse token possui uma estrutura dividida em tr√™s partes principais, como mostrado na imagem a seguir:

<div align="center"><img src="https://i.imgur.com/EEoVRt4.png" title="source: imgur.com" /></div>

**Relembrando...**

- A primeira parte, chamada **Header**, cont√©m informa√ß√µes sobre o tipo do token (que √© JWT) e o algoritmo usado para assin√°-lo, garantindo a seguran√ßa. Essa parte ajuda o sistema a entender como interpretar e verificar o token.
- A segunda parte, o **Payload**, √© onde ficam os dados importantes, conhecidos como *claims*. √â nessa se√ß√£o que est√£o armazenadas informa√ß√µes como o nome do usu√°rio (subject), a data de emiss√£o e a data de expira√ß√£o do token. Esses dados s√£o usados para identificar o usu√°rio e controlar a validade do token.
- Por fim, a terceira parte √© a **Signature**, que √© uma assinatura digital gerada a partir do conte√∫do do header e do payload, usando uma chave secreta. Essa assinatura serve para garantir que o token n√£o foi alterado durante o transporte e que realmente foi emitido por uma fonte confi√°vel.

<br />

> [!TIP]
>
> üëâ Caso voc√™ tenha alguma d√∫vida sobre o Token JWT, header, payload, claim, entre outras, **consulte o conte√∫do <a href="15.md">Introdu√ß√£o a Spring Security</a>**.

<br />

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="4%"/> <a href="https://pt.wikipedia.org/wiki/Base64" target="_blank"><b>Codifica√ß√£o em Base 64</b></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="4%"/> <a href="https://www.base64url.com" target="_blank"><b>Ferramenta: Codificador Base 64</b></a></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="4%"/> <a href="https://pt.wikipedia.org/wiki/HMAC" target="_blank"><b>Algoritmo HMAC.</b></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="4%"/> <a href="https://pt.wikipedia.org/wiki/SHA-2" target="_blank"><b>Algoritmo SHA256.</b></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="4%"/> <a href="https://generate-random.org/encryption-key-generator" target="_blank"><b>Ferramenta: Key Generator</b></div>

<div align="left"><img src="https://i.imgur.com/WeNdbPo.png" title="source: imgur.com" width="4%"/> <a href="https://jwt.io/introduction" target="_blank"><b>Documenta√ß√£o: JWT - JSON WEB Token</b></a></div>

<div align="left"><img src="https://i.imgur.com/wMe2uG1.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html" target="_blank"><b>Documenta√ß√£o: <i>Classe Duration</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wMe2uG1.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/javase/8/docs/api/javax/crypto/SecretKey.html" target="_blank"><b>Documenta√ß√£o: <i>Interface SecretKey</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wMe2uG1.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html" target="_blank"><b>Documenta√ß√£o:</b><i> Classe Instant</i></a></div>

<div align="left"><img src="https://i.imgur.com/wMe2uG1.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Date.html" target="_blank"><b>Documenta√ß√£o:</b><i> Classe Date</i></a></div>

<div align="left"><img src="https://i.imgur.com/wMe2uG1.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html" target="_blank"><b>Documenta√ß√£o:</b><i> Classe String</i></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/javase/7/docs/api/java/security/Key.html" target="_blank"><b>Documenta√ß√£o: <i>Interface Key</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/doc/io.jsonwebtoken/jjwt-api/0.12.6/io/jsonwebtoken/security/Keys.html" target="_blank"><b>Documenta√ß√£o: <i>Classe Keys</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/static/io.jsonwebtoken/jjwt-api/0.12.6/io/jsonwebtoken/io/Decoders.html" target="_blank"><b>Documenta√ß√£o: <i>Classe Decoders</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/userdetails/UserDetails.html" target="_blank"><b>Documenta√ß√£o: <i>Interface UserDetails</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/static/io.jsonwebtoken/jjwt-api/0.12.6/io/jsonwebtoken/Claims.html" target="_blank"><b>Documenta√ß√£o: <i>Interface Claims</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/static/io.jsonwebtoken/jjwt-api/0.12.6/io/jsonwebtoken/Jwts.html" target="_blank"><b>Documenta√ß√£o: <i>Classe Jwts</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/static/io.jsonwebtoken/jjwt-api/0.12.6/io/jsonwebtoken/Jwt.html" target="_blank"><b>Documenta√ß√£o: <i>Interface Jwt</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/static/io.jsonwebtoken/jjwt-api/0.12.6/io/jsonwebtoken/JwtParserBuilder.html" target="_blank"><b>Documenta√ß√£o: <i>Interface JwtParserBuilder</i></b></a></div>

<br />

üíæ **Salve as altera√ß√µes antes de prosseguir ( File ü°™ Save All )!**

A seguir, veja a implementa√ß√£o completa da classe **`JwtService`**:

```java
package com.generation.blogpessoal.security;

import java.time.Duration;
import java.time.Instant;
import java.util.Date;

import javax.crypto.SecretKey;

import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;

@Component
public class JwtService {

    private static final String SECRET = "5367566B59703373367639792F423F4528482B4D6251655468576D5A71347437";
    private static final Duration EXPIRATION_DURATION = Duration.ofMinutes(60);
    
    private final SecretKey signingKey;
    
    public JwtService() {
        byte[] keyBytes = Decoders.BASE64.decode(SECRET);
        this.signingKey = Keys.hmacShaKeyFor(keyBytes);
    }
    
    private Claims extractAllClaims(String token) {
        return Jwts.parser()
            .verifyWith(signingKey)
            .build()
            .parseSignedClaims(token)
            .getPayload();
    }

    public String extractUsername(String token) {
        return extractAllClaims(token).getSubject();
    }

    public Date extractExpiration(String token) {
        return extractAllClaims(token).getExpiration();
    }

    public boolean validateToken(String token, UserDetails userDetails) {
        Claims claims = extractAllClaims(token);
        return claims.getSubject().equals(userDetails.getUsername()) && 
               claims.getExpiration().after(new Date());
    }

    public String generateToken(String username) {
        Instant now = Instant.now();
        return Jwts.builder()
            .subject(username)
            .issuedAt(Date.from(now))
            .expiration(Date.from(now.plus(EXPIRATION_DURATION)))
            .signWith(signingKey)
            .compact();
    }
    
}
```

<br />

<h2>üë£ Passo 02 - Criar a Classe JwtAuthFilter</h2>



A **classe `JwtAuthFilter`** tem a responsabilidade de interceptar e pr√©-processar todas as requisi√ß√µes HTTP, buscando o token JWT que √© enviado no cabe√ßalho da requisi√ß√£o, na propriedade **Authorization**. Ap√≥s extrair o token, essa classe valida sua autenticidade, cria um objeto de autentica√ß√£o correspondente e insere o usu√°rio autenticado no **SecurityContext**. 

O `SecurityContext` √© o componente do Spring Security que mant√©m as informa√ß√µes de autentica√ß√£o do usu√°rio durante a execu√ß√£o da aplica√ß√£o, permitindo que as regras de seguran√ßa sejam aplicadas quando o usu√°rio faz requisi√ß√µes a diferentes endpoints.

No contexto do Spring Security, a **classe `JwtAuthFilter` funciona como um filtro de servlet personalizado (Custom Servlet Filter)**. Isso significa que ela √© inserida na cadeia de filtros do Spring para interceptar cada requisi√ß√£o HTTP, garantindo que o token JWT seja validado antes que a requisi√ß√£o seja processada pela aplica√ß√£o. Assim, qualquer requisi√ß√£o que n√£o contenha um token v√°lido pode ser bloqueada ou tratada adequadamente.

Para que o Spring gerencie essa classe automaticamente, ela deve ser anotada com **`@Component`**. Essa anota√ß√£o indica que o `JwtAuthFilter` √© um componente gerenciado pelo Spring, permitindo a inje√ß√£o e a instancia√ß√£o autom√°tica de suas depend√™ncias em outras classes, sempre que necess√°rio. Al√©m disso, os m√©todos definidos nessa classe s√£o fundamentais para o funcionamento correto da autentica√ß√£o e autoriza√ß√£o no Spring Security, garantindo a seguran√ßa da aplica√ß√£o.

Vamos criar e implementar a Classe **JwtAuthFilter**:

1. Clique com o bot√£o direito do mouse sobre o **pacote com.generation.blogpessoal.security**, na source folder principal (**src/main/java**), e clique na op√ß√£o **New ü°™ Class**
2. Na janela **New Java Class**, no item **Name**, digite o nome da Classe (**JwtAuthFilter**), e na sequ√™ncia clique no bot√£o **Finish** para concluir.

Vejamos abaixo a implementa√ß√£o da Classe **JwtAuthFilter**:

<div align="center"><img src="https://i.imgur.com/dEi2uRD.png" title="source: imgur.com" /></div>

**Linha 1:** A instru√ß√£o **package** define o nome do pacote (ou camada) onde a classe foi criada. Essa declara√ß√£o organiza o c√≥digo dentro da estrutura do projeto e √© adicionada automaticamente pelo STS (Spring Tool Suite) ao criar a classe.

**Linhas 3 a 22:** As declara√ß√µes **import** indicam todos os pacotes e classes externas que s√£o utilizadas dentro da classe **JwtAuthFilter**. Esses imports permitem que a classe acesse funcionalidades fornecidas por outras bibliotecas ou pelo pr√≥prio framework, facilitando o desenvolvimento e a manuten√ß√£o do c√≥digo.

<div align="center"><img src="https://i.imgur.com/OziVzmW.png" title="source: imgur.com" /></div>

**Linha 24:** A classe foi anotada com **`@Component`**, indicando que ela √© um componente gerenciado pelo Spring. Isso significa que o Spring cria e controla a inst√¢ncia dessa classe automaticamente, possibilitando a inje√ß√£o e a instancia√ß√£o de suas depend√™ncias em outras classes sempre que necess√°rio.

**Linha 25:** A classe **`JwtAuthFilter`** estende (herda) a classe **`OncePerRequestFilter`**.

> **Entendendo a classe `OncePerRequestFilter`**
>
> Filtros de servlet podem ser executados m√∫ltiplas vezes durante o processamento de uma requisi√ß√£o HTTP, especialmente quando a requisi√ß√£o √© encaminhada para outras aplica√ß√µes ou recursos. Por√©m, existem situa√ß√µes em que √© importante garantir que um filtro seja executado apenas uma vez por requisi√ß√£o.
>
> Para isso, o Spring oferece a classe abstrata `OncePerRequestFilter`, que assegura que o filtro personalizado, neste caso o `JwtAuthFilter`, seja executado somente uma vez para cada requisi√ß√£o HTTP, evitando execu√ß√µes repetidas desnecess√°rias.

**Linhas 27 a 31:** Foram feitas duas inje√ß√µes de depend√™ncia nesta classe: a primeira √© da classe **`JwtService`**, que disponibiliza m√©todos para valida√ß√£o do token JWT; a segunda √© da classe **`UserDetailsServiceImpl`**, que fornece acesso aos dados do usu√°rio autenticado. Essas depend√™ncias s√£o fundamentais para que o filtro possa validar o token e carregar as informa√ß√µes do usu√°rio corretamente.

<br />

<div align="center"><img src="https://i.imgur.com/XEDknr5.png" title="source: imgur.com" /></div>

O m√©todo **`doFilterInternal`** √© o cora√ß√£o do filtro de autentica√ß√£o JWT. Ele √© chamado para cada requisi√ß√£o HTTP e tem a fun√ß√£o de interceptar a requisi√ß√£o, extrair o token JWT, validar sua autenticidade e, se estiver tudo correto, permitir que o usu√°rio seja autenticado no sistema antes de continuar o processamento.

**Linha 33:** O m√©todo √© anotado com `@Override` porque est√° sobrescrevendo um m√©todo da superclasse, garantindo que a l√≥gica personalizada do filtro seja executada em cada requisi√ß√£o.

**Linha 34:** O m√©todo `doFilterInternal` √© uma implementa√ß√£o do m√©todo abstrato da classe `OncePerRequestFilter`. Ele recebe tr√™s par√¢metros importantes:

- `request`: representa a requisi√ß√£o HTTP que chegou ao servidor;
- `response`: representa a resposta que ser√° enviada ao cliente;
- `filterChain`: controla a cadeia de filtros, permitindo que a requisi√ß√£o continue seu processamento ap√≥s passar por este filtro.

<br />

> [!IMPORTANT]
>
> N√£o √© necess√°rio se preocupar com os tr√™s par√¢metros do m√©todo `doFilterInternal`, pois eles s√£o gerados e fornecidos automaticamente pelo Spring Security.

<br />

Os tr√™s par√¢metros foram anotados com `@NonNull`, indicando que **n√£o devem ser nulos**, ou seja, n√£o podem receber o valor `null`.

Na declara√ß√£o do m√©todo, tamb√©m foi especificado que ele pode lan√ßar as seguintes exce√ß√µes:

- **`ServletException`**: exce√ß√£o espec√≠fica do contexto de servlets em aplica√ß√µes web Java. Indica problemas no processamento da requisi√ß√£o, como erros internos ou falhas no ciclo de vida do servlet.
- **`IOException`**: exce√ß√£o gen√©rica relacionada a opera√ß√µes de entrada e sa√≠da. Geralmente sinaliza problemas ao ler ou escrever dados, como falhas na leitura de arquivos, erros de comunica√ß√£o em rede, entre outros.

**Linhas 38 a 52:** O corpo do m√©todo est√° dentro de um bloco `try-catch` para capturar exce√ß√µes espec√≠ficas relacionadas √† valida√ß√£o do token JWT e autentica√ß√£o do usu√°rio.

**Linha 39:** Chama o m√©todo `extractTokenFromRequest(request)` para extrair o token JWT que pode estar presente no cabe√ßalho da requisi√ß√£o.

**Linhas 41 a 44:** Verifica se o token √© `null` (n√£o existe) ou se j√° existe uma autentica√ß√£o configurada no contexto de seguran√ßa (`SecurityContextHolder`). 

Se qualquer uma dessas condi√ß√µes for verdadeira, o m√©todo simplesmente encaminha a requisi√ß√£o para o pr√≥ximo filtro da cadeia, usando `filterChain.doFilter(request, response)`, e retorna, sem tentar autenticar novamente via token.

Na nossa implementa√ß√£o, o pr√≥ximo filtro da cadeia √© o **`UsernamePasswordAuthenticationFilter`**, respons√°vel por autenticar utilizando credenciais (usu√°rio e senha). Nesse cen√°rio, o Spring Security verificar√° se as credenciais foram enviadas e tentar√° realizar a autentica√ß√£o.

Caso as credenciais n√£o estejam presentes ou n√£o sejam v√°lidas, o Spring Security retornar√° a resposta HTTP **`401 Unauthorized`**, indicando falha na autentica√ß√£o.

**Linha 46:** Caso o token esteja presente e n√£o exista autentica√ß√£o configurada, o m√©todo chama `processJwtAuthentication(request, token)` para validar o token e configurar a autentica√ß√£o do usu√°rio no contexto de seguran√ßa.

**Linha 47:** Ap√≥s tentar a autentica√ß√£o, o m√©todo chama `filterChain.doFilter(request, response)` para garantir que a requisi√ß√£o continue seu processamento normalmente.

**Linhas 49 a 52:** O bloco `catch` captura exce√ß√µes espec√≠ficas que podem ocorrer durante a valida√ß√£o do token JWT, como:

- Token expirado (`ExpiredJwtException`)
- Assinatura inv√°lida (`SignatureException`)
- Token malformado (`MalformedJwtException`)
- Erro de usu√°rio n√£o encontrado (`UsernameNotFoundException`). 

Se alguma dessas exce√ß√µes ocorrer, a resposta HTTP ter√° seu status definido como `401 Unauthorized`, indicando que a autentica√ß√£o falhou.

<br />

<div align="center"><img src="https://i.imgur.com/utvLq8j.png" title="source: imgur.com" /></div>

O m√©todo **`extractTokenFromRequest`** tem a tarefa simples, por√©m fundamental, de extrair o token JWT do cabe√ßalho HTTP da requisi√ß√£o. Ele verifica se o token est√° presente e no formato correto dentro da propriedade `Authorization`, retornando o token puro para ser usado nas etapas seguintes.

**Linha 55:** O m√©todo privado `extractTokenFromRequest` recebe como par√¢metro um objeto `HttpServletRequest`, que representa a requisi√ß√£o HTTP enviada pelo cliente. O m√©todo tem como objetivo extrair o token JWT presente no cabe√ßalho da requisi√ß√£o.

**Linha 57:** Dentro do m√©todo, a vari√°vel `authHeader` recebe o valor do cabe√ßalho **Authorization** da requisi√ß√£o, que cont√©m o token JWT precedido da palavra-chave "Bearer" seguido de um espa√ßo em branco.

> [!WARNING]
>
> **O espa√ßo em branco entre a palavra Bearer e o Token JWT √© obrigat√≥rio.** 

**Linha 59:** O m√©todo verifica se o cabe√ßalho `authHeader` n√£o √© nulo, se come√ßa com a palavra `"Bearer "` e se o seu comprimento √© maior que 7 caracteres (para garantir que o token realmente exista ap√≥s a palavra "Bearer ").

**Linha 60:** Se a verifica√ß√£o for verdadeira, o m√©todo retorna somente a parte do token, removendo a palavra `"Bearer "` e o espa√ßo que a acompanha. Isso √© feito usando o m√©todo `substring(7)`, que pega o texto a partir do √≠ndice 7, ou seja, depois da palavra "Bearer ".

> **Bearer**
>
> Para enviar um Token JWT no cabe√ßalho da requisi√ß√£o HTTP, deve-se utilizar a propriedade **Authorization** com o valor contendo a palavra **Bearer** (que significa "ao portador"), seguida de um espa√ßo em branco e, em seguida, o Token JWT.
>
> **Token JWT:**
>
> <div align="center"><img src="https://i.imgur.com/Y4X2KzV.png" title="source: imgur.com" /></div>
>
> **Token no cabe√ßalho Authorization com a palavra Bearer:**
>
> <div align="center"><img src="https://i.imgur.com/13LBzxE.png" title="source: imgur.com" /></div>
>
> Na valida√ß√£o do Token JWT, √© necess√°rio **remover a palavra "Bearer"** para extrair apenas o token puro e, assim, process√°-lo corretamente.

**Linha 63:** Caso o cabe√ßalho n√£o exista, n√£o comece com `"Bearer "` ou n√£o contenha token, o m√©todo retorna `null`, indicando que n√£o foi poss√≠vel extrair um token v√°lido da requisi√ß√£o.

<br />

<div align="center"><img src="https://i.imgur.com/IWi1VxW.png" title="source: imgur.com" /></div>

Ap√≥s extrair o token, o m√©todo **`processJwtAuthentication`** realiza a valida√ß√£o detalhada: extrai o nome do usu√°rio do token, busca os dados do usu√°rio no sistema, verifica se o token √© v√°lido para aquele usu√°rio e, por fim, configura a autentica√ß√£o no contexto de seguran√ßa, garantindo que o sistema reconhe√ßa o usu√°rio como autenticado durante a requisi√ß√£o.

**Linha 66:** O m√©todo `processJwtAuthentication` recebe dois par√¢metros: a requisi√ß√£o HTTP (`request`) e o token JWT (`token`). Seu prop√≥sito √© validar o token e, se v√°lido, configurar a autentica√ß√£o do usu√°rio no contexto de seguran√ßa.

**Linha 68:** Chama o m√©todo `jwtService.extractUsername(token)` para extrair o nome de usu√°rio presente no token JWT. Esse valor ser√° usado para buscar os detalhes do usu√°rio no sistema.

**Linha 70:** Verifica se o nome de usu√°rio extra√≠do n√£o √© nulo e n√£o est√° vazio (ap√≥s remover espa√ßos em branco do inicio e do fim da String, com o m√©todo `trim`). Isso garante que o token cont√©m um usu√°rio v√°lido para continuar o processo.

**Linha 71:** Caso o usu√°rio seja v√°lido, chama o m√©todo `userDetailsService.loadUserByUsername(username)`, que carrega as informa√ß√µes completas do usu√°rio, incluindo suas permiss√µes e credenciais.

**Linhas 73 a 85:** Verifica se o token √© v√°lido para o usu√°rio carregado, chamando o m√©todo  `jwtService.validateToken(token, userDetails)`. 

**Linhas 75 a 77:** Se o token for v√°lido, cria um objeto `UsernamePasswordAuthenticationToken`, que representa a autentica√ß√£o do usu√°rio no Spring Security, associando o usu√°rio, suas credenciais (aqui, `null` pois n√£o usamos a senha neste contexto) e suas permiss√µes (em nossa implementa√ß√£o, uma cole√ß√£o vazia, porque n√£o implmentamos roles).

**Linha 79:** Por meio do m√©todo **setDetails()** da classe **UsernamePasswordAuthenticationToken**, adicionamos a requisi√ß√£o HTTP ao objeto **authToken**.

Antes disso, √© necess√°rio converter o objeto **request** (da classe **HttpServletRequest**) em uma inst√¢ncia da classe **WebAuthenticationDetailsSource**. Essa classe, interna ao Spring Security, √© utilizada pelos filtros de servlet para processar requisi√ß√µes HTTP.

Como n√£o √© poss√≠vel enviar os dados da requisi√ß√£o HTTP diretamente ao filtro de servlet, o Spring Security usa a **WebAuthenticationDetailsSource** para converter a requisi√ß√£o em um formato adequado e compreens√≠vel para o filtro.

**Linha 81:** Insere a autentica√ß√£o criada no contexto de seguran√ßa atual, `SecurityContextHolder.getContext()`, permitindo que o Spring reconhe√ßa o usu√°rio como autenticado durante o processamento da requisi√ß√£o.

**Linha 84:** Caso o token n√£o seja v√°lido para o usu√°rio, o m√©todo lan√ßa uma exce√ß√£o `RuntimeException` com a mensagem ‚ÄúToken JWT inv√°lido ou expirado‚Äù, interrompendo o fluxo de autentica√ß√£o.

**Linha 88:** Se o nome de usu√°rio n√£o puder ser extra√≠do do token, o m√©todo lan√ßa uma exce√ß√£o `RuntimeException` informando que o usu√°rio n√£o p√¥de ser obtido a partir do token JWT.

<br />

<div align="left"><img src="https://i.imgur.com/wMe2uG1.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html" target="_blank"><b>Documenta√ß√£o: <i>Interface HttpServletRequest</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wMe2uG1.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html" target="_blank"><b>Documenta√ß√£o: <i>Interface HttpServletResponse</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wMe2uG1.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/javase/7/docs/api/java/io/IOException.html" target="_blank"><b>Documenta√ß√£o: <i>Classe IOException</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/wMe2uG1.png" title="source: imgur.com" width="4%"/> <a href=https://docs.oracle.com/javaee/7/api/javax/servlet/ServletException.html" target="_blank"><b>Documenta√ß√£o: <i>Classe ServletException</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/filter/OncePerRequestFilter.html" target="_blank"><b>Documenta√ß√£o: <i>Classe OncePerRequestFilter</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/userdetails/UserDetailsService.html" target="_blank"><b>Documenta√ß√£o: <i>Interface UserDetailsService</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/context/SecurityContext.html" target="_blank"><b>Documenta√ß√£o: <i>Classe SecurityContext</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/core/context/SecurityContextHolder.html" target="_blank"><b>Documenta√ß√£o: <i>Classe SecurityContextHolder</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-security/site/docs/4.0.x/apidocs/org/springframework/security/authentication/UsernamePasswordAuthenticationToken.html" target="_blank"><b>Documenta√ß√£o: <i>Classe UsernamePasswordAuthenticationToken</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-security/site/docs/4.0.x/apidocs/org/springframework/security/web/authentication/WebAuthenticationDetailsSource.html" target="_blank"><b>Documenta√ß√£o: <i>Classe WebAuthenticationDetailsSource</i></b></a></div>


<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.oracle.com/javaee/7/api/javax/servlet/FilterChain.html" target="_blank"><b>Documenta√ß√£o: <i>Interface FilterChain</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/doc/io.jsonwebtoken/jjwt/latest/io/jsonwebtoken/ExpiredJwtException.html" target="_blank"><b>Documenta√ß√£o: <i>Classe ExpiredJwtException</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/static/io.jsonwebtoken/jjwt/0.2/io/jsonwebtoken/UnsupportedJwtException.html" target="_blank"><b>Documenta√ß√£o: <i>Classe UnsupportedJwtException</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/doc/io.jsonwebtoken/jjwt/0.2/io/jsonwebtoken/MalformedJwtException.html" target="_blank"><b>Documenta√ß√£o: <i>Classe MalformedJwtException</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://javadoc.io/doc/io.jsonwebtoken/jjwt/0.2/io/jsonwebtoken/SignatureException.html" target="_blank"><b>Documenta√ß√£o: <i>Classe SignatureException</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/9B46Slv.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/server/ResponseStatusException.html" target="_blank"><b>Documenta√ß√£o: <i>Classe ResponseStatusException</i></b></a></div>

<br />

üíæ **Salve as altera√ß√µes antes de prosseguir ( File ü°™ Save All )!**

A seguir, veja a implementa√ß√£o completa da classe **`JwtAuthFilter`**:

```java
package com.generation.blogpessoal.security;

import java.io.IOException;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.MalformedJwtException;
import io.jsonwebtoken.security.SignatureException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

@Component
public class JwtAuthFilter extends OncePerRequestFilter {

    @Autowired
    private JwtService jwtService;

    @Autowired
    private UserDetailsServiceImpl userDetailsService;

    @Override
    protected void doFilterInternal(@NonNull HttpServletRequest request, 
                                   @NonNull HttpServletResponse response, 
                                   @NonNull FilterChain filterChain) throws ServletException, IOException {
        
        try {
            String token = extractTokenFromRequest(request);
            
            if (token == null || SecurityContextHolder.getContext().getAuthentication() != null) {
                filterChain.doFilter(request, response);
                return;
            }
            
            processJwtAuthentication(request, token);
            filterChain.doFilter(request, response);
            
        } catch (ExpiredJwtException | SignatureException | MalformedJwtException
        		| UsernameNotFoundException e) {
        	response.setStatus(HttpStatus.UNAUTHORIZED.value());
        }
    }

    private String extractTokenFromRequest(HttpServletRequest request) {
        
    	String authHeader = request.getHeader("Authorization");
        
        if (authHeader != null && authHeader.startsWith("Bearer ") && authHeader.length() > 7) {
            return authHeader.substring(7);
        }
        
        return null;
    }
    
    private void processJwtAuthentication(HttpServletRequest request, String token) {
        
    	String username = jwtService.extractUsername(token);
        
        if (username != null && !username.trim().isEmpty()) {
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);
            
            if (jwtService.validateToken(token, userDetails)) {
            	
                UsernamePasswordAuthenticationToken authToken = 
                    new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                
                SecurityContextHolder.getContext().setAuthentication(authToken);
                
            } else {
                throw new RuntimeException("Token JWT inv√°lido ou expirado");
            }
            
        } else {
            throw new RuntimeException("Usu√°rio n√£o pode ser extra√≠do do token JWT");
        }
    }

}
```

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="4%"/> <a href="https://github.com/rafaelq80/backend_blogpessoal_spring/tree/11_Spring_Security" target="_blank"><b>C√≥digo fonte do projeto</b></a></div>

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
