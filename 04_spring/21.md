<h1>Teste de Software com JUnit 5 - Introdu√ß√£o</h1>

<br />

O teste de software √© uma forma de avaliar a qualidade da aplica√ß√£o e reduzir os riscos de falhas no c√≥digo ao ser colocado  em opera√ß√£o (Produ√ß√£o). Testar n√£o se resume apenas em executar testes e verificar os resultados. **Executar** testes √© apenas uma das atividades. Planejamento, an√°lise, modelagem e implementa√ß√£o dos testes,  relat√≥rios de progresso, resultado e avalia√ß√£o da qualidade, tamb√©m s√£o  partes de um **processo de testes**.
Testar software n√£o √© somente **verificar** se os requisitos foram atendidos, atribui-se ao teste de software tamb√©m a **valida√ß√£o**, ou  seja, verificar se o sistema atender√° √†s necessidades do usu√°rio e de outras partes interessadas em seu(s) ambiente(s) operacional(is).

<br />

<h2>1. A Pir√¢mide de Testes</h2>



A **Pir√¢mide de Testes** √© uma representa√ß√£o gr√°fica que orienta a distribui√ß√£o dos testes de software em diferentes n√≠veis. Ela sugere a quantidade ideal de testes para cada tipo, destacando tamb√©m seus respectivos custos e tempos de execu√ß√£o ‚Äî quanto mais pr√≥ximo da base, mais r√°pidos e baratos os testes tendem a ser.

<div align="center"><img src="https://i.imgur.com/Od62OuJ.png" title="source: imgur.com" width="75%"/></div>

Observe que os testes na base s√£o mais r√°pidos e baratos do que os testes no topo da pir√¢mide.

De acordo com a **Pir√¢mide de Testes**, existem tr√™s tipos de teste:

- Teste de Unidade
- Teste de Integra√ß√£o
- Teste End to End (E2E)

<br />

<h3>1.1. Teste de unidade</h3>



O **teste de unidade** √© uma t√©cnica de verifica√ß√£o que consiste em testar partes individuais e isoladas de um sistema, geralmente fun√ß√µes ou m√©todos. Essas **unidades** podem ser m√©todos, classes, pacotes ou componentes menores de um subsistema.

O objetivo principal √© garantir que cada unidade de c√≥digo **funcione de forma correta e independente**, conforme o comportamento esperado.

Por se concentrar em blocos pequenos de c√≥digo, o teste de unidade √©:

- **R√°pido**, pois n√£o depende de servi√ßos externos ou banco de dados;
- **Barato**, porque pode ser escrito e executado diretamente pela pessoa desenvolvedora durante a codifica√ß√£o;
- **Determin√≠stico**, ou seja, fornece os mesmos resultados sob as mesmas condi√ß√µes.

Devido a essas caracter√≠sticas, os testes de unidade est√£o na base da **Pir√¢mide de Testes** e s√£o considerados o tipo de teste mais frequente e fundamental no processo de desenvolvimento orientado a testes (**TDD**).

**Exemplos de Testes Unit√°rios:**

- **Fun√ß√£o matem√°tica simples:** Testar uma fun√ß√£o que calcula a m√©dia entre dois n√∫meros. O teste verifica se, ao receber os valores 8 e 6, o resultado retornado √© 7.
- **Valida√ß√£o de senha:** Testar uma fun√ß√£o que verifica se a senha digitada atende aos crit√©rios de seguran√ßa, como ter pelo menos 8 caracteres e conter n√∫meros. O teste avalia se a entrada "12345678" √© considerada v√°lida.
- **Convers√£o de temperatura:** Testar um m√©todo que converte Celsius para Fahrenheit. O teste valida se, ao informar 0¬∞C, o retorno √© 32¬∞F.
- **C√°lculo de desconto em um produto:** Testar a l√≥gica de c√°lculo de desconto em um item de um carrinho de compras. Por exemplo, um produto de R$ 100,00 com 10% de desconto deve retornar R$ 90,00.
- **Formata√ß√£o de CPF:** Testar uma fun√ß√£o que recebe um CPF num√©rico (12345678900) e retorna o CPF formatado ("123.456.789-00").
- **Gera√ß√£o de sauda√ß√£o personalizada:** Testar se a fun√ß√£o que gera mensagens retorna "Bom dia, Jo√£o!" ao receber o nome "Jo√£o" e a hora 9h da manh√£.

<br />

<h3>1.2. Teste de Integra√ß√£o</h3>



O **Teste de Integra√ß√£o** √© uma etapa fundamental no processo de testes de software que tem como objetivo verificar a **intera√ß√£o entre dois ou mais m√≥dulos do sistema**. Diferente do teste de unidade, que avalia partes isoladas do c√≥digo, o teste de integra√ß√£o foca em **como os componentes trabalham juntos** e se essa integra√ß√£o mant√©m o comportamento esperado do sistema.

Segundo o ISTQB Glossary, o Teste de Integra√ß√£o √© definido como:

> "Um n√≠vel de teste no qual unidades s√£o combinadas e testadas em conjunto para avaliar se as interfaces entre elas se comportam conforme especificado."
>
> *O **ISTQB** (International Software Testing Qualifications Board) √© uma organiza√ß√£o internacional sem fins lucrativos respons√°vel por definir um **padr√£o global de certifica√ß√µes em teste de software**.*

Mesmo que cada m√≥dulo funcione corretamente de forma isolada, **falhas podem surgir quando esses m√≥dulos interagem**. Isso pode ocorrer por diverg√™ncia em formatos de dados, contratos de APIs, erros de comunica√ß√£o entre classes, ou regras de neg√≥cio mal implementadas em conjunto. 

Para uma melhor compreens√£o, vamos analisar a situa√ß√£o abaixo:

Imagine que voc√™ testou separadamente:

- Uma **fechadura** que responde corretamente ao comando de travar;
- Uma **porta** que pode ser trancada se receber esse comando.

No entanto, ao integrar os dois, percebe-se que a fechadura foi feita apenas para portas de giro, e a porta em quest√£o √© de correr. **Ambos funcionam individualmente**, mas n√£o s√£o compat√≠veis quando combinados ‚Äî evidenciando a import√¢ncia do Teste de Integra√ß√£o, como vemos na anima√ß√£o abaixo:

<div align="center"><img src="https://i.imgur.com/sjACFFr.gif" title="source: imgur.com" /></div>

<br />

- Os **Testes de Integra√ß√£o** apresentam caracter√≠sticas distintas quando comparados aos **Testes Unit√°rios**:
  - **Mais complexos**: envolvem a intera√ß√£o entre dois ou mais componentes do sistema, o que aumenta o n√≠vel de depend√™ncia e l√≥gica conjunta a ser verificada.
  - **Mais lentos**: muitas vezes dependem de recursos externos, como banco de dados, APIs, arquivos ou servi√ßos, o que aumenta o tempo de execu√ß√£o.
  - **Mais custosos**: exigem um ambiente de testes mais robusto e, em alguns casos, o uso de mocks, containers ou dados reais, elevando o esfor√ßo de configura√ß√£o e manuten√ß√£o.

**Exemplos de Testes de Integra√ß√£o:**

1. **Autentica√ß√£o e acesso a dados:** Verificar se, ao fazer login com usu√°rio e senha v√°lidos, o sistema acessa corretamente o banco de dados e retorna os dados do usu√°rio.
2. **Cadastro com envio de e-mail:** Testar se, ao cadastrar um novo cliente, o sistema salva os dados no banco e envia um e-mail de confirma√ß√£o com sucesso.
3. **Fluxo de compra em e-commerce:** Validar se, ao adicionar um produto ao carrinho e finalizar a compra, o sistema calcula corretamente os valores, atualiza o estoque e gera o pedido.
4. **Consulta via API externa:** Testar a integra√ß√£o com um servi√ßo externo de CEP para garantir que o endere√ßo seja preenchido corretamente ao digitar o n√∫mero do CEP.
5. **Cria√ß√£o de usu√°rio com valida√ß√£o de CPF:** Verificar se, ao criar um novo usu√°rio, o sistema consulta um servi√ßo interno para validar o CPF e, caso esteja v√°lido, persiste os dados.

<br />

<h3>1.3. Teste End to End</h3>



O **Teste End-to-End (E2E)** √© uma metodologia de teste de software que tem como objetivo verificar o **funcionamento completo de um sistema**, simulando o comportamento real de um usu√°rio, desde o in√≠cio at√© o fim de um fluxo funcional. Esse tipo de teste valida a **comunica√ß√£o entre os diferentes componentes, camadas e servi√ßos da aplica√ß√£o**, garantindo que todas as partes estejam corretamente integradas e operem como esperado em um cen√°rio real.

De acordo com a documenta√ß√£o oficial do Cypress, testes E2E:

> ‚Äú...testam todo o sistema como um todo, do ponto de vista do usu√°rio, garantindo que os fluxos principais funcionem corretamente.‚Äù
>
> *O **Cypress** √© uma ferramenta moderna de automa√ß√£o de testes focada em **testes end-to-end (E2E)** para aplica√ß√µes **web**.*

Esses testes s√£o essenciais para validar:

- A **experi√™ncia do usu√°rio**;
- A **integra√ß√£o entre sistemas e servi√ßos**;
- A **confiabilidade dos dados ao longo de um processo completo**, como uma compra ou autentica√ß√£o.

Os testes E2E costumam ser:

- **Mais lentos**: envolvem m√∫ltiplas camadas (back-end, banco de dados, servi√ßos externos e at√© mesmo o front-end e/ou app mobile), o que exige mais tempo para execu√ß√£o.
- **Mais caros**: requerem ambientes de teste realistas, dados simulados, automa√ß√µes ou at√© mesmo testadores humanos.
- **Mais complexos**: verificam o sistema de forma hol√≠stica, o que aumenta o n√∫mero de vari√°veis e a possibilidade de falhas externas.

Por esses motivos, s√£o utilizados em menor escala, priorizando os fluxos **mais cr√≠ticos da aplica√ß√£o**, como login, pagamento, cadastro ou finaliza√ß√£o de pedidos.

**Exemplos de testes E2E:**

1. **Autentica√ß√£o completa:** Simular o login de um usu√°rio, validando o acesso a endpoints restritos com base mas permiss√µes do usu√°rio.
2. **Finaliza√ß√£o de compra em e-commerce:** Realizar todo o processo de compra: adicionar itens ao carrinho, informar dados de entrega, escolher o meio de pagamento e receber a confirma√ß√£o do pedido.
3. **Cadastro de usu√°rio e confirma√ß√£o por e-mail:** Preencher os dados do usu√°rio, submeter os dados, verificar a chegada do e-mail de confirma√ß√£o e validar a ativa√ß√£o da conta.
4. **Simula√ß√£o de agendamento:** Agendar um servi√ßo em um sistema de reservas, verificar se os hor√°rios dispon√≠veis s√£o atualizados e se o agendamento aparece na agenda.
5. **Preenchimento de formul√°rio com m√∫ltiplas etapas (front-end):** Completar um formul√°rio dividido em v√°rias telas (exemplo: cadastro de curr√≠culo), garantindo que os dados sejam salvos corretamente em cada etapa.

<br />

<h3>1.4. O que deve ser testado?</h3>



Ao planejar os testes de software, a prioridade deve ser dada √†s **partes mais cr√≠ticas, complexas ou sens√≠veis da aplica√ß√£o**, ou seja, aquelas que impactam diretamente o funcionamento, a seguran√ßa ou a experi√™ncia do usu√°rio final.

Esses pontos geralmente incluem:

- **Regras de neg√≥cio essenciais** (ex: c√°lculo de desconto, valida√ß√£o de CPF);
- **Funcionalidades que envolvem transa√ß√µes** (ex: pagamento, envio de pedido);
- **Integra√ß√µes com sistemas externos** (ex: gateways de pagamento, APIs de terceiros);
- **Fluxos principais da aplica√ß√£o** (ex: login, cadastro, finaliza√ß√£o de compra);
- **√Åreas com alta probabilidade de falha ou alta frequ√™ncia de uso**.

Focar os testes nesses pontos **reduz riscos em produ√ß√£o**, melhora a estabilidade do sistema e ajuda a detectar falhas antes que impactem os usu√°rios.

> üí° **Exemplo pr√°tico:**
>  Em um e-commerce, a **finaliza√ß√£o da compra** √© um fluxo essencial. Se houver qualquer falha nesse processo (exemplo: erro no c√°lculo do valor final, falha no pagamento ou n√£o gera√ß√£o do pedido), isso afeta diretamente o cliente e gera preju√≠zo ao neg√≥cio. Por isso, esse √© um dos primeiros pontos que deve ser testado.

<br />

**O que n√£o vale a pena testar?**

Alguns trechos de c√≥digo s√£o t√£o simples, triviais ou irrelevantes para a l√≥gica do sistema que o esfor√ßo de test√°-los n√£o se justifica. Isso se aplica principalmente a:

- **Getters e setters autom√°ticos** (sem l√≥gica interna);
- **C√≥digos gerados automaticamente por frameworks**;
- **Estiliza√ß√£o ou layout est√°tico em componentes front-end** (quando n√£o afetam a l√≥gica ou a experi√™ncia do usu√°rio).

> ‚ùå **Exemplo de teste irrelevante:**
> Testar se um m√©todo `getNome()` simplesmente retorna o valor de uma vari√°vel `nome` **sem nenhuma l√≥gica adicional**. Esse tipo de teste n√£o traz ganho real e apenas aumenta o volume de testes sem valor agregado.

<br />

<h2>2. Spring Boot Testing</h2>



**Spring Boot Testing** √© uma funcionalidade essencial do ecossistema Spring Boot que facilita a cria√ß√£o e execu√ß√£o de testes automatizados, tanto testes unit√°rios quanto testes de integra√ß√£o. Ele oferece uma configura√ß√£o simplificada e integrada para testar aplica√ß√µes Spring, reduzindo a complexidade e aumentando a produtividade dos desenvolvedores.

Ao iniciar um projeto com Spring Boot, as depend√™ncias necess√°rias para testes j√° v√™m pr√©-configuradas, o que permite come√ßar a escrever testes imediatamente, sem configura√ß√µes extras complicadas.

O Spring Boot Testing integra-se de forma natural com os principais frameworks de teste da plataforma Java, como o **JUnit 5** (a vers√£o mais recente e recomendada do JUnit), al√©m de ferramentas espec√≠ficas do Spring, como o **MockMvc** ‚Äî que permite simular requisi√ß√µes HTTP para testar controllers REST sem a necessidade de subir um servidor web completo.

Essa combina√ß√£o proporciona uma estrutura robusta para:

- **Testes unit√°rios**: verificando componentes isolados, como servi√ßos e reposit√≥rios.
- **Testes de integra√ß√£o**: validando o comportamento completo da aplica√ß√£o em um ambiente controlado, incluindo intera√ß√µes entre m√∫ltiplos componentes.

Assim, o Spring Boot Testing √© uma pe√ßa-chave para garantir a qualidade, a confiabilidade e a manuten√ß√£o eficiente do c√≥digo durante o ciclo de desenvolvimento.

<br />

<div align="left"><img src="https://i.imgur.com/mw7d1xn.png" title="source: imgur.com" width="4%"/> <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing" target="_blank"><b>Documenta√ß√£o Oficial</b></a></div>

<br />


<h3>2.1. Spring Testing Annotations</h3>



| Anota√ß√£o            | Descri√ß√£o                                                    |
| ------------------- | ------------------------------------------------------------ |
| **@SpringBootTest** | A anota√ß√£o **`@SpringBootTest`** √© utilizada para criar e inicializar o contexto completo da aplica√ß√£o durante os testes, permitindo que todos os componentes Spring sejam carregados e injetados normalmente. Isso possibilita a execu√ß√£o de testes de integra√ß√£o que verificam o comportamento real da aplica√ß√£o em um ambiente semelhante ao de produ√ß√£o.<br />A propriedade **`webEnvironment = WebEnvironment.RANDOM_PORT`** instrui o Spring Boot a iniciar o servidor web em uma porta aleat√≥ria dispon√≠vel, ao inv√©s de usar a porta padr√£o (geralmente 8080). Essa abordagem evita conflitos quando a porta padr√£o j√° est√° em uso, por exemplo, se a aplica√ß√£o estiver rodando localmente durante a execu√ß√£o dos testes. Dessa forma, os testes podem ser executados de forma isolada e paralela, sem interferir em outras inst√¢ncias da aplica√ß√£o. |

<br />

<h2>3. O framework JUnit</h2>



**JUnit** √© um framework open source amplamente utilizado na linguagem Java para escrever e executar testes automatizados. Ele ajuda a garantir que o c√≥digo funcione conforme o esperado, possibilitando a repeti√ß√£o dos testes de forma f√°cil e eficiente durante o desenvolvimento.

O JUnit oferece diversos recursos importantes, tais como:

- **Asser√ß√µes**: m√©todos que verificam se os resultados dos testes correspondem aos valores esperados.
- **Recursos de teste compartilhados**: para preparar e limpar dados comuns usados por m√∫ltiplos testes.
- **Conjuntos de testes (Test Suites)**: permitem organizar e executar grupos de testes de forma conjunta.
- **Execu√ß√£o flex√≠vel**: testes podem ser executados tanto por interfaces gr√°ficas quanto por linha de comando, facilitando a integra√ß√£o com ferramentas de build e CI/CD.

O JUnit √© utilizado para testar diferentes n√≠veis de c√≥digo, como:

- Um objeto completo.
- M√©todos espec√≠ficos ou grupos de m√©todos dentro de um objeto.
- Intera√ß√µes entre v√°rios objetos.

<br />

<div align="left"><img src="https://i.imgur.com/AaUP7GB.png" title="source: imgur.com" width="4%"/> <a href="https://junit.org/junit5/docs/current/user-guide/" target="_blank"><b>Documenta√ß√£o: JUnit 5</b></a></div>

<br />


<h3>3.1. Anota√ß√µes do JUnit</h3>



As anota√ß√µes do **JUnit 5** s√£o usadas para marcar m√©todos e classes de teste, definindo seu comportamento durante a execu√ß√£o dos testes automatizados. Elas facilitam a organiza√ß√£o, configura√ß√£o e controle do ciclo de vida dos testes, como preparar o ambiente antes da execu√ß√£o, limpar recursos depois dos testes, ou desabilitar testes temporariamente. Na tabela abaixo, vemos as principais anota√ß√µes do JUnit 5:

| **JUnit 5**       | **Descri√ß√£o**                                                |
| ----------------- | ------------------------------------------------------------ |
| *`@Test`*         | Indica que o m√©todo anotado deve ser executado como um teste. |
| *`@BeforeEach`*   | Executa o m√©todo antes de cada m√©todo de teste da classe. Usado para configurar pr√©-condi√ß√µes comuns a todos os testes (ex.: inicializar vari√°veis). |
| *`@BeforeAll`*    | Executa o m√©todo uma √∫nica vez antes de todos os m√©todos de teste da classe. Usado para configura√ß√µes gerais necess√°rias a todos os testes (ex.: criar objetos). O m√©todo deve ser est√°tico, a menos que o ciclo de vida da classe de testes seja `PER_CLASS`. |
| *`@AfterEach`*    | Executa o m√©todo ap√≥s cada m√©todo de teste. Usado para limpar ou redefinir condi√ß√µes ap√≥s cada teste (ex.: resetar vari√°veis). |
| *`@AfterAll`*     | Executa o m√©todo uma √∫nica vez ap√≥s todos os testes da classe. Usado para limpeza geral ap√≥s todos os testes (ex.: liberar recursos). Tamb√©m deve ser est√°tico, a menos que o ciclo de vida da classe de testes seja `PER_CLASS`. |
| *`@Disabled`*     | Desabilita temporariamente um teste ou classe de testes, impedindo sua execu√ß√£o. |
| *`@DisplayName`*  | Permite personalizar o nome do teste que ser√° exibido nas execu√ß√µes, incluindo emojis e textos descritivos. |
| *`@TestInstance`* | Modifica o ciclo de vida da inst√¢ncia da classe de teste:<br />1) `PER_METHOD` (padr√£o): uma nova inst√¢ncia da classe √© criada para cada m√©todo de teste. Necess√°rio para `@BeforeEach` e `@AfterEach`.<br />2) `PER_CLASS`: uma √∫nica inst√¢ncia √© usada para todos os m√©todos de teste. Necess√°rio para usar `@BeforeAll` e `@AfterAll` em m√©todos n√£o est√°ticos. |

<br />

<h3>3.2. Asser√ß√µes - JUnit</h3>



**Asser√ß√µes (Assertions)** s√£o m√©todos fornecidos por frameworks de testes, como o JUnit, que verificam se uma determinada condi√ß√£o √© verdadeira durante a execu√ß√£o de um teste automatizado. Elas s√£o usadas para validar o comportamento esperado do c√≥digo, garantindo que o resultado obtido em uma execu√ß√£o corresponda ao resultado esperado.

Por exemplo, uma asser√ß√£o pode confirmar que o valor retornado por um m√©todo √© igual a um valor esperado, ou que uma vari√°vel n√£o √© nula. Caso a condi√ß√£o da asser√ß√£o falhe, o teste √© marcado como reprovado, indicando que o c√≥digo n√£o se comportou como esperado.

Asser√ß√µes s√£o essenciais para garantir a qualidade do software, pois permitem detectar regress√µes e erros automaticamente durante o desenvolvimento. Na tabela abaixo vemos as principais asser√ß√µes utilizadas pelo JUnit:

| **Assertion**                                     | **Descri√ß√£o**                                                |
| ------------------------------------------------- | ------------------------------------------------------------ |
| *`assertEquals(expected, actual)`*                | Afirma que dois valores s√£o iguais (usado para comparar valores primitivos ou objetos com `equals`). |
| *`assertTrue(condition)`*                         | Afirma que a condi√ß√£o booleana √© verdadeira.                 |
| *`assertFalse(condition)`*                        | Afirma que a condi√ß√£o booleana √© falsa.                      |
| *`assertNotNull(object)`*                         | Afirma que o objeto n√£o √© nulo.                              |
| *`assertNull(object)`*                            | Afirma que o objeto √© nulo.                                  |
| *`assertSame(expected, actual)`*                  | Afirma que dois objetos referenciam o mesmo objeto (compara√ß√£o por refer√™ncia). |
| *`assertNotSame(expected, actual)`*               | Afirma que dois objetos n√£o referenciam o mesmo objeto.      |
| *`assertArrayEquals(expectedArray, actualArray)`* | Afirma que dois arrays possuem os mesmos elementos na mesma ordem. |

<br />

| <img src="https://i.imgur.com/RfjtOFi.png" title="source: imgur.com" width="150px"/> | <p align="justify">**DICA:** Ao escrever testes, sempre verifique se a importa√ß√£o dos pacotes do JUnit na Classe de testes est√£o corretos. O JUnit 5 tem como pacote base: `org.junit.jupiter.api` . </p> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<h2>4. Banco de Dados H2</h2>



O **H2** √© um sistema de banco de dados relacional escrito em Java, leve e de c√≥digo aberto. Ele pode ser usado de forma **embutida** dentro de aplica√ß√µes Java ou em modo cliente-servidor, permitindo flexibilidade na arquitetura do sistema.

Uma caracter√≠stica importante do H2 √© o seu funcionamento **em mem√≥ria**, o que significa que os dados s√£o armazenados temporariamente durante a execu√ß√£o da aplica√ß√£o. Por isso, seu armazenamento √© **vol√°til**: ao reiniciar a aplica√ß√£o, o banco √© reconstru√≠do e os dados anteriores s√£o perdidos. Essa caracter√≠stica torna o H2 ideal para ambientes de desenvolvimento, testes automatizados e prototipagem r√°pida, pois permite criar e descartar bancos facilmente sem necessidade de configura√ß√£o complexa.

Al√©m disso, o H2 oferece uma configura√ß√£o simples, performance adequada para testes e compatibilidade com a maioria dos recursos SQL, facilitando a produtividade dos desenvolvedores.

<br />


<div align="left"><img src="https://i.imgur.com/p436QzQ.png" title="source: imgur.com" width="50px"/> <a href="https://gasparbarancelli.com/post/banco-de-dados-h2-com-spring-boot" target="_blank"><b>Tutorial Banco de dados H2</b></a></div>

<br />


<h2>5. Quais testes faremos?</h2>



Vamos escrever **Testes End to End**, que ir√£o simular o uso real da aplica√ß√£o via Requisi√ß√µes HTTP direcionadas ao recurso **Usuario** do projeto **Blog Pessoal**.

Para isso, √© necess√°rio realizar algumas configura√ß√µes importantes:

1. **Source Folder de testes**: Organizar o c√≥digo e e configurar o Banco de dados de testes na pasta `src/test`, que √© o local padr√£o para os arquivos de teste em projetos Maven.
2. **Arquivo `pom.xml`**: Incluir ou ajustar as depend√™ncias necess√°rias para execu√ß√£o dos testes, como JUnit 5, Spring Boot Test, entre outras.
3. **Classe Utilit√°ria `TestBuilder`**: Vamos criar uma Classe Utilit√°ria, que ser√° respons√°vel por gerar os objetos da Classe Usuario, que ser√£o utilizados pelos testes.

Antes de iniciar as modifica√ß√µes, certifique-se de que o projeto **Blog Pessoal esteja totalmente funcional e sem erros, com todos os m√©todos implementados, principalmente os m√©todos do Recurso Usu√°rio**, caso contr√°rio, os testes n√£o ir√£o funcionar.

<br /><br />
	
<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>

