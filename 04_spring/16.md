<h1>Projeto 02 - Blog Pessoal - Spring Security - Ecossistema do Usu√°rio - Parte 01</h1>



O que veremos por aqui:

1. Ecossistema do Usu√°rio
2. Apresenta√ß√£o do Recurso Usu√°rio
3. Cria√ß√£o da classe Model `Usuario` e relacionamento com a classe `Postagem`
4. Cria√ß√£o da classe `UsuarioLogin`
5. Cria√ß√£o da Interface `UsuarioRepository`

<br />

<h2>1. Ecossistema do Usuario</h2>



O **Ecossistema do Usu√°rio** √© respons√°vel por definir os dados do objeto `Usuario`, que ser√° utilizado para autentica√ß√£o e autoriza√ß√£o de acesso ao Blog Pessoal, quando a camada de seguran√ßa da aplica√ß√£o estiver totalmente implementada.

<br />

<h2>2. O Recurso Usuario</h2>



Nesta etapa, iniciaremos a constru√ß√£o do recurso **Usu√°rio**, que ser√° composto por duas classes principais: **`Usuario`** e **`UsuarioLogin`**.

```mermaid
classDiagram
    class Usuario {
        - id: Long
        - nome: String
        - usuario: String
        - senha: String
        - foto: String
        - postagem: List ~Postagem~
        + getAll() ResponseEntity List ~Usuario~
        + getById(id: Long) ResponseEntity ~Usuario~
        + post(usuario: Usuario) ResponseEntity ~Usuario~
        + put(usuario: Usuario) ResponseEntity ~Usuario~
        + autenticar(usuarioLogin: UsuarioLogin) ResponseEntity ~UsuarioLogin~
    }

```

A classe **`Usuario`** servir√° como modelo para a cria√ß√£o da tabela **`tb_usuarios`** no banco de dados **`db_blogpessoal`**. Os atributos definidos na classe correspondem √†s colunas da tabela. Ap√≥s implementarmos a classe modelo, ao executar o projeto no Spring Tool Suite (STS), a tabela ser√° gerada automaticamente no banco de dados.

A seguir, apresentamos o Diagrama de Entidade e Relacionamento (DER) que representa a estrutura da tabela **`tb_usuarios`**:

```mermaid
erDiagram
    USUARIO {
        bigint id PK
        varchar(255) nome
        varchar(255) usuario
        varchar(255) senha
        varchar(5000) foto
    }
```

O Dicion√°rio de dados da nossa tabela **tb_Usuarios** ser√° o seguinte:

| Atributo  | Tipo de dado  | Descri√ß√£o           | Chave |
| --------- | ------------- | ------------------- | ----- |
| `id`      | bigint        | Identificador √∫nico | PK    |
| `nome`    | varchar(255)  | Nome do usu√°rio     |       |
| `usuario` | varchar(255)  | E-mail do usu√°rio   |       |
| `senha`   | varchar(255)  | Senha do usu√°rio    |       |
| `foto`    | varchar(5000) | Foto do usu√°rio     |       |

Al√©m da classe **`Usuario`**, estabeleceremos o relacionamento com a classe **`Postagem`**, que foi criada anteriormente. Abaixo, apresentamos o diagrama de classes que representa esse relacionamento, incluindo tamb√©m a classe **`Tema`**:

```mermaid
classDiagram
    class Usuario {
        - Long id
        - String nome
        - String usuario
        - String senha
        - String foto
        - List ~Postagem~ postagem
    }

    class Postagem {
        - Long id
        - String titulo
        - String texto
        - LocalDate data
        - Tema tema
        - Usuario usuario
    }

    class Tema {
        - Long id
        - String descricao
        - List ~Postagem~ postagem
    }

    Usuario "1" <--> "N" Postagem
    Tema "1" <--> "N" Postagem

```

Com a implementa√ß√£o da classe **`Usuario`** e seu relacionamento com **`Postagem`**, a estrutura do banco **`db_blogpessoal`** ficar√° conforme o DER abaixo:

```mermaid
erDiagram
    USUARIO ||--o{ POSTAGEM : escreve
    TEMA ||--o{ POSTAGEM : classifica

    USUARIO {
        bigint id PK
        varchar(255) nome
        varchar(255) usuario
        varchar(255) senha
        varchar(5000) foto
    }

    POSTAGEM {
        bigint id PK
        varchar(100) titulo
        varchar(1000) texto
        datetime data
        bigint tema_id FK
        bigint usuario_id FK        
    }

    TEMA {
        bigint id PK
        varchar(255) descricao
    }

```

Note que a entidade **`POSTAGEM`** ter√° duas chaves estrangeiras (**FK**): `tema_id` e `usuario_id`, que estabelecem as rela√ß√µes com as tabelas **`TEMA`** e **`USUARIO`**, respectivamente.

Em seguida, construiremos a interface **`UsuarioRepository`**, respons√°vel pela intera√ß√£o com o banco de dados. Essa interface ser√° utilizada pelas classes **`UsuarioController`**, onde implementaremos os m√©todos CRUD e de autentica√ß√£o descritos no diagrama de classes, e pela classe **`UsuarioService`**, onde aplicaremos as regras de neg√≥cio, especialmente as relacionadas ao Spring Security.

O diagrama da interface **`UsuarioRepository`** pode ser representado da seguinte forma:

```mermaid
classDiagram
    class UsuarioRepository {
        <<interface>>
        + findByUsuario(usuario: String) Optional ~Usuario~
    }

```

Note que a **Query Method** utilizada na `UsuarioRepository` difere das utilizadas nas interfaces `PostagemRepository` e `TemaRepository`, pois, neste caso, ela realiza a busca de um usu√°rio com base no e-mail (atributo `usuario`). O m√©todo retorna um `Optional<Usuario>`, pois a busca pode ou n√£o encontrar um usu√°rio correspondente, evitando, assim, retornos nulos e facilitando o tratamento do resultado.

<br />

> [!NOTE]
>
> **Alerta de BSM**
>
> *Mantenha a aten√ß√£o aos detalhes*
>
> As camadas (pacotes: model, repository e controller) j√° foram criados e utilizados nos recursos `Postagem` e `Tema` ‚Äî utilize-as como refer√™ncia.

<br />

> [!TIP]
>
> üëâ Caso voc√™ tenha alguma d√∫vida sobre como criar a classe, executar o projeto, entre outras, **consulte os conte√∫dos referentes a constru√ß√£o dos Recursos Postagem e Tema**.

<br />

Tamb√©m ser√° criada a classe `UsuarioLogin`, que, embora perten√ßa √† camada *Model*, n√£o ser√° mapeada para o banco de dados. Ela ser√° uma classe auxiliar, respons√°vel por armazenar temporariamente os dados do login (usu√°rio e senha), permitindo a autentica√ß√£o do usu√°rio. Al√©m disso, essa classe ser√° utilizada para retornar, na resposta da autentica√ß√£o, os **demais dados do usu√°rio autenticado**, como nome, token gerado, e outros dados relevantes que ser√£o utilizados no frontend da aplica√ß√£o.

```mermaid
classDiagram
    class UsuarioLogin {
        - id: Long
        - nome: String
        - usuario: String
        - senha: String
        - foto: String
        - token: String
    }

```

<br />

<h2>üë£ Passo 01 - Adicionar as Depend√™ncias - Spring Security</h2>



1.  Abra o arquivo **pom.xml**
2. Localize o trecho de c√≥digo indicado na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/de1JcFS.png" title="source: imgur.com" /></div>

3. Adicione as linhas abaixo (caso voc√™ ainda n√£o tenha adicionado):

```xml
<!-- Adicionamos a Depend√™ncia - Spring Security -->
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-security</artifactId>
</dependency>
<!-- Depend√™ncias para Gera√ß√£o e Valida√ß√£o do Token JWT -->
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt-api</artifactId>
	<version>0.12.6</version>
</dependency>
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt-impl</artifactId>
	<version>0.12.6</version>
</dependency>
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt-jackson</artifactId>
	<version>0.12.6</version>
</dependency>
```

4. Ap√≥s a inser√ß√£o do trecho de c√≥digo acima, o arquivo `pom.xml` ficar√° semelhante a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/ltNmhsD.png" title="source: imgur.com" /></div>

A primeira depend√™ncia (`spring-boot-starter-security`) foi adicionada no conte√∫do **Introdu√ß√£o ao Spring Security**, sendo respons√°vel por integrar os recursos de autentica√ß√£o e autoriza√ß√£o na aplica√ß√£o. J√° as outras tr√™s depend√™ncias s√£o respons√°veis por **gerar, assinar e validar o Token JWT**, permitindo a implementa√ß√£o de autentica√ß√£o baseada em tokens de forma segura e eficiente.

<br />

> [!WARNING]
>
> No momento em que este conte√∫do foi escrito, a vers√£o mais recente da depend√™ncia **JJWT** era a **0.12.6**. No entanto, ao acessar este material no futuro, √© poss√≠vel que uma nova vers√£o j√° tenha sido lan√ßada.

<br />
	
üíæ **Salve as altera√ß√µes antes de prosseguir ( File ü°™ Save All )!**

Ap√≥s salvar as altera√ß√µes no arquivo `pom.xml`, as depend√™ncias ser√£o automaticamente baixadas do **Reposit√≥rio Central do Maven**. Esse processo pode levar alguns segundos, dependendo da velocidade da sua conex√£o com a internet e da quantidade de depend√™ncias envolvidas. Aguarde a conclus√£o para garantir que todas as bibliotecas estejam dispon√≠veis no projeto antes de prosseguir com o desenvolvimento.

<br />

<h2>üë£ Passo 02 - Criar a Classe Usuario no Pacote Model</h2>



Agora vamos criar a terceira classe Model que chamaremos de **Usuario**.

1. Clique com o bot√£o direito do mouse sobre o **pacote com.generation.blogpessoal.model**, na source folder principal (**src/main/java**), e clique na op√ß√£o **New ü°™ Class**
2. Na janela **New Java Class**, no item **Name**, digite o nome da classe (**Usuario**), e na sequ√™ncia clique no bot√£o **Finish** para concluir.  


A seguir veja a implementa√ß√£o completa da **classe Usuario**:

```java
package com.generation.blogpessoal.model;

import java.util.List;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

@Entity
@Table(name = "tb_usuarios")
public class Usuario {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;

	@NotBlank(message = "O Atributo Nome √© Obrigat√≥rio!")
	private String nome;

	@NotBlank(message = "O Atributo Usu√°rio √© Obrigat√≥rio!")
	@Email(message = "O Atributo Usu√°rio deve ser um email v√°lido!")
	private String usuario;

	@NotBlank(message = "O Atributo Senha √© Obrigat√≥rio!")
	@Size(min = 8, message = "A Senha deve ter no m√≠nimo 8 caracteres")
	private String senha;

	@Size(max = 5000, message = "O link da foto n√£o pode ser maior do que 5000 caracteres")
	private String foto;

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "usuario", cascade = CascadeType.REMOVE)
	@JsonIgnoreProperties(value = "usuario", allowSetters = true)
	private List<Postagem> postagem;

	public Long getId() {
		return this.id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getNome() {
		return this.nome;
	}

	public void setNome(String nome) {
		this.nome = nome;
	}

	public String getUsuario() {
		return this.usuario;
	}

	public void setUsuario(String usuario) {
		this.usuario = usuario;
	}

	public String getSenha() {
		return this.senha;
	}

	public void setSenha(String senha) {
		this.senha = senha;
	}

	public String getFoto() {
		return this.foto;
	}

	public void setFoto(String foto) {
		this.foto = foto;
	}

	public List<Postagem> getPostagem() {
		return this.postagem;
	}

	public void setPostagem(List<Postagem> postagem) {
		this.postagem = postagem;
	}

}
```

<br />

> [!NOTE]
>
> **Alerta de BSM**
>
> *Mantenha aten√ß√£o aos detalhes.* 
>
> O atributo `senha`, definido anteriormente, **n√£o deve conter** a propriedade `@Size(max = ...)`, que imp√µe um tamanho m√°ximo para o campo. Isso porque, ap√≥s a criptografia (hash) realizada pelo Spring Security, a senha poder√° ultrapassar esse limite, provocando um erro **HTTP Status 500 ‚Äì Internal Server Error**. Para evitar esse problema, configure **apenas a propriedade `@Size(min = ...)`**.
>
> Essa abordagem garante que a senha tenha um tamanho m√≠nimo adequado para seguran√ßa, **sem impedir o armazenamento do hash completo**.

<br />


üíæ **Salve as altera√ß√µes antes de prosseguir ( File ü°™ Save All )!**

<br />

<h2>üë£ Passo 03 - Criar a Rela√ß√£o ManytoOne na classe Postagem</h2>



A classe **`Postagem`** representar√° o lado **N:1** da rela√ß√£o, ou seja, **muitas postagens podem estar associadas a um √∫nico usu√°rio**.

Para configurar essa rela√ß√£o, insira o seguinte trecho de c√≥digo na classe **`Postagem`**:

```java
	@ManyToOne
	@JsonIgnoreProperties("postagem")
	private Usuario usuario;
```

Esse c√≥digo deve ser adicionado **logo ap√≥s o √∫ltimo atributo da classe (`tema`)**, conforme ilustrado na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/2m9sNrN.png" title="source: imgur.com" /></div>

Na sequ√™ncia, atualize os **m√©todos Get e Set**, incluindo os correspondentes ao novo atributo **`usuario`**:

```java
	public Usuario getUsuario() {
		return usuario;
	}

	public void setUsuario(Usuario usuario) {
		this.usuario = usuario;
	}
```

Esses m√©todos devem ser posicionados logo ap√≥s os *Getters* e *Setters* do atributo **`tema`**, mantendo a organiza√ß√£o e a consist√™ncia da classe, como ilustrado na imagem a seguir:

<div align="center"><img src="https://i.imgur.com/TE9lvAU.png" title="source: imgur.com" /></div>

A seguir, apresentamos a implementa√ß√£o completa da **classe `Postagem`** com as altera√ß√µes aplicadas.

```java
package com.generation.blogpessoal.model;

import java.time.LocalDateTime;

import org.hibernate.annotations.UpdateTimestamp;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

@Entity
@Table(name = "tb_postagens")
public class Postagem {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;
		
	@Column(length = 100)
	@NotBlank(message = "O atributo t√≠tulo √© obrigat√≥rio!")
	@Size(min = 5, max = 100, message = "O atributo t√≠tulo deve ter no minimo 5 e no m√°ximo 100 caracteres.")
	@Pattern(regexp = "^[^0-9].*", message = "O t√≠tulo n√£o pode ser apenas num√©rico")
	private String titulo;
	
	@Column(length = 1000)
	@NotBlank(message = "O atributo texto √© obrigat√≥rio!")
	@Size(min = 10, max = 1000, message = "O atributo texto deve ter no minimo 10 e no m√°ximo 1000 caracteres.")
	@Pattern(regexp = "^[^0-9].*", message = "O texto n√£o pode ser apenas num√©rico")
	private String texto;
	
	@UpdateTimestamp
	private LocalDateTime data;

	@ManyToOne
	@JsonIgnoreProperties("postagem")
	private Tema tema;
	
	@ManyToOne
	@JsonIgnoreProperties("postagem")
	private Usuario usuario;
	
	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getTitulo() {
		return titulo;
	}

	public void setTitulo(String titulo) {
		this.titulo = titulo;
	}

	public String getTexto() {
		return texto;
	}

	public void setTexto(String texto) {
		this.texto = texto;
	}

	public LocalDateTime getData() {
		return data;
	}

	public void setData(LocalDateTime data) {
		this.data = data;
	}

	public Tema getTema() {
		return tema;
	}

	public void setTema(Tema tema) {
		this.tema = tema;
	}

	public Usuario getUsuario() {
		return usuario;
	}

	public void setUsuario(Usuario usuario) {
		this.usuario = usuario;
	}
	
}
```

<br />
	
üíæ **Salve as altera√ß√µes antes de prosseguir ( File ü°™ Save All )!**

<br />


<h2>üë£ Passo 04 - Criar a classe UsuarioLogin na Camada Model</h2>



Agora vamos criar a **quarta classe Model**, que chamaremos de **`UsuarioLogin`**.

A classe `UsuarioLogin` √© respons√°vel por definir os dados que o cliente deve fornecer ao tentar se autenticar (fazer login) no sistema: **usu√°rio (e-mail)** e **senha**.

Essa classe funcionar√° como uma **DTO (Data Transfer Object)**, ou seja, uma classe utilizada para transitar dados entre as camadas da aplica√ß√£o sem expor diretamente a classe `Usuario` (Model) para o cliente.

1. Clique com o bot√£o direito do mouse sobre o **pacote com.generation.blogpessoal.model**, na source folder Principal (**src/main/java**), e clique na op√ß√£o **New ü°™ Class**
3. Na janela **New Java Class**, no item **Name**, digite o nome da classe (**UsuarioLogin**), e na sequ√™ncia clique no bot√£o **Finish** para concluir.

A seguir veja a implementa√ß√£o completa da **classe UsuarioLogin**:

```java
package com.generation.blogpessoal.model;

public class UsuarioLogin {
	
	private Long id;
	private String nome;
	private String usuario;
	private String senha;
	private String foto;
	private String token;

	public Long getId() {
		return this.id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getNome() {
		return this.nome;
	}

	public void setNome(String nome) {
		this.nome = nome;
	}

	public String getUsuario() {
		return this.usuario;
	}

	public void setUsuario(String usuario) {
		this.usuario = usuario;
	}

	public String getSenha() {
		return this.senha;
	}

	public void setSenha(String senha) {
		this.senha = senha;
	}

	public String getFoto() {
		return this.foto;
	}

	public void setFoto(String foto) {
		this.foto = foto;
	}

	public String getToken() {
		return this.token;
	}

	public void setToken(String token) {
		this.token = token;
	}

}
```

<br />

> [!NOTE]
>
> **Alerta de BSM**
>
> *Mantenha aten√ß√£o aos detalhes.* 
>
> Ao criar a classe `UsuarioLogin`, **n√£o esque√ßa de adicionar o atributo `token`**. Esse atributo √© **fundamental**, pois ser√° utilizado para armazenar o **Token JWT gerado no login**.
>
> O token ser√° enviado **no cabe√ßalho de todas as requisi√ß√µes** feitas pelo frontend para acessar os endpoints protegidos da API. Sem esse atributo, o sistema **n√£o conseguir√° realizar a autentica√ß√£o e autoriza√ß√£o corretamente**.

<br />
	
üíæ **Salve as altera√ß√µes antes de prosseguir ( File ü°™ Save All )!**

<br />

<h2>üë£ Passo 05 - Executar o projeto e Checar o Banco de dados</h2>



1. Execute o projeto e verifique no **MySQL Workbench** se a tabela **tb_usuarios** foi criada no Banco de dados **db_blogpessoal** com o respectivo relacionamento com a tabela **tb_postagens**, onde foi criada a Chave Estrangeira **usuario_id**.

<div align="center"><img src="https://i.imgur.com/o3Ul8iS.png" title="source: imgur.com" /></div>

<br />

<h2>üë£ Passo 06 - Criar a Interface UsuarioRepository na Camada Repository</h2>



Agora vamos criar a Interface Repository que chamaremos de **UsuarioRepository**.

1. Clique com o bot√£o direito do mouse sobre o **pacote com.generation.blogpessoal.repository**, na source folder principal (**src/main/java**)
	
2. Na sequ√™ncia, clique na op√ß√£o **New ü°™ Interface**

3. Na janela **New Java Interface**, no item **Name**, digite o nome da Interface (**UsuarioRepository**), e na sequ√™ncia clique no bot√£o **Finish** para concluir.

<br />

A seguir veja a implementa√ß√£o completa da **Interface UsuarioRepository**:

```java
package com.generation.blogpessoal.repository;

import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;

import com.generation.blogpessoal.model.Usuario;

public interface UsuarioRepository extends JpaRepository<Usuario, Long>{

	Optional<Usuario> findByUsuario(String usuario);

}
```

<br />

> [!NOTE]
>
> **Alerta de BSM**
>
> *Mantenha aten√ß√£o aos detalhes.* 
>
> Tome **muito cuidado** ao escrever os m√©todos `findBy` ou `findAllBy` na interface repository. Caso haja qualquer **erro de digita√ß√£o** ou nome incorreto, o **Spring Data JPA n√£o conseguir√° interpretar corretamente** o m√©todo, e um **erro ser√° exibido no console do STS**.
>
> Verifique sempre se os **nomes dos atributos usados no m√©todo correspondem exatamente** aos nomes declarados na classe model.

<br />

Observe que foi criada uma Query Method na Interface UsuarioRepository, conforme detalhado abaixo:

**Query Method**

```java
public Optional<Usuario> findByUsuario(String usuario);
```

**Instru√ß√£o SQL equivalente**

```sql
SELECT * FROM tb_usuario WHERE usuario = "usuarios";
```

| Palavra            |      | Instru√ß√£o SQL                                                |
| ------------------ | ---- | ------------------------------------------------------------ |
| **find**           | ü°™    | SELECT                                                       |
| **By**             | ü°™    | WHERE                                                        |
| **Usuario**        | ü°™    | Atributo da classe Usuario                                   |
| **String usuario** | ü°™    | Par√¢metro do M√©todo contendo o e-mail do usu√°rio que voc√™ deseja procurar. |

<br />
	
üíæ **Salve as altera√ß√µes antes de prosseguir ( File ü°™ Save All )!**

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="4%"/> <a href="https://github.com/rafaelq80/backend_blogpessoal_spring/tree/11_Spring_Security" target="_blank"><b>C√≥digo fonte do Projeto</b></a></div>

<br />

<h2 id="anexo1">Anexo I - Principais Mensagens de Erro</h2>

| Erro                        | Descri√ß√£o                                                    |
| --------------------------- | ------------------------------------------------------------ |
| ***BeanCreationException*** | Ao criar o Relacionamento Bidirecional, voc√™ criou apenas um lado da Rela√ß√£o (**@OneToMany**). Faltou criar o outro lado da Rela√ß√£o (**@ManyToOne**).<br />**Exemplo:** <br/>Habilitou o Relacionamento na classe Tema, mas n√£o habilitou na classe Postagem. |

<br /><br />


<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
