<h1>Introdução ao Axios</h1>



Como vimos em conteúdos anteriores, enquanto o **Frontend é a camada visual da aplicação**, responsável por exibir dados de forma amigável e permitir que os usuários interajam com eles, o **Backend é responsável pelas regras de negócio**, processamento dos dados e comunicação com o banco de dados.

Uma dúvida comum para quem está iniciando é: **como o Frontend e o Backend se comunicam?**

A resposta está nas **Bibliotecas de Comunicação HTTP**.

<br />

<h2>1. Bibliotecas de Comunicação HTTP</h2>



As bibliotecas de Comunicação HTTP permitem que uma aplicação Frontend faça **requisições HTTP** para uma API (Backend) e receba **respostas HTTP**, contendo dados e status da operação. É o mesmo conceito que você utilizou no Insomnia para testar endpoints do Backend, mas automatizado dentro da aplicação Frontend.

<br />

> [!IMPORTANT]
>
> Essas bibliotecas facilitam a comunicação entre Frontend e Backend, permitindo que os dados armazenados no servidor sejam acessados, manipulados e exibidos para o usuário final de forma dinâmica.

<r />

No universo **JavaScript**, temos a **Fetch API**, que é uma biblioteca nativa do navegador. No universo **React**, uma das bibliotecas mais populares é o **Axios**. Ambas permitem realizar operações **CRUD** (Create, Read, Update, Delete), utilizando os principais verbos HTTP: **GET, POST, PUT e DELETE**.

Um ponto importante é que **tanto a Fetch API quanto o Axios utilizam funções assíncronas**, baseadas no conceito de **Promises**, para lidar com requisições HTTP. Isso significa que essas operações são executadas em segundo plano, permitindo que o restante do código continue rodando normalmente, sem bloquear a aplicação. Quando a resposta chega, a função assíncrona processa os dados e permite que eles sejam utilizados dentro da aplicação.

Na prática, isso significa que uma requisição HTTP é feita **em segundo plano**, sem travar a aplicação. Quando a resposta chega, a função assíncrona processa os dados e retorna um objeto contendo informações importantes, como **status**, **headers** e o **corpo da resposta**.

<br />

<h2>2. Funções Assíncronas e Promises</h2>



Tanto a **Fetch API** quanto o **Axios** utilizam **funções assíncronas**, que no JavaScript e TypeScript são implementadas com **Promises**, para realizar requisições de forma **não bloqueante**.

As **funções assíncronas** permitem que tarefas mais demoradas, como requisições HTTP ou acesso a banco de dados, sejam executadas em **segundo plano**, sem interromper o funcionamento do restante do código.

Uma **Promise** é um objeto que representa o **resultado futuro** de uma operação assíncrona. Ela pode estar em três estados, como ilustrado abaixo:

<div align="center"><img src="https://i.imgur.com/CoxH7Yw.png" title="source: imgur.com" /><figcaption><i>Estados de uma Promise</i></figcaption></div>

- **pending (pendente):** estado inicial, aguardando resolução.
- **fulfilled (resolvida):** operação concluída com sucesso.
- **rejected (rejeitada):** operação que falhou.

Dessa forma, mesmo que a operação demore, a aplicação continua respondendo ao usuário, e quando a Promise é resolvida, os dados podem ser processados e utilizados normalmente.

**Sintaxe**

```ts
new Promise((resolve, reject) => {
  // lógica da operação assíncrona
});
```

- `resolve`: função chamada quando a operação é bem-sucedida.
- `reject`: função chamada quando ocorre algum erro.

<br />

<img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="4%"/>**Exemplo Ilustrativo - Promise**

<br />

> [!WARNING]
>
> **ATENÇÃO!**
>
> Este exemplo é **apenas ilustrativo**. **Não inclua este código em nenhum componente ou arquivo** do Projeto Blog Pessoal. Ele serve apenas para fins de estudo e compreensão dos conceitos apresentados.

<br />

```js
// Criando a Promise
function buscarPostsSimulados(): Promise<string[]> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const sucesso = true; // altere para false para simular erro
      if (sucesso) {
        resolve(['Post 1', 'Post 2', 'Post 3']);
      } else {
        reject('Erro ao buscar posts');
      }
    }, 2000); // simula atraso de 2 segundos
  });
}

// Consumindo a Promise com .then() e .catch()
buscarPostsSimulados()
  .then((posts) => {
    console.log('Posts recebidos:', posts);
  })
  .catch((erro) => {
    console.error(erro);
  });

```

**Explicação do fluxo:**

1. `buscarPostsSimulados()` retorna uma **Promise**.
2. O método `.then()` é chamado quando a Promise é **resolvida**, recebendo os dados retornados.
3. O método `.catch()` é chamado quando a Promise é **rejeitada**, permitindo tratar erros.

<br />

<h3>2.1. Async/Await</h3>



Como vimos no exemplo anterior, embora seja possível utilizar **Promises** diretamente com `.then()` e `.catch()`, a sintaxe **async/await** oferece uma opção mais **limpa e parecida com código síncrono**, facilitando a leitura e manutenção do código.

- **`async`**: define uma função como assíncrona, permitindo o uso do `await` dentro dela.
- **`await`**: pausa a execução da função até que a Promise seja resolvida ou rejeitada, retornando o resultado diretamente.

Vamos ver o mesmo exemplo, implementado com async/await:

<br />

<img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="4%"/>**Exemplo Ilustrativo - async/await**

<br />

> [!WARNING]
>
> **ATENÇÃO!**
>
> Este exemplo é **apenas ilustrativo**. **Não inclua este código em nenhum componente ou arquivo** do Projeto Blog Pessoal. Ele serve apenas para fins de estudo e compreensão dos conceitos apresentados.

<br />

```js
// Criando a Promise
function buscarPostsSimulados(): Promise<string[]> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const sucesso = true; // altere para false para simular erro
      if (sucesso) {
        resolve(['Post 1', 'Post 2', 'Post 3']);
      } else {
        reject('Erro ao buscar posts');
      }
    }, 2000); // simula atraso de 2 segundos
  });
}

// Consumindo a Promise com async/await
async function mostrarPosts() {
  try {
    const posts = await buscarPostsSimulados(); // posts recebe uma Promise
    console.log('Posts recebidos:', posts);
  } catch (erro) {
    console.error(erro);
  }
}

mostrarPosts();
```

**Explicação do fluxo:**

1. `buscarPostsSimulados()` retorna uma **Promise**, que será resolvida ou rejeitada após 2 segundos.
2. A função `mostrarPosts()` é marcada como `async`, permitindo o uso do `await`.
3. `await buscarPostsSimulados()` pausa a execução de `mostrarPosts()` até que a Promise seja resolvida, retornando os dados diretamente.
4. `try/catch` é usado para tratar erros, caso a Promise seja rejeitada.

Observe que ao utilizar **async/await** o código se torna **mais legível e próximo de um fluxo síncrono**, especialmente quando há **múltiplas requisições encadeadas** ou **tratamento de erros complexo**.

Com `async/await`, o Axios retornará os dados da requisição diretamente, sem necessidade de encadear Promises, facilitando o **debug**, a **manutenção** e a **compreensão do fluxo assíncrono**, o que é especialmente útil para iniciantes no Front-end.

<br />

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/API/Fetch_API" target="_blank"><b>Documentação: Fetch API</b></a></div>

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank"><b>Documentação: Funções Assíncronas</b></a></div>

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank"><b>Documentação: Promise</b></a></div> 

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" target="_blank"><b>Documentação: Async</b></a></div> 

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Operators/await" target="_blank"><b>Documentação: Await</b></a></div> 

<br />

<h2>3. A Biblioteca Axios</h2>



O **Axios** é uma biblioteca JavaScript de **comunicação HTTP**, baseada em **Promises**, que permite que desenvolvedores façam requisições para sua própria API (Backend da aplicação) ou para APIs de terceiros.

<div align="center"><img src="https://i.imgur.com/d8r03iQ.png" title="source: imgur.com" width="80%"/></div>

A grande vantagem do Axios é que ele é **fácil de usar** e oferece recursos que simplificam o trabalho com requisições HTTP, tornando o desenvolvimento mais ágil e seguro.

### Principais recursos do Axios:

- **Suporte a Promises:** o Axios retorna uma Promise em todos os seus métodos, facilitando o tratamento da resposta da requisição;
- **Intercepção de requisições e respostas:** permite modificar ou tratar requisições e respostas antes de serem enviadas ou exibidas;
- **Cancelamento de requisições:** possibilita interromper requisições em andamento, ajudando na performance da aplicação;
- **Configurações globais:** permite definir opções padrão, como cabeçalhos HTTP, para todas as requisições.
- **Sintaxe limpa:** Diferente da **Fetch API**, o Axios possui uma sintaxe mais direta e legível, especialmente ao ser usado com **async/await**, facilitando o gerenciamento de requisições assíncronas.

<br />

<h3>3.1. Como o Axios funciona?</h3>



Ao fazer uma requisição HTTP com Axios, você configura alguns parâmetros principais:

- **URL:** endereço do endpoint que será consumido;
- **Método HTTP:** GET, POST, PUT ou DELETE;
- **Cabeçalhos (Headers):** por exemplo, um Token JWT;
- **Corpo da requisição (Body):** dados que serão enviados, se necessário.

O Axios cria um **objeto de configuração** com essas informações e envia a requisição de duas formas:

1. Pelo **Node.js**, usando a biblioteca interna **HTTP**;
2. Pelo **navegador**, utilizando a API **XMLHttpRequest**.

> **XMLHttpRequest** é uma API nativa de navegadores que permite enviar requisições HTTP ou HTTPS e receber respostas, possibilitando que dados de um servidor sejam manipulados diretamente em JavaScript.

Quando a requisição é bem-sucedida, o Axios **resolve a Promise** e retorna um objeto de resposta contendo um **HTTP Status 2xx** e os dados solicitados. Caso a requisição falhe, a Promise é **rejeitada**, retornando um status de erro (**4xx** ou **5xx**).

O objeto de resposta do Axios possui as seguintes propriedades:

- **data:** dados retornados pelo servidor (geralmente JSON);
- **status:** código HTTP da resposta;
- **statusText:** texto associado ao status (ex.: "OK");
- **headers:** cabeçalhos da resposta;
- **config:** configurações da requisição original;
- **request:** objeto da requisição original, útil para depuração.

O diagrama abaixo mostra uma representação gráfica de como o Axios interage com uma API:

<div align="center"><img src="https://i.imgur.com/OyFjwqJ.png" title="source: imgur.com" /></div>

**Fluxo prático:**

1. Axios cria o objeto da requisição HTTP;
2. Transforma dados do corpo da requisição em JSON;
3. Envia a requisição para a API;
4. Recebe a resposta do servidor;
5. Converte os dados de JSON para objeto JavaScript;
6. Retorna o objeto de resposta para a aplicação;
7. Durante todo o processo, a aplicação continua funcionando normalmente, graças ao uso de **Promises**.

O Axios detecta automaticamente se a requisição é feita pelo **navegador** ou pelo **Node.js**, garantindo a forma correta de enviar e receber dados.

<br />

<h3>3.2. Métodos do Axios</h3>



O Axios suporta todos os métodos HTTP. Em nossas aplicações, utilizaremos os 4 MÉTODOS principais:

| Método Axios                     | Método HTTP | Descrição                                                    |
| -------------------------------- | :---------: | ------------------------------------------------------------ |
| `axios.get(url, options)`        |   **GET**   | Faz uma **requisição GET** para obter dados da API. **Não envia corpo (body)**. |
| `axios.post(url, data, options)` |  **POST**   | Faz uma **requisição POST** para enviar dados à API e criar novos registros. |
| `axios.put(url, data, options)`  |   **PUT**   | Faz uma **requisição PUT** para atualizar dados existentes na API. |
| `axios.delete(url, options)`     | **DELETE**  | Faz uma **requisição DELETE** para remover dados da API. **Não envia corpo (body)**. |

**Onde:**

- **url:** endereço do endpoint;
- **data:** dados a serem enviados ou atualizados;
- **options:** configurações opcionais, como cabeçalhos e tokens.

<br />

> [!IMPORTANT]
>
> Por retornar **Promises**, o Axios permite trabalhar com **.then()/.catch()** ou **async/await**, tornando o código mais limpo e legível, especialmente em requisições encadeadas ou com tratamento de erros mais complexo.
>
> Por Boas Práticas, utilizaremos no Projeto Blog Pessoal a sintaxe **async/await**.

<br />

<img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="4%"/>**Exemplo Ilustrativo**

<br />

> [!WARNING]
>
> **ATENÇÃO!**
>
> Estes exemplos são **apenas ilustrativos**. **Não inclua estes códigos em nenhum componente ou arquivo** do Projeto Blog Pessoal. Ele serve apenas para fins de estudo e compreensão dos conceitos apresentados.

<br />

**Consumo com Fetch API**

```js
fetch("https://jsonplaceholder.typicode.com/posts")
  .then(resposta => resposta.json())
  .then(data => console.log(data))
  .catch(erro => console.error(erro));
```

**Consumo com Axios**

```js
import axios from "axios";

async function carregarPosts() {
  try {
    const resposta = await axios.get("https://jsonplaceholder.typicode.com/posts");
    console.log(resposta.data);
  } catch (erro) {
    console.error(erro);
  }
}

carregarPosts();

```

Nos dois exemplos apresentados está sendo realizada exatamente a **mesma requisição GET** para o endpoint:  `https://jsonplaceholder.typicode.com/posts`. 

O objetivo é buscar uma lista de posts de uma API pública e exibir o resultado no console.

A diferença está na forma como cada modelo lida com essa requisição:

- **Com Fetch** utilizamos a API nativa do JavaScript, que já está disponível no navegador sem a necessidade de instalar nada. O processo acontece em duas etapas: primeiro recebemos a resposta bruta (`Response`) e, em seguida, precisamos convertê-la para JSON chamando o método `.json()`. Além disso, o tratamento de erros é feito encadeando `.catch()`.
- **Com Axios** usamos uma biblioteca externa, que precisa ser instalada no projeto, mas que traz mais praticidade. O retorno já vem estruturado em `resposta.data`, sem a necessidade de conversão manual. O código também ganha legibilidade com o uso de `async/await` e o tratamento de erros via `try/catch`. Outro ponto é que o Axios oferece recursos extras, como configuração de timeouts, interceptors para modificar requisições e cancelamento de chamadas.

Embora ambos os exemplos façam a mesma requisição GET, o **Fetch representa a forma mais “pura” e manual**, enquanto o **Axios entrega uma experiência mais simples, direta e poderosa** para o desenvolvedor.

<br />

<div align="left"><img src="https://i.imgur.com/A94hGdN.png" title="source: imgur.com" width="4%"/> <a href="https://axios-http.com/" target="_blank"><b>Axios - Documentação Oficial</b></a></div>

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
