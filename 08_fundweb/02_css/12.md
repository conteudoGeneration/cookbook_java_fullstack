<h1>Flexbox</h1>



Atualmente, devido à grande variedade de dispositivos — celulares, tablets, notebooks e desktops — **é essencial que os layouts se adaptem automaticamente a diferentes tamanhos de tela**. Essa adaptação é conhecida como **Design Responsivo**.

> **Design Responsivo** é uma abordagem ao design da Web que faz  as páginas da web renderizarem (carregarem) de forma personalizada, de acordo com dispositivo e o tamanho da janela ou tela, do mínimo ao máximo. 

Quando falamos em Design Responsivo, os modelos mais utilizados no mercado, sem sombra de dúvidas são o **CSS Flexbox Layout** e o **CSS Grid Layout**. 

Neste conteúdo, focaremos no **CSS Flexbox Layout** e no próximo veremos o  **CSS Grid Layout**.  

<br />

<h2>1. O que é o Flexbox?</h2>



**Flexbox** é a  abreviação de ***"Flexible Box Layout"***. É um modelo de layout CSS que  simplifica a criação de layouts complexos. Ele fornece uma maneira  flexível de alinhar elementos e distribuir o espaço dentro de um  elemento, que está inserido dentro de um contêiner.

O Flexbox é um modelo de layout **unidimensional** do CSS, projetado para organizar elementos em linha ou coluna, facilitando o alinhamento, a distribuição de espaço e a adaptação do layout a diferentes tamanhos de tela.

<br />

<h3>1.1. Quais são os benefícios de usar o Flexbox?</h3>



Antes do Flexbox, era difícil criar layouts complexos e páginas da web  responsivas. Com o Flexbox, você pode criar layouts responsivos com menos dificuldade e menos linhas de código. O Flexbox permite:

- Alinhar e centralizar elementos usando propriedades;
- Desenvolver layouts responsivos sem escrever muitas consultas de mídia;
- Reordenar os elementos na tela sem alterar a estrutura HTML;
- Criar colunas de mesma altura sem elementos HTML extras ou imagens de fundo.

<br />

<h3>1.2. O Eixo Principal (main axis) e o Eixo Transversal (cross axis)</h3>



A primeira coisa que você precisa entender sobre o Flexbox é o conceito de eixos. Cada recipiente flexível (um elemento com a Propriedade `display` definida como `flex` ou `inline-flex`) tem um eixo principal e um eixo transversal.

O eixo principal é horizontal ou vertical, dependendo do valor da propriedade `flex-direction`, como vemos nas imagens abaixo:

O eixo principal será o horizontal e eixo transversal será o vertical quando a propriedade `flex-direction` for definida com o valor `row`.

<div align="center"><img src="https://i.imgur.com/1FoEghw.png" title="source: imgur.com" /></div>

O eixo principal será o vertical e o eixo transversal será o horizontal quando a propriedade `flex-direction` for definida com o valor `column`.

<div align="center"><img src="https://i.imgur.com/SKpJfRE.png" title="source: imgur.com" /></div>

<br />

<h3>1.3. Propriedade Display</h3>



Para usar todas as propriedades do Flexbox, a primeira coisa que você precisa definir é a propriedade `display` do elemento container (div, por exemplo), com o valor `flex` ou o valor `inline-flex`, transformando este elemento em um container flexível. Todos os elementos que estiverem dentro do elemento container (chamados de child ou filhos), também se tornam itens flexíveis do elemento container.

Vamos ver isso na prática:

<img src="https://i.imgur.com/ZWD22yi.png" title="source: imgur.com" width="4%"/> **Projeto Exemplo**



Antes de prosseguirmos, faça a clonagem do nosso Projeto Guia:

1. Acesse o Repositório do **Projeto Guia** clicando [aqui](https://github.com/rafaelq80/exemplos_fundweb)
2. Clone o Repositório do **Projeto Guia** na sua máquina
3. Abra o Projeto **01_css_flexbox** no Visual Studio Code
4. Abra Página **index.html** no Navegador, através do **Live Server**.

Ao executar Projeto **Layout-Flexbox** você verá o seguinte resultado na tela:

<div align="center"><img src="https://i.imgur.com/h4cSHpO.png" title="source: imgur.com" /></div>

Abra o arquivo CSS **style.css** e adicione a linha `display: flex;` na classe `.container`, indicado no trecho de código abaixo:

<div align="center"><img src="https://imgur.com/y8T7f0O.png" title="source: imgur.com" /></div>

Observe que  o contêiner flexível se comportará como um elemento de nível de bloco, que ocupa toda a largura disponível. 

<div align="center"><img src="https://i.imgur.com/H3jYkfb.png" title="source: imgur.com" /></div>

No arquivo CSS **style.css** altere a linha `display: flex;` na classe `.container`, para  `display: inline-flex;` conforme indicado no trecho de código abaixo:

<div align="center"><img src="https://i.imgur.com/OPU0yuT.png" title="source: imgur.com" /></div>

Observe que  o contêiner flexível se comportará como um elemento de nível em linha, ocupando apenas o espaço necessário.

<div align="center"><img src="https://i.imgur.com/WCm76NG.png" title="source: imgur.com" /></div>

<br />

<div align="left"><img src="https://i.imgur.com/63FhSvn.png" title="source: imgur.com" width="4%"/> <a href="https://www.w3schools.com/cssref/pr_class_display.php" target="_blank"><b>Documentação: Display</b></a></div>

<br />

<h2>2. Propriedades do Flex Container</h2>



As propriedades do contêiner flex permitem que você controle o layout e o alinhamento dos itens flexíveis dentro de um contêiner flexível. Importante destacar que você aplica essas propriedades no contêiner flexível e não nos seus itens. Vamos conhecer a principais propriedades do Flex Container.

<br />

<h3>2.1. Propriedade flex-direction</h3>



A propriedade `flex-direction` define a direção em que os itens flexíveis serão exibidos, ou seja, define o eixo principal do recipiente flexível. Esta propriedade pode receber os seguintes valores:

- `row`: Valor padrão, exibe os elementos em linha.
- `column`: Exibe os elementos em coluna.
- `row-reverse`: Exibe os elementos em linha, na ordem inversa.
- `column-reverse`: Exibe os elementos em coluna, na ordem inversa.

Vamos testar as 4 possibilidades, adicionando a propriedade `flex-direction` na classe `.container`, como mostra o trecho de código abaixo: 

<div align="center"><img src="https://i.imgur.com/P3RapmV.png" title="source: imgur.com" /></div>

Experimente trocar os valores da propriedade `flex-direction`. Os Resultados esperados você confere nas imagens abaixo:

|                     flex-direction: row;                     |                 flex-direction: row-reverse;                 |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| <img src="https://i.imgur.com/WCm76NG.png" title="source: imgur.com" /> | <img src="https://i.imgur.com/2zOK1Ng.png" title="source: imgur.com" /> |
|                 **flex-direction: column;**                  |             **flex-direction: column-reverse;**              |
| <img src="https://i.imgur.com/eqQv5z0.png" title="source: imgur.com" /> | <img src="https://i.imgur.com/ya5QE2f.png" title="source: imgur.com" /> |

Um ponto importante sobre as propriedades  `row-reverse`  e  `column-reverse` é que ambas modificam a ordem visual dos elementos na tela, mas a ordem em seu HTML permanece inalterada. Inclusive, é a ordem que os  leitores de tela e os controles de navegação do teclado utilizarão.

<br />

<div align="left"><img src="https://i.imgur.com/63FhSvn.png" title="source: imgur.com" width="4%"/> <a href="https://www.w3schools.com/cssref/css3_pr_flex-direction.php" target="_blank"><b>Documentação: Flex Direction</b></a></div>

<br />

<h3>2.2. Propriedade flex-wrap</h3>



Quando o espaço dentro do recipiente flexível não é suficiente para os itens flexíveis, você pode utilizar a propriedade `flex-wrap` para escolher se quer deixar os itens flexíveis transbordarem ou começarem em uma nova linha. Esta propriedade pode receber os seguintes valores:

- `nowrap`: Mantém todos os itens flexíveis em uma única linha ou em uma única coluna. Ele permite que os itens flexíveis transbordem se não houver  espaço suficiente no recipiente flexível. 
- `wrap`: Move os itens flexíveis para a próxima linha se não houver espaço suficiente para eles.
- `wrap-reverse`: Move os itens flexíveis para a próxima linha se não houver espaço suficiente para eles, invertendo a ordem de exibição dos elementos.

Antes de testarmos a propriedade `flex-wrap`, vamos alterar o tamanho dos nossos elementos, modificando a propriedade `width` para `600px`, na classe `.child`, como mostra o trecho de código abaixo:

<div align="center"><img src="https://i.imgur.com/LdBAOaY.png" title="source: imgur.com" /></div>

Vamos testar as 3 possibilidades, adicionando a propriedade `flex-wrap` na classe `.container`, como mostra o trecho de código abaixo: 

<div align="center"><img src="https://i.imgur.com/0d9n95n.png" title="source: imgur.com" /></div>

Experimente trocar os valores da propriedade `flex-direction`. Os Resultados esperados você confere nas imagens abaixo:

|                      flex-wrap: nowrap;                      |
| :----------------------------------------------------------: |
| <img src="https://i.imgur.com/tg0FU2E.png" title="source: imgur.com" /> |
|                     **flex-wrap: wrap;**                     |
| <img src="https://i.imgur.com/ESlUUz5.png" title="source: imgur.com" /> |
|                 **flex-wrap: wrap-reverse;**                 |
| <img src="https://i.imgur.com/fIuJBGX.png" title="source: imgur.com" /> |

<br />

<div align="left"><img src="https://i.imgur.com/63FhSvn.png" title="source: imgur.com" width="4%"/> <a href="https://www.w3schools.com/cssref/css3_pr_flex-wrap.php" target="_blank"><b>Documentação: Flex Wrap</b></a></div>

<br />

<h3>2.3. Propriedade flex</h3>



No **Flexbox**, a propriedade `flex` é uma forma abreviada de controlar **como os itens flexíveis crescem, encolhem e ocupam o espaço disponível** dentro de um container (`display: flex`). Ela combina três propriedades em uma única declaração:

```css
flex: flex-grow flex-shrink flex-basis;
```

Vamos entender cada uma das 3 propriedades:

✅ `flex-basis`

O **`flex-basis`** define o **tamanho inicial** do item antes de crescer ou encolher.

Em outras palavras, antes de começar a distribuir espaço, cada item já “começa” com um tamanho pré definido.

<br />

Antes de testarmos a propriedade `flex-basis`, vamos alterar o tamanho dos nossos elementos, modificando a propriedade `width` para `100px`, na classe `.child`, como mostra o trecho de código abaixo:

<div align="center"><img src="https://i.imgur.com/XSzjfZD.png" title="source: imgur.com" /></div>

Remova a propriedade `flex-wrap` da classe `.container`, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/wreIrAX.png" title="source: imgur.com" /></div>

Observe que as propriedades `display` e `flex-direction` foram mantidas.

Vamos adicionar a propriedade `flex-basis` em cada uma das 4 classes, que estilizam os nossos elementos, com valores variados, como mostra o trecho de código abaixo:

<div align="center"><img src="https://i.imgur.com/2zylzbD.png" title="source: imgur.com" /></div>

O Resultado esperado você confere na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/xxsT4TK.png" title="source: imgur.com" /></div>

Observe que:

- O **item 01** (`flex-basis: auto`) teve seu **tamanho original respeitado**, pois o valor `auto` considera a largura ou o conteúdo definido no elemento.
- O **item 02** (`flex-basis: 0%`) teve seu **tamanho inicial ignorado**, permitindo que o elemento **ocupe apenas o espaço disponível** no contêiner flex.
- Os **itens 03 e 04** tiveram seus **tamanhos calculados com base nos valores definidos em `flex-basis`**, ajustando-se proporcionalmente conforme o espaço disponível no layout.

Esse comportamento demonstra como o `flex-basis` influencia diretamente o tamanho inicial dos itens antes da aplicação das regras de crescimento (`flex-grow`) e encolhimento (`flex-shrink`).

<br />

✅ `flex-grow`

O **`flex-grow`** controla **quanto cada item cresce** quando existe espaço livre no container.

Imagine uma barra horizontal com espaço sobrando. Cada item “puxa” esse espaço de acordo com seu valor de `flex-grow`.

Antes de testarmos a propriedade `flex-grow`, altere a propriedade `display` da classe `.container` para `flex`, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/T7M4cOa.png" title="source: imgur.com" /></div>

Vamos alterar a propriedade **`flex-basis`** de todas as quatro classes para **`auto`**, garantindo que cada item utilize o **tamanho definido pelo seu conteúdo ou pela propriedade `width`** como ponto de partida.

Em seguida, adicionaremos a propriedade **`flex-grow`** com valores diferentes para cada classe (elemento), permitindo observar **como o espaço disponível no container é distribuído proporcionalmente** entre os itens, conforme indicado no trecho de código abaixo.

<div align="center"><img src="https://i.imgur.com/UEb8Mjj.png" title="source: imgur.com" /></div>

O Resultado esperado você confere na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/0Eanzxn.png" title="source: imgur.com" /></div>

Observe que, considerando **`flex-basis: auto`**:

- Os **itens 01 e 04** (`flex-grow: 1`) **cresceram de forma proporcional e igual**, partindo do **tamanho original de cada elemento**.
- O **item 02** (`flex-grow: 0`) **não participou da distribuição do espaço livre**, mantendo exatamente o seu **tamanho inicial**.
- O **item 03** (`flex-grow: 2`) **recebeu o dobro do espaço disponível** em relação aos itens com `flex-grow: 1`, sempre considerando como base o tamanho original do elemento.

Esse comportamento evidencia que, com `flex-basis: auto`, o **tamanho inicial do conteúdo é respeitado**, e o `flex-grow` atua **apenas na distribuição do espaço livre restante** dentro do contêiner flex.

<br />

✅  `flex-shrink`

O **`flex-shrink`** entra em ação quando **não há espaço suficiente** no container. 

Em outras palavras, todos os itens começam grandes demais para caber na tela. O navegador reduz o tamanho conforme o valor definido na propriedade `flex-shrink`.

Antes de testarmos a propriedade `flex-shrink`, vamos alterar o tamanho dos nossos elementos, modificando a propriedade `width` para `600px`, na classe `.child`, como mostra o trecho de código abaixo:

<div align="center"><img src="https://i.imgur.com/LdBAOaY.png" title="source: imgur.com" /></div>

Vamos manter a propriedade **`flex-basis`** de todas as quatro classes para **`auto`**, garantindo que cada item utilize o **tamanho definido pelo seu conteúdo ou pela propriedade `width`** como ponto de partida.

Em seguida, substituiremos a propriedade **`flex-grow`** pela propriedade **`flex-shrink`** com valores diferentes para cada classe (elemento), permitindo observar **como o espaço disponível no container é distribuído proporcionalmente** entre os itens, conforme indicado no trecho de código abaixo.

<div align="center"><img src="https://i.imgur.com/Cn2HmGK.png" title="source: imgur.com" /></div>

O Resultado esperado você confere na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/Z0sSuii.png" title="source: imgur.com" /></div>

Observe que, considerando **`flex-basis: auto`** e **todos os elementos com `width: 600px`**:

- Os **itens 01 e 04** (`flex-shrink: 1`) **encolheram de forma proporcional e igual**, reduzindo seus tamanhos para que todos os itens coubessem no contêiner.
- O **item 02** (`flex-shrink: 0`) **não sofreu redução**, mantendo os **600px definidos**, mesmo quando o espaço disponível foi insuficiente.
- O **item 03** (`flex-shrink: 2`) **encolheu o dobro** em relação aos itens com `flex-shrink: 1`, absorvendo uma parte maior da redução necessária.

Esse comportamento demonstra que, com `flex-basis: auto`, o **tamanho inicial (width)** é usado como referência, e o `flex-shrink` define **quanto cada item pode reduzir proporcionalmente** quando o espaço do contêiner é menor que a soma dos tamanhos dos itens.

Os exemplos acima, mostram que:

- `flex-basis` define o ponto de partida
- `flex-grow` atua quando sobra espaço
- `flex-shrink` atua quando falta espaço

<br />

## O que significa `flex: 1`?

Quando você escreve:

```css
.item {
  flex: 1;
}
```

Está utilizando a forma abreviada (*shorthand*) da propriedade `flex`, que equivale a:

```css
.item {
  flex-grow: 1;
  flex-shrink: 1;
  flex-basis: 0%;
}
```

Na prática, isso significa que:

- **`flex-grow: 1`** → o item pode crescer e participar da distribuição do espaço disponível
- **`flex-shrink: 1`** → o item pode encolher caso o container não tenha espaço suficiente
- **`flex-basis: 0%`** → o tamanho inicial do item é desconsiderado, priorizando a divisão proporcional do espaço

Como consequência, **todos os itens com `flex: 1` passam a dividir igualmente o espaço do container**, independentemente do tamanho do conteúdo interno ou de larguras previamente definidas.

Essa configuração é muito comum em layouts onde o objetivo é **equilibrar visualmente os elementos**, como colunas, cards ou seções de mesmo peso.

<br />

**Boas práticas**

- Utilize `flex: 1` quando desejar **divisão igual de espaço** entre os itens
- Combine valores diferentes (`flex: 1`, `flex: 2`, `flex: 3`) para criar **proporções e hierarquia visual**
- Prefira `flex: auto` quando o **conteúdo precisar influenciar o tamanho inicial**
- Evite misturar `flex: 1` com larguras fixas sem planejamento, pois isso pode gerar conflitos de layout
- Sempre teste o comportamento com **conteúdo real e em diferentes tamanhos de tela**

<br />

<div align="left"><img src="https://i.imgur.com/63FhSvn.png" title="source: imgur.com" width="4%"/> <a href="https://www.w3schools.com/cssref/css3_pr_flex.php" target="_blank"><b>Documentação: flex</b></a></div>

<br />

<h3>2.4. Propriedade justify-content</h3>



A propriedade **justify-content** lida com o alinhamento dos itens flexíveis no eixo principal do recipiente flexível. Você pode usá-la para definir como o espaço é distribuído no eixo principal. Esta propriedade pode receber os seguintes valores:

- `flex-start`: Coloca os itens no início do eixo principal. Se o eixo principal é horizontal ele alinha os itens à esquerda. Se o eixo for vertical ele alinha os itens no topo.
- `flex-end`: Coloca os itens no final do eixo principal. Se o eixo principal é horizontal ele alinha os itens à direita. Se o eixo for vertical ele alinha os itens na base.
- `center`: Coloca os itens no centro do eixo principal. 
- `space-between`: Coloca o primeiro item flexível no início do eixo principal e o último item no final do eixo principal. Em seguida, o espaço no eixo principal é distribuído igualmente entre os elementos.
- `space-around`: Distribui o espaço igualmente entre os itens flexíveis. Isso significa que o espaço antes e depois de cada item é o mesmo.
- `space-evenly`: Distribui o espaço igualmente entre os itens flexíveis. A principal  diferença aqui é que o espaço antes do primeiro item e depois do último  item é maior do que o espaço entre os itens flexíveis.

Antes de testarmos a propriedade `justify-content`, vamos alterar o tamanho dos nossos elementos, modificando a propriedade `width` para `100px`, na classe `.child`, como mostra o trecho de código abaixo:

<div align="center"><img src="https://i.imgur.com/XSzjfZD.png" title="source: imgur.com" /></div>

Vamos testar as 6 possibilidades, adicionando a propriedade `justify-content` na classe `.container` como mostra o trecho de código abaixo: 

<div align="center"><img src="https://i.imgur.com/kiK1NQM.png" title="source: imgur.com" /></div>

Experimente trocar os valores da propriedade `justify-content` no container Flexbox. Cada valor altera o **alinhamento dos itens no eixo principal (horizontal, quando `flex-direction: row`)**. Os **resultados esperados** podem ser conferidos nas imagens abaixo.

|             justify-content: flex-start;              |
| :---------------------------------------------------: |
| ![source: imgur.com](https://i.imgur.com/N6sRNrE.png) |
|            **justify-content: flex-end;**             |
| ![source: imgur.com](https://i.imgur.com/wsd2T7A.png) |
|             **justify-content: center;**              |
| ![source: imgur.com](https://i.imgur.com/Hu6aj9i.png) |
|          **justify-content: space-between;**          |
| ![source: imgur.com](https://i.imgur.com/YNO6QuF.png) |
|          **justify-content: space-around;**           |
| ![source: imgur.com](https://i.imgur.com/7RaV8hR.png) |
|          **justify-content: space-evenly;**           |
| ![source: imgur.com](https://i.imgur.com/2Zsu72O.png) |

<br />

<div align="left"><img src="https://i.imgur.com/63FhSvn.png" title="source: imgur.com" width="4%"/> <a href="https://www.w3schools.com/cssref/css3_pr_justify-content.php" target="_blank"><b>Documentação: Justify Content</b></a></div>

<br />

<h3>2.5. Propriedade align-items</h3>



A propriedade **align-items** lida com o alinhamento dos itens flexíveis no eixo cruzado do recipiente flexível. Esta propriedade geralmente recebe os seguintes valores:

- **`flex-start`**: posiciona os itens no **início do eixo transversal**. Se o eixo transversal for horizontal, os itens ficam alinhados à esquerda; se for vertical, ficam alinhados ao topo.
- **`flex-end`**: posiciona os itens no **final do eixo transversal**. Se o eixo transversal for horizontal, os itens ficam alinhados à direita; se for vertical, ficam alinhados à base.
- **`center`**: posiciona os itens no **centro do eixo transversal**, distribuindo o espaço igualmente acima e abaixo (ou à esquerda e à direita, conforme o eixo).
- **`stretch`**: **estica os itens automaticamente ao longo do eixo transversal**, fazendo com que ocupem todo o espaço disponível do contêiner. Esse comportamento ocorre quando os itens **não possuem altura (ou largura) definida**, sendo o valor padrão de `align-items`.

Antes de testarmos a propriedade **`align-items`**, vamos **remover a definição de altura dos quatro elementos**. Para isso, eliminaremos a propriedade **`height`** da classe **`.child`**, permitindo que cada item assuma **sua altura natural**, baseada apenas no conteúdo interno.

Essa alteração é importante porque facilita a **visualização do alinhamento vertical no Flexbox**. Quando todos os elementos possuem a mesma altura fixa, o efeito do `align-items` pode não ficar evidente. Ao remover a altura, conseguimos observar com mais clareza como os itens são posicionados ao longo do **eixo transversal (vertical)** do contêiner flex.

Após remover a propriedade **`height`** da classe **`.child`**, o código ficará semelhante ao ilustrado na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/yh7roxC.png" title="source: imgur.com" /></div>

Vamos testar as **quatro possibilidades da propriedade `align-items`**, adicionando essa configuração na classe **`.container`**. Para que o comportamento do alinhamento vertical fique mais evidente, **definiremos a altura do contêiner como `70vh`**, criando um espaço vertical suficiente para visualizar claramente as diferenças entre cada valor aplicado.

Com essa altura definida, será possível observar como os elementos se posicionam ao longo do **eixo transversal (vertical)** do Flexbox, conforme o valor de `align-items` utilizado, como mostra o trecho de código abaixo:

<div align="center"><img src="https://i.imgur.com/kLjHV4Y.png" title="source: imgur.com" /></div>

Experimente trocar os valores da propriedade `align-items` no container Flexbox. Cada valor altera o **alinhamento dos itens no eixo cruzado (vertical, quando `flex-direction: row`)**. Os **resultados esperados** podem ser conferidos nas imagens abaixo.

|               align-items: flex-start;                |
| :---------------------------------------------------: |
| ![source: imgur.com](https://i.imgur.com/auIc9qF.png) |
|              **align-items: flex-end;**               |
| ![source: imgur.com](https://i.imgur.com/pu5zkb4.png) |
|               **align-items: center;**                |
| ![source: imgur.com](https://i.imgur.com/dkjm9US.png) |
|               **align-items: stretch;**               |
| ![source: imgur.com](https://i.imgur.com/ydY83pR.png) |

<br />

> [!WARNING]
>
> As propriedades **`justify-content`** e **`align-items`** são diretamente influenciadas pelo valor de **`flex-direction`**, pois elas atuam em eixos diferentes do layout flexível.
>
> - **`justify-content`** alinha os itens ao longo do **eixo principal**, que varia conforme o `flex-direction`.
> - **`align-items`** alinha os itens ao longo do **eixo transversal** (perpendicular ao eixo principal).
>
> Por exemplo, com `flex-direction: row`, o eixo principal é **horizontal**; já com `flex-direction: column`, o eixo principal passa a ser **vertical**, alterando o efeito visual dessas propriedades.

<br />

<div align="left"><img src="https://i.imgur.com/63FhSvn.png" title="source: imgur.com" width="4%"/> <a href="https://www.w3schools.com/cssref/css3_pr_align-items.php" target="_blank"><b>Documentação: Align Items</b></a></div>

<div align="left"><img src="https://i.imgur.com/63FhSvn.png" title="source: imgur.com" width="4%"/> <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank"><b>Tutorial: Guia Completo do Flexbox - CSS Tricks</b></a></div>

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
