<h1>TypeScript: O Básico para o Frontend - Parte 01</h1>



Neste conteúdo, faremos um **overview dos principais recursos da linguagem TypeScript**, destacando que a maioria desses recursos **foi herdada do JavaScript**, já que o TypeScript é um **superset** da linguagem.

Ao longo deste material, o foco será compreender **o que o TypeScript adiciona ao JavaScript**, como tipagem estática, verificações em tempo de desenvolvimento e melhorias na organização do código, mantendo total compatibilidade com o ecossistema JavaScript.

<br />

<h2>1. O que vai mudar em relação ao JavaScript?</h2>



Com relação a todos os conteúdos vistos até o presente momento com a linguagem **JavaScript**, a principal mudança ao utilizar a linguagem **TypeScript** está na **tipagem estática** de variáveis, constantes e arrays. No entanto, além da tipagem, existem outras diferenças importantes que são **específicas do TypeScript**, principalmente relacionadas à forma de organização do código.

Na tabela abaixo, apresentamos um resumo objetivo do que **muda** e do que **permanece igual** ao migrar de JavaScript para TypeScript:

| Conteúdo                   | Mudanças? | Descrição                                                    |
| -------------------------- | --------- | ------------------------------------------------------------ |
| **Script (arquivo)**       | ✔         | Os arquivos TypeScript utilizam a extensão **.ts**.          |
| **Execução do Código**     | ✔         | É necessário instalar o **transpilador do TypeScript** e configurar o ambiente para gerar e executar o JavaScript resultante. |
| **Comentários**            | ❌         | ---                                                          |
| **Variáveis e Constantes** | ✔         | Continuam sendo declaradas com **let** e **const**, seguindo as mesmas regras do JavaScript, porém agora recebem **tipos de dados explícitos** (tipagem estática). |
| **Saída de dados**         | ❌         | ---                                                          |
| **Entrada de dados**       | ❌         | ---                                                          |
| **Operadores**             | ❌         | ---                                                          |
| **Laços Condicionais**     | ❌         | ---                                                          |
| **Laços de Repetição**     | ❌         | ---                                                          |
| **Vetores e Matrizes**     | ✔         | A declaração continua sendo feita com **let**, porém os arrays passam a ter **tipos definidos**, garantindo maior segurança e previsibilidade. |

De forma geral, o TypeScript **preserva a base do JavaScript**, mas adiciona recursos que aumentam a **segurança**, a **organização** e a **manutenibilidade** do código, especialmente em projetos maiores e mais complexos.

<br />

<h2>2. Variáveis Tipadas</h2>



O **TypeScript** disponibiliza diversos recursos que estendem e complementam o **JavaScript**. Entre eles, o mais importante e relevante é a **tipagem estática**.

Com o TypeScript, é possível definir explicitamente **o tipo de dado que uma variável pode receber**, **o tipo de retorno de uma função** e **os tipos dos parâmetros**, entre outras situações. Essa abordagem permite que erros comuns sejam identificados **em tempo de desenvolvimento**, antes mesmo da execução do código, tornando as aplicações mais **seguras**, **previsíveis** e **fáceis de manter**, especialmente em projetos de médio e grande porte.

<br />

<h3>2.1. Por que tipar o JavaScript?</h3>



Uma das principais vantagens do **TypeScript** é o suporte à **tipagem estática**, que contribui diretamente para a **qualidade e confiabilidade** do código. 

Ao definir tipos para variáveis, parâmetros e retornos de funções, o desenvolvedor reduz significativamente a ocorrência de erros, facilitando o processo de **depuração** (*debug*) e tornando o comportamento da aplicação mais previsível.

No **JavaScript**, problemas relacionados a tipos de dados só são identificados **em tempo de execução**, o que pode dificultar a detecção da causa do erro e aumentar o risco de falhas em produção. Já no **TypeScript**, esses problemas são detectados **em tempo de desenvolvimento**, durante a transpilação, permitindo correções antecipadas, maior produtividade e um código mais seguro e fácil de manter.

<br />

<h3>2.2. Declaração de Variáveis</h3>



No **TypeScript**, assim como no **JavaScript moderno**, as variáveis podem ser declaradas utilizando as palavras-chave **`let`** ou **`var`**, seguidas por um identificador e, opcionalmente, por uma **anotação de tipo**, definida após dois pontos (**`:`**).

<br />

> [!TIP]
>
> As **Boas práticas** recomendam priorizar o uso de **`let`** ou **`const`** em vez de **`var`**, pois `var` possui **escopo de função**, o que pode causar comportamentos inesperados, especialmente em estruturas condicionais e laços de repetição.

<br />

> [!IMPORTANT]
>
>  O **TypeScript é capaz de inferir tipos automaticamente** com base no valor atribuído à variável. Ainda assim, a **declaração explícita do tipo** é altamente recomendada, pois torna o código mais **legível**, **autoexplicativo** e **seguro**, facilitando a manutenção e reduzindo a chance de erros ao longo do desenvolvimento.

<br />

**Sintaxe:**

**Sem atribuição de valor**

```typescript
let identificador_da_variável: tipo;
```

Nesse formato, a variável é declarada com um **tipo explícito**, porém **sem valor inicial**. Após o identificador, utilizamos **dois pontos (`:`)** seguidos do **tipo de dado** que a variável deverá receber.

Essa abordagem permite que o compilador do TypeScript aplique **verificações de tipo antecipadas**, impedindo que valores incompatíveis sejam atribuídos futuramente.

**Com atribuição de valor**

```typescript
let identificador_da_variável: tipo = valor;
```

Nesse caso, além da declaração da variável e da anotação de tipo, ocorre também a **inicialização imediata** com um valor **compatível com o tipo definido**.

Essa é a forma mais comum de declaração, pois melhora a **legibilidade do código**, facilita o entendimento da intenção da variável e reforça a **segurança de tipos** durante o desenvolvimento.

<br />

<h3>2.3. Tipos de dados</h3>



Os **tipos de dados do TypeScript** podem ser resumidos na imagem abaixo. Eles são, em grande parte, herdados do JavaScript, porém com o benefício adicional da **verificação estática de tipos**.

<div align="center"><img src="https://i.imgur.com/AnoulGf.png" title="source: imgur.com" /></div>

<br />

| Tipo            | Descrição                                                    |
| --------------- | ------------------------------------------------------------ |
| **`any`**       | Representa **qualquer tipo de valor**. Ao utilizar `any`, a verificação de tipos do TypeScript é desativada, permitindo atribuir qualquer valor à variável. Deve ser usado com cautela, pois compromete a segurança, a previsibilidade e os benefícios da tipagem estática. |
| **`number`**    | No JavaScript e no TypeScript, **todos os valores numéricos pertencem ao tipo `number`**, incluindo inteiros e números de ponto flutuante. Exemplos: `10`, `3.14`, `-7`. Não existe distinção entre `int` e `float`, como em outras linguagens. |
| **`string`**    | Representa **sequências de caracteres Unicode**, utilizadas para armazenar e manipular textos. Strings podem ser delimitadas por aspas simples (`'`), aspas duplas (`"`) ou *template literals* (crase: ```). |
| **`boolean`**   | Tipo lógico que aceita apenas **dois valores possíveis**: `true` ou `false`. É amplamente utilizado em estruturas condicionais, comparações e expressões lógicas. |
| **`null`**      | Representa a **ausência intencional de valor**. Quando uma variável recebe `null`, significa que ela foi explicitamente definida como vazia. |
| **`undefined`** | Representa uma variável **declarada, mas não inicializada**. Também pode ser retornado ao acessar propriedades inexistentes ou quando uma função não possui retorno explícito. |

<br />

> [!TIP]
>
> Diferente de linguagens como **Java** e **C#**, em que o tipo `String` é escrito com **letra maiúscula**, no **TypeScript** (assim como no JavaScript), os tipos primitivos são escritos **em letras minúsculas**, como `string`, `number` e `boolean`.

<br />

> [!IMPORTANT]
>
> Embora o tipo `any` possa ser útil em cenários específicos, como **migração de código legado** ou **integração com bibliotecas JavaScript externas**, prefira sempre **tipos mais específicos**.
>
> Ferramentas de análise estática, como o **SonarQube** e o **Lint**, geralmente desaconselham o uso de `any`, podendo inclusive gerar alertas críticos conforme as regras do projeto.

<br />

## <img src="https://i.imgur.com/bT8YpxS.png" title="source: imgur.com" width="4%"/>**Exemplo 01 - Declaração de Variáveis**

```typescript
let nome: string = "Generation";
let sobrenome: string = "Brasil";
let numero_01: number = 10;
let numero_02: number = 20.5;

console.log(`Nome: ${nome}`);
console.log(`Sobrenome: ${sobrenome}`);
console.log(`Numero 01: ${numero_01}`);
console.log(`Numero 02: ${numero_02}`);
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="4%"/>**Resultado do Algoritmo:**

```typescript
Nome: Generation
Sobrenome: Brasil
Numero 01: 10
Numero 02: 20.5
```

O código acima cria 4 variáveis e exibe o seu conteúdo na tela.

<br />

<h4>2.3.1. Valores especiais do tipo Number</h4>



O tipo **`number`** no TypeScript (assim como no JavaScript) possui **valores especiais** que representam resultados **inválidos, indeterminados ou infinitos** em operações matemáticas. Esses valores são importantes para **identificar erros lógicos**, divisões inválidas ou situações extremas durante cálculos numéricos.

| Valor           | Descrição                                                    |
| --------------- | ------------------------------------------------------------ |
| **`NaN`**       | `NaN` significa *Not-a-Number*. Apesar do nome, trata-se de um valor do tipo `number` que indica o resultado de **uma operação matemática inválida**, como `parseInt("abc")`, `Math.sqrt(-1)` ou `0 / 0`. É uma propriedade do **objeto global**. |
| **`Infinity`**  | Representa um valor **infinito positivo**, geralmente resultante de operações como `1 / 0`. Também é uma propriedade do **objeto global** e possui tipo `number`. Qualquer número positivo multiplicado por `Infinity` resulta em `Infinity`, e qualquer número finito dividido por `Infinity` resulta em `0`. |
| **`-Infinity`** | Representa um valor **infinito negativo**, como em `-1 / 0`. Possui o mesmo comportamento do `Infinity`, porém com sinal negativo, e também é do tipo `number`. |

<br />

> [!TIP]
>
> Embora `NaN`, `Infinity` e `-Infinity` pertençam ao tipo `number`, eles possuem **comportamentos especiais** que exigem atenção.
>
> - Comparar `NaN` com qualquer valor, inclusive com ele mesmo (`NaN === NaN`), retorna `false`.
> - Para verificar corretamente se um valor é `NaN`, utilize:
>
> ```typescript
> Number.isNaN(valor);
> ```
>
> O uso de `Number.isNaN()` é preferível ao `isNaN()`, pois evita coerções implícitas e torna a verificação mais segura e previsível.

<br />

## <img src="https://i.imgur.com/bT8YpxS.png" title="source: imgur.com" width="4%"/>**Exemplo 02 - Tipos Especiais NaN e Infinity**

```typescript
const resultadoInvalido: number = 0 / 0;
const valorInfinito: number = 1 / 0;
const valorNegativoInfinito: number = -100 / 0; 

console.log(resultadoInvalido); 
console.log(valorInfinito);    
console.log(valorNegativoInfinito);
```

 <img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="4%"/>**Resultado do Algoritmo:**

```bash
NaN
Infinity
-Infinity
```

O código acima demonstra os valores especiais do tipo number: `NaN` e `Infinity`.

- Dividir zero por zero (`0 / 0`) **não é uma operação válida** matematicamente. Logo o retorno será `NaN` (Not a Number), que indica que o resultado **não é um número válido**.
- Dividir um número positivo por zero é matematicamente indefinido, mas em JavaScript/TypeScript, isso resulta em um valor especial chamado **`Infinity`**.
- Da mesma forma que o anterior, porém o número é negativo. Isso resulta em **`-Infinity`**.

<br />

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#the-primitives-string-number-and-boolean" target="_blank"><b>Documentação - TypeScript: Tipos de dados</b></a></div>

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#null-and-undefined" target="_blank"><b>Documentação - TypeScript: Null e Undefined</b></a></div>

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Infinity" target="_blank"><b>Documentação: Infinity</b></a></div>

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/NaN" target="_blank"><b>Documentação: NaN</b></a></div>

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN" target="_blank"><b>Documentação: Função isNaN()</b></a></div>

<br />

<h3>2.4. Declaração de Constantes</h3>



No **TypeScript**, a declaração de uma **constante** é semelhante à declaração de uma variável, porém com uma regra fundamental: **o valor atribuído não pode ser reatribuído após a inicialização**. 

Para declarar uma constante, utiliza-se a palavra-chave **`const`**, seguida do identificador e do valor. A anotação de tipo é **opcional**, pois o TypeScript é capaz de **inferir automaticamente o tipo** com base no valor atribuído.

A palavra-chave **`const`** pode ser utilizada para declarar **valores primitivos**, **arrays** e **objetos**. Entretanto, é importante compreender que o `const` **protege a referência**, e não necessariamente o conteúdo. Isso significa que:

- A constante **não pode apontar para outro valor ou objeto**;
- Porém, **o conteúdo interno de arrays e objetos pode ser modificado**, pois esses tipos são manipulados por **referência**.

**Sintaxe:**

```js
const identificador_da_constante: tipo = valor;
```

Diferentemente das variáveis declaradas com `let` ou `var`, uma constante **deve obrigatoriamente ser inicializada no momento da declaração**. Caso a atribuição do valor seja omitida, o compilador do TypeScript emitirá um erro, garantindo maior segurança e previsibilidade no código.

<br />

## <img src="https://i.imgur.com/bT8YpxS.png" title="source: imgur.com" width="4%"/>**Exemplo 03 - Declaração de  Constantes**

```typescript
const estado: string = "São Paulo";
console.log(`Estado: ${estado}`);
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="4%"/>**Resultado do Algoritmo:**

```
Estado: São Paulo
```

Neste exemplo, a constante **`estado`** é declarada com o tipo `string` e inicializada com o valor `"São Paulo"`. Como se trata de uma constante, **seu valor não pode ser alterado por atribuição após a declaração**.

Ao tentar reatribuir um novo valor:

```typescript
estado = "Rio de Janeiro";
```

O TypeScript irá gerar um **erro em tempo de compilação**, impedindo a execução do código:

```bash
Cannot assign to 'estado' because it is a constant.ts(2588)
```

Esse comportamento reforça a segurança do código, evitando alterações acidentais em valores que devem permanecer fixos durante a execução da aplicação.

<br />

> [!IMPORTANT]
>
> ### `const` não garante imutabilidade de objetos em TypeScript
>
> Ao utilizar `const`, o TypeScript **impede apenas a reatribuição da referência**, e não a modificação do conteúdo interno.
>
> Em objetos e arrays, é possível alterar propriedades ou elementos internos, pois esses tipos são manipulados **por referência**. Para garantir imutabilidade real, é necessário utilizar abordagens adicionais, como `readonly`, `Readonly<T>` ou bibliotecas específicas de imutabilidade.

<br />

## <img src="https://i.imgur.com/bT8YpxS.png" title="source: imgur.com" width="4%"/>**Exemplo 04 - Declaração de  Constantes - Objeto**

```javascript
export const usuario: { nome: string } = { nome: "João da Silva" };

usuario.nome = "João da Silva Junior";

console.log("O Nome do Usuário é:", usuario.nome);
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="4%"/>**Resultado do Código:**

```bash
O Nome do Usuário é: João da Silva Junior
```

Neste exemplo, a constante **`usuario`** aponta sempre para o **mesmo objeto na memória**. Entretanto, como objetos são **tipos por referência**, suas **propriedades internas podem ser modificadas**, mesmo quando o objeto é declarado com `const`.

Isso ocorre porque o `const` impede apenas a **reatribuição da referência**, e não a alteração do estado interno do objeto.

> Esse comportamento é semelhante ao que ocorre em linguagens orientadas a objetos como **Java** ou **C#**.
>
> A instrução `usuario.nome = valor` é conceitualmente equivalente a uma chamada como `usuario.setNome(valor)`.

Agora observe o que acontece ao tentar **atribuir um novo objeto** à constante `usuario`:

<br />

## <img src="https://i.imgur.com/bT8YpxS.png" title="source: imgur.com" width="4%"/>**Exemplo 04.1. - Declaração de  Constantes - Objeto**

```typescript
export const usuario: { nome: string } = { nome: "João da Silva" };

usuario = { nome: "João da Silva Junior" };

```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="4%"/>**Resultado do Código:**

```bash
Cannot assign to 'usuario' because it is a constant.ts(2588)
```

Nesse caso, o TypeScript gera um **erro de compilação**, pois a tentativa envolve a **reatribuição da constante**, o que não é permitido.

> ### Resumindo:
>
> - `const` **não permite reatribuição do identificador**.
> - Para **tipos primitivos** (`string`, `number`, `boolean`, etc.), o valor realmente não pode ser alterado.
> - Para **objetos e arrays**, a referência é fixa, mas **o conteúdo interno pode ser modificado**.
>
> Para evitar alterações internas, utilize recursos como `readonly`, `Readonly<T>` ou padrões de imutabilidade.

<br />

<h2>3.Array</h2>



O TypeScript utiliza o **objeto `Array` do JavaScript**, adicionando a ele o conceito de **tipagem estática**, o que garante maior segurança e previsibilidade no uso de listas de dados.

Um array tipado define **qual tipo de dado pode ser armazenado em suas posições**, evitando inserções incorretas em tempo de compilação.

**Sintaxe — Array vazio**

```typescript
const nome_do_array: Array<T> = new Array<T>();
```

- O construtor sem argumentos cria um **array vazio**.
- O `T` representa um **Generic**, que define o tipo dos elementos do array.
- Esse tipo pode ser:
  - **Primitivo** (`number`, `string`, `boolean`, etc.).
  - **Estruturado** (objetos, interfaces ou classes definidas pelo desenvolvedor).

**Sintaxe — Array inicializado**

```typescript
const nome_do_array: Array<T> = new Array<T>(elemento1, elemento2, ..., elementoN);
```

- Os elementos iniciais são passados como parâmetros do construtor.
- Todos os elementos devem respeitar o tipo definido em `T`.

Se preferir, o TypeScript também oferece uma sintaxe mais comum e simples para arrays, usando colchetes:

```typescript
const nome_do_array: T[] = [elemento1, elemento2, elemento3];
```

- Esta é a **forma mais utilizada** no TypeScript.
- É mais simples, legível e amplamente adotada em projetos reais.
- O tipo `T` garante que todos os elementos do array sejam do mesmo tipo.

<br />

<h3>3.1. Principais Métodos do Objeto Array</h3>



A tabela abaixo apresenta os **principais métodos e propriedades** do objeto `Array`, amplamente utilizados no dia a dia:

| Método / Propriedade                       | Descrição                                                    |
| ------------------------------------------ | ------------------------------------------------------------ |
| **length**                                 | Propriedade que retorna o tamanho do array                   |
| **push(elemento)**                         | Adiciona um elemento ao final do array e retorna o novo tamanho |
| **unshift(...elementos)**                  | Adiciona um ou mais elementos ao início do array e retorna o novo tamanho |
| **splice(indice, quantidade, elementos?)** | Remove e/ou adiciona elementos a partir de um índice específico. Retorna os elementos removidos |
| **shift()**                                | Remove e retorna o primeiro elemento do array                |
| **pop()**                                  | Remove e retorna o último elemento do array                  |
| **sort([comparador])**                     | Ordena os elementos do array. Sem comparador, ordena como strings |
| **reverse()**                              | Inverte a ordem dos elementos do array                       |
| **includes(elemento)**                     | Verifica se um elemento existe no array (`true` ou `false`)  |
| **indexOf(elemento)**                      | Retorna o índice da primeira ocorrência do elemento ou `-1`  |
| **lastIndexOf(elemento)**                  | Retorna o índice da última ocorrência do elemento ou `-1`    |

<br />

> ### Observações importantes:
>
> - O índice de um array **sempre começa em 0**.
> - `length` é uma **propriedade**, não um método (não utiliza parênteses).
> - `unshift` aceita **quantidade variável de elementos**.
> - `splice` **retorna os elementos removidos**, e não o array resultante.
> - `sort`, sem função comparadora, realiza ordenação **lexicográfica** (como strings).
> - `reverse` apenas **inverte a ordem atual**, não realiza ordenação numérica decrescente.

<br />

## <img src="https://i.imgur.com/bT8YpxS.png" title="source: imgur.com" width="4%"/> Exemplo 05 - Array:

```ts
// Cria um array do tipo number chamado notas e inicializa com valores
const notas: Array<number> = new Array<number>(7.0, 5.0, 4.0, 10.0);

/* Exibe todas as notas na tabela */
console.table(notas);

/* Adiciona uma nova nota */
notas.push(4.0);

// Mostra o índice da primeira ocorrência da nota 5
console.log("\nA posição da nota 5 é: " + notas.indexOf(5));

// Verifica se a nota 5 existe no array
console.log("\nA nota 5 existe no array? " + notas.includes(5));

// Mostra a nota na posição 1 do array
console.log("\nNa posição 1 do array, a nota é: " + notas[1]);

// Altera a nota 5.0 para 6.0 e mostra que a alteração foi efetuada
notas[notas.indexOf(5)] = 6.0;

// Remove a primeira ocorrência da nota 4.0 e mostra que a exclusão foi efetuada
notas.splice(notas.indexOf(4.0), 1);

// Exibe o tamanho atual do array (número de elementos)
console.log("\nO tamanho do array é: " + notas.length);

/* Exibe todas as notas atualizadas */
console.table(notas);
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="4%"/> **Resultado do Algoritmo:**

```bash
┌─────────┬────────┐
│ (index) │ Values │
├─────────┼────────┤
│    0    │   7    │
│    1    │   5    │
│    2    │   4    │
│    3    │   10   │
└─────────┴────────┘

A posição da nota 5 é: 1

A nota 5 existe no array? true

Na posição 1 da array, a nota é: 5

O tamanho do array é: 4

┌─────────┬────────┐
│ (index) │ Values │
├─────────┼────────┤
│    0    │   7    │
│    1    │   6    │
│    2    │   10   │
│    3    │   4    │
└─────────┴────────┘
```

Mesmo declarando o array com **`const`**, o seu **conteúdo interno pode ser modificado** por meio dos métodos da classe `Array`. O uso de `const` **impede apenas a reatribuição da variável**, ou seja, a variável `notas` não pode apontar para outro array, mas os **elementos internos podem ser adicionados, removidos ou alterados** normalmente.

<br />

<h3>3.2. Métodos de Manipulação de Arrays</h3>



Além dos métodos básicos de inserção e remoção, também existem  diversos métodos que permitem **manipular os dados de um array sem alterar o array original**. 

Esses métodos são amplamente utilizados em abordagens de **programação funcional**, pois favorecem a **imutabilidade**, tornando o código mais previsível, seguro e fácil de manter.

A seguir, alguns dos principais métodos de manipulação de arrays:

| Método       | Descrição                                                    |
| ------------ | ------------------------------------------------------------ |
| `concat()`   | Combina dois ou mais arrays e retorna um **novo array**, sem modificar os arrays originais. |
| `slice()`    | Retorna uma **cópia parcial do array** (subarray), definida por índices, sem alterar o array original. |
| `forEach()`  | Executa uma função para **cada elemento do array**, sem retornar um novo array. É usado principalmente para efeitos colaterais. |
| `map()`      | Cria um **novo array**, contendo o resultado da função aplicada a cada elemento do array original. |
| `filter()`   | Retorna um **novo array** com os elementos que atendem a uma condição específica. |
| `reduce()`   | Aplica uma função acumuladora aos elementos do array, resultando em um **único valor** (soma, média, objeto, etc.). |
| `find()`     | Retorna o **primeiro elemento** que satisfaz a condição informada ou `undefined` se não encontrar nenhum. |
| `some()`     | Retorna `true` se **ao menos um elemento** satisfizer a condição. |
| `every()`    | Retorna `true` se **todos os elementos** satisfizerem a condição. |
| `join()`     | Concatena todos os elementos do array em uma **string**, usando um separador definido. |
| `toString()` | Converte o array em uma **string com elementos separados por vírgula**. |

<br />

## <img src="https://i.imgur.com/bT8YpxS.png" title="source: imgur.com" width="4%"/> Exemplo 05.1 - Array - Manipulação de dados:

```ts
export const numeros: number[] = [1, 2, 3, 4, 5];

// map() - cria um novo array com o dobro de cada número
const dobrados: number[] = numeros.map((num: number) => num * 2);
console.log('Dobro:', dobrados); // [2, 4, 6, 8, 10]

// filter() - filtra números maiores que 3
const maioresQueTres: number[] = numeros.filter((num: number) => num > 3);
console.log('Maiores que 3:', maioresQueTres); // [4, 5]

// reduce() - soma todos os números do array
const soma: number = numeros.reduce((acumulador: number, valor: number) => acumulador + valor, 0);
console.log('Soma:', soma); // 15

// find() - encontra o primeiro número par
const primeiroPar: number | undefined = numeros.find((num: number) => num % 2 === 0);
console.log('Primeiro par:', primeiroPar); // 2

// some() - verifica se existe algum número maior que 4
const existeMaiorQueQuatro: boolean = numeros.some((num: number) => num > 4);
console.log('Existe número > 4?', existeMaiorQueQuatro); // true

// every() - verifica se todos são menores que 10
const todosMenoresQueDez: boolean = numeros.every((num: number) => num < 10);
console.log('Todos menores que 10?', todosMenoresQueDez); // true

// concat() - junta outro array
const maisNumeros: number[] = numeros.concat([6, 7, 8]);
console.log('Array concatenado:', maisNumeros); // [1, 2, 3, 4, 5, 6, 7, 8]

// slice() - obtém uma parte do array
const parte: number[] = numeros.slice(1, 4);
console.log('Slice:', parte); // [2, 3, 4]

// join() - cria uma string com os elementos separados por hífen
const stringNumeros: string = numeros.join(' - ');
console.log('Join:', stringNumeros); // "1 - 2 - 3 - 4 - 5"

```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="4%"/> **Resultado do Algoritmo:**

```bash
Dobro: [ 2, 4, 6, 8, 10 ]
Maiores que 3: [ 4, 5 ]   
Soma: 15
Primeiro par: 2
Existe número > 4? true   
Todos menores que 10? true
Array concatenado: [      
  1, 2, 3, 4,
  5, 6, 7, 8
]
Slice: [ 2, 3, 4 ]
Join: 1 - 2 - 3 - 4 - 5
```

O exemplo acima, demonstra algumas formas de utilizar os métodos de manipulação dos arrays.

> [!NOTE]
>
> ### Observações sobre TypeScript
>
> - As variáveis recebem **tipos explícitos** (`number[]`, `number`, `boolean`, `string`), o que **reduz a ocorrência de erros em tempo de desenvolvimento**, melhora a **legibilidade** e facilita a **manutenção do código**.
> - O método `find` pode retornar **um elemento do próprio tipo do array ou `undefined`**, caso nenhum valor atenda à condição definida. Por esse motivo, o tipo de retorno deve ser declarado como **`number | undefined`**, garantindo segurança de tipo.
> - Em **arrays aninhados com tipos mistos**, utiliza-se uma tipagem mais genérica, como **`(number | number[])[]`**. Já o método `flat` pode produzir resultados com **estrutura variável**, dependendo do nível de profundidade informado, o que faz com que o TypeScript **infera o tipo como `any[]`** nesses casos.

<br />

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank"><b>Documentação: Classe Array</b></a></div>

<div align="left"><img src="https://i.imgur.com/r9lrbPG.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Array" target="_blank"><b>Documentação: Método Array()</b></a></div>

<br />

<h2>4. Functions</h2>



No **TypeScript**, é possível definir explicitamente os **tipos dos parâmetros** e o **tipo do valor retornado** por uma função. Essa característica aumenta a **segurança**, melhora a **legibilidade** do código e permite a **detecção precoce de erros**, ainda em tempo de desenvolvimento.

<br />

## <img src="https://i.imgur.com/bT8YpxS.png" title="source: imgur.com" width="4%"/> Exemplo 06 - Função com  retorno:

```typescript
function subtrair(numero1: number, numero2: number): number {
    return numero1 - numero2
}

let resultado: number = subtrair(20, 10);

console.log(`Subtração: ${resultado}`);
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="4%"/>**Resultado do Código:**

```bash
Subtração: 10
```

O tipo declarado após os parênteses da função (`: number`) indica explicitamente o **tipo de retorno**, garantindo que a função sempre devolva um valor compatível com esse tipo.

Quando a função **não retorna nenhum valor**, utiliza-se o tipo especial **`void`**, conforme demonstrado no exemplo a seguir:

<br />

## <img src="https://i.imgur.com/bT8YpxS.png" title="source: imgur.com" width="4%"/> Exemplo 07- Função sem retorno:

```typescript
function tabuada(numero: number): void {

    for (let contador = 1; contador <= 10; contador++){
        
        let resultado = numero * contador;
        console.log(`${numero} x ${contador} = ${resultado}`);

    }
        
}

console.log("Tabuada:\n");

tabuada(5);
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="4%"/>**Resultado do Código:**

```bash
Tabuada:

5 x 1 = 5
5 x 2 = 10
5 x 3 = 15
5 x 4 = 20
5 x 5 = 25
5 x 6 = 30
5 x 7 = 35
5 x 8 = 40
5 x 9 = 45
5 x 10 = 50
```

O tipo **`void`** indica que a função **não deve retornar nenhum valor**, ou seja, sua finalidade é apenas executar uma ação.

Além disso, uma função pode possuir **parâmetros opcionais**, que são identificados pelo caractere **`?`** após o nome do parâmetro. Esses parâmetros **não são obrigatórios** na chamada da função.

<br />

## <img src="https://i.imgur.com/bT8YpxS.png" title="source: imgur.com" width="4%"/> Exemplo 08- Função com parâmetros opcionais:

```typescript
function somar(numero1: number, numero2: number, numero3?: number): number{
    
    if(numero3 != undefined)
        return numero1 + numero2 + numero3;

    return numero1 + numero2;
}

const resultado1 = somar(10, 20);
console.log(`Soma: ${resultado1}`);

const resultado2 = somar(10, 20, 30);
console.log(`Soma: ${resultado2}`);
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="4%"/>**Resultado do Código:**

```bash
Primeira Soma: 30
Segunda Soma: 60
```

Observe que o **terceiro parâmetro** foi marcado como opcional por meio do caractere **`?`**, permitindo que a função seja chamada tanto com dois quanto com três argumentos.

<br />

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#functions" target="_blank"><b>Documentação - TypeScript: Funções</b></a></div>

<br />

<h2>5. Arrow Functions</h2>



As **Arrow Functions** são uma forma mais **concisa e moderna** de declarar funções em JavaScript e TypeScript. Além da sintaxe enxuta, elas possuem uma característica importante: **não criam seu próprio contexto de `this`**, preservando o valor do `this` do escopo onde foram definidas (escopo léxico).

No **TypeScript**, é possível tipar explicitamente os **parâmetros** e o **valor de retorno** das arrow functions, garantindo maior **segurança**, **legibilidade** e **manutenibilidade** do código.

**Sintaxe:**

```typescript
(parâmetros: tipo): tipoDeRetorno => expressão
```

Uma **Arrow Function** é composta por:

- **Parâmetros:** Podem ser tipados individualmente.
- **Operador Arrow (`=>`)**: Separa os parâmetros do corpo da função.
- **Corpo da função:** Pode ser uma única expressão (com retorno implícito) ou um bloco de código delimitado por `{}` (com retorno explícito).

<br />

<h3>5.1. Características das Arrow Functions no TypeScript</h3>



### ✅Parênteses nos parâmetros

- Os **parênteses são opcionais** quando há apenas **um parâmetro**.
- São **obrigatórios** quando há **zero ou mais de um parâmetro**.

```typescript
// Um parâmetro - parênteses opcionais
export const exibir = (n: number): void => console.log(n);

// Dois parâmetros - parênteses obrigatórios
const somar = (n1: number, n2: number): void => console.log(n1 + n2);

exibir(5);
somar(5, 10);
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="4%"/>**Resultado do Algoritmo:**

```bash
5
15
```

<br />

### ✅Corpo da função com ou sem chaves

- Quando a função possui **apenas uma expressão**, as chaves `{}` são opcionais.
- Quando há **mais de uma instrução**, as chaves são obrigatórias.

```typescript
// Lista de números
const numeros: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];

// Arrow function com múltiplas instruções no corpo
numeros.forEach((numero: number): void => {
  if (numero % 3 === 0) {
    console.log(numero);
  }
});
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="4%"/>**Resultado do Algoritmo:**

```bash
3
6
9
```

<br />

### ✅Retorno implícito e explícito

- Se a função tiver **apenas uma expressão**, o `return` é **implícito**.
- Em funções com **bloco de código**, o `return` deve ser **explícito**.

```typescript
// Com return explícito
const comReturn = (n1: number, n2: number): number => {
  return n1 + n2;
};

// Com retorno implícito
const semReturn = (n1: number, n2: number): number => n1 + n2;

console.log(comReturn(1, 2));
console.log(semReturn(1, 2));
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="4%"/>**Resultado do Algoritmo:**

```bash
3
3
```

<br />

No próximo **exemplo**, vamos utilizar uma **Arrow Function** para chamar o método `forEach()` para percorrer um array de números e exibir cada elemento no console. 

Esse exemplo demonstra como as arrow functions tornam o código **mais enxuto**, **legível** e **expressivo**, especialmente em operações comuns de iteração sobre arrays, muito utilizadas no desenvolvimento moderno com JavaScript e TypeScript.

## <img src="https://i.imgur.com/bT8YpxS.png" title="source: imgur.com" width="4%"/> Exemplo 09- Arrow Functions:

```typescript
const numeros: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];

console.log("Exibir os itens\n");

// Exibir os itens da lista com Arrow Function
numeros.forEach((numero: number): void => console.log(numero));
```

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="4%"/>**Resultado do Algoritmo:**

```bash
Exibir os itens

1
2
3
4
5
6
7
8
9
```

Neste exemplo, a tipagem explícita do array e do parâmetro da função garante **segurança de tipos**, enquanto o uso do `forEach()` reforça a prática de trabalhar com funções como argumentos, um conceito fundamental da programação funcional.

<br />

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="20px"/><a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#arrow-functions" target="_blank"><b>Documentação - TypeScript: Arrow Functions</b></a> </div>

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="4%"/>Voltar</a></div>
